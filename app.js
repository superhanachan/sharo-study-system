const DEFAULT_QUIZ_DATA = [
    {
        id: "pension-1",
        title: "å›½æ°‘å¹´é‡‘æ³• è³‡æ ¼å–ªå¤±ã®æ™‚æœŸ (æ³•9æ¡) å¼·åˆ¶è¢«ä¿é™ºè€…",
        columns: ["é …ç›®", "å½“æ—¥å–ªå¤±", "ç¿Œæ—¥å–ªå¤±"],
        questions: [
            { id: "q-1", text: "ã‚¤ï¼‰æ­»äº¡ã—ãŸã¨ã", answer: "ç¿Œæ—¥å–ªå¤±" },
            { id: "q-2", text: "ãƒ‹ï¼‰åšç”Ÿå¹´é‡‘ä¿é™ºæ³•ã«åŸºã¥ãè€é½¢çµ¦ä»˜ç­‰ã‚’å—ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹è€…ãã®ä»–ã“ã®æ³•å¾‹ã®é©ç”¨ã‚’é™¤å¤–ã™ã¹ãç‰¹åˆ¥ã®ç†ç”±ãŒã‚ã‚‹è€…ã¨ã—ã¦åšç”ŸåŠ´åƒçœä»¤ã§å®šã‚ã‚‹è€…ã¨ãªã£ãŸã¨ãï¼ˆç¬¬2å·è¢«ä¿é™ºè€…åˆã¯ç¬¬3å·è¢«ä¿é™ºè€…ã«è©²å½“ã™ã‚‹ã¨ãã‚’é™¤ãï¼‰", answer: "å½“æ—¥å–ªå¤±" },
            { id: "q-3", text: "ãƒï¼‰60æ­³ã«é”ã—ãŸã¨ãï¼ˆç¬¬2å·è¢«ä¿é™ºè€…ã«è©²å½“ã™ã‚‹ã¨ãã‚’é™¤ãï¼‰", answer: "å½“æ—¥å–ªå¤±" }
        ]
    },
    {
        id: "survivor-rank-1",
        title: "ã€ç‰¹è¨“ã€‘éºæ—ã®é †ä½åˆ¤å®šï¼ˆã‚¹ãƒªãƒ ç‰ˆï¼‰",
        isMultiSelect: true,
        columns: [
            "é †ä½", "ã€ç”Ÿè¨ˆç¶­æŒã€‘", "ã€ç”Ÿè¨ˆåŒä¸€ã€‘", "é…å¶è€…", "å­", "çˆ¶æ¯", "å­«", "ç¥–çˆ¶æ¯", "å…„å¼Ÿå§‰å¦¹", "3è¦ªç­‰ä»¥å†…", "å¯¾è±¡ãªã—"
        ],
        questions: [
            { id: "q-surv-1", text: "ç¬¬1é †ä½", answer: ["é…å¶è€…", "å­", "ã€ç”Ÿè¨ˆç¶­æŒã€‘"] },
            { id: "q-surv-2", text: "ç¬¬2é †ä½", answer: ["çˆ¶æ¯", "ã€ç”Ÿè¨ˆç¶­æŒã€‘"] },
            { id: "q-surv-3", text: "ç¬¬3é †ä½", answer: ["å­«", "ã€ç”Ÿè¨ˆç¶­æŒã€‘"] },
            { id: "q-surv-4", text: "ç¬¬4é †ä½", answer: ["ç¥–çˆ¶æ¯", "ã€ç”Ÿè¨ˆç¶­æŒã€‘"] },
            { id: "q-surv-5", text: "ç¬¬5é †ä½", answer: ["å¯¾è±¡ãªã—"] },
            { id: "q-surv-6", text: "ç¬¬6é †ä½", answer: ["å¯¾è±¡ãªã—"] }
        ]
    }
];

class QuizApp {
    constructor() {
        this.quizData = this.loadData();
        this.history = this.loadHistory();
        this.questionStats = this.loadQuestionStats();
        this.currentSetId = this.quizData[0].id;
        this.isEditMode = false;
        this.isAutoGenerated = false;

        this.userAnswers = {};
        this.isChecked = false;
        this.sortColumnIndex = -1;
        this.sortDirection = 1;

        this.chartMode = 'accuracy';
        this.statsChart = null;

        this.migrateData();
        this.cacheDOM();
        this.bindEvents();
        this.init();
    }

    migrateData() {
        let modified = false;

        // 1. Inject/Update Survivor Sample (Check for "ã‚¹ãƒªãƒ ç‰ˆ" or column count change)
        const currentRank = this.quizData.find(s => s.id === "survivor-rank-1");
        const defaultRank = DEFAULT_QUIZ_DATA.find(s => s.id === "survivor-rank-1");

        if (!currentRank || (currentRank.columns && currentRank.columns[1] !== "ã€ç”Ÿè¨ˆç¶­æŒã€‘")) {
            if (currentRank) {
                this.quizData = this.quizData.filter(s => s.id !== "survivor-rank-1");
            }
            this.quizData.push(JSON.parse(JSON.stringify(defaultRank)));
            modified = true;
        }

        this.quizData.forEach(set => {
            if (!set.type) set.type = 'page';
            if (set.parentId === undefined) set.parentId = null;
            if (set.isCollapsed === undefined) set.isCollapsed = false;

            if (set.type === 'page') {
                if (!set.questions) return;
                set.questions.forEach(q => {
                    if (!q.id) { q.id = 'q-' + Math.random().toString(36).substr(2, 9) + Date.now(); modified = true; }
                    if (set.isMultiSelect && typeof q.answer === 'string') {
                        q.answer = [q.answer];
                        modified = true;
                    }
                    if (q.isInPool === undefined) {
                        q.isInPool = true;
                        modified = true;
                    }
                });
            }
        });

        // 2. Safe cleanup of questionStats
        // BUG FIX: Only cleanup stats if quizData is successfully loaded and has content.
        // If quizData is somehow empty or fallback-only but stats exist, we MUST NOT wipe them.
        if (this.quizData && this.quizData.length > 0) {
            const cleanedStats = {};
            const allIds = new Set();
            this.quizData.forEach(set => {
                if (set.type === 'page' && set.questions) set.questions.forEach(q => allIds.add(q.id));
            });

            let hasWiped = false;
            Object.keys(this.questionStats).forEach(key => {
                if (allIds.has(key)) {
                    cleanedStats[key] = this.questionStats[key];
                    // Initialize recent history for older data
                    if (!cleanedStats[key].recent) {
                        const t = cleanedStats[key].total || 0;
                        const c = cleanedStats[key].correct || 0;
                        const count = Math.min(t, 5);
                        const r = [];
                        const recentCorrect = t > 0 ? Math.round((c / t) * count) : 0;
                        for (let i = 0; i < count; i++) r.push(i < recentCorrect ? 1 : 0);
                        cleanedStats[key].recent = r;
                    }
                } else {
                    // Log or backup orphaned stats if needed, but for now, just track if we're deleting
                    hasWiped = true;
                }
            });

            // SAFETY: If we are about to wipe more than 50% of stats, something might be wrong.
            // In a real data loss scenario, quizData might be default (2 items) while stats are 100+.
            if (hasWiped && Object.keys(this.questionStats).length > 10 && Object.keys(cleanedStats).length < (Object.keys(this.questionStats).length / 2)) {
                console.warn("Migration safety triggered: Excessive stat cleanup prevented.");
            } else {
                this.questionStats = cleanedStats;
            }
        }

        if (modified) this.saveData();
        this.saveQuestionStats();
    }

    cacheDOM() {
        this.tabQuiz = document.getElementById('tab-quiz');
        this.tabStats = document.getElementById('tab-stats');
        this.quizView = document.getElementById('quiz-view');
        this.statsView = document.getElementById('stats-view');
        this.tocList = document.getElementById('toc-list');
        this.quizTitle = document.getElementById('quiz-title');
        this.tableHead = document.getElementById('table-head');
        this.tableBody = document.getElementById('table-body');
        this.scoreDisplay = document.getElementById('score');
        this.editModeToggle = document.getElementById('edit-mode-toggle');
        this.addFolderBtn = document.getElementById('add-folder-btn');
        this.addPageBtn = document.getElementById('add-page-btn');
        this.addRowBtn = document.getElementById('add-row-btn');
        this.addColumnBtn = document.getElementById('add-column-btn');
        this.clearDataBtn = document.getElementById('clear-data-btn');
        this.deletePageBtn = document.getElementById('delete-page-btn');
        this.clonePageBtn = document.getElementById('clone-page-btn');
        this.checkAnswersBtn = document.getElementById('check-answers-btn');
        this.resetQuizBtn = document.getElementById('reset-quiz-btn');

        this.totalAccuracy = document.getElementById('total-accuracy');
        this.totalAnsweredDisplay = document.getElementById('total-answered');
        this.historyBody = document.getElementById('history-body');
        this.weakQuestionsBody = document.getElementById('weak-questions-body');
        this.genWeakBtn = document.getElementById('gen-weak-btn');
        this.genRareBtn = document.getElementById('gen-rare-btn');
        this.genRandomBtn = document.getElementById('gen-random-btn');

        this.chartBtns = {
            accuracy: document.getElementById('show-accuracy-btn'),
            frequency: document.getElementById('show-frequency-btn'),
            errors: document.getElementById('show-errors-btn')
        };
        this.sidebar = document.getElementById('sidebar');
        this.sidebarContent = document.getElementById('quiz-sidebar-content');
        this.menuToggle = document.getElementById('menu-toggle');

        // Data management
        this.exportJsonBtn = document.getElementById('export-json-btn');
        this.importJsonBtn = document.getElementById('import-json-btn');
        this.exportCsvBtn = document.getElementById('export-csv-btn');
        this.importCsvBtn = document.getElementById('import-csv-btn');
        this.dataImportInput = document.getElementById('data-import-input');
        this.dataStatusMsg = document.getElementById('data-status-msg');
    }

    bindEvents() {
        this.tabQuiz.addEventListener('click', () => this.switchView('quiz'));
        this.tabStats.addEventListener('click', () => this.switchView('stats'));
        this.editModeToggle.addEventListener('change', (e) => {
            this.isEditMode = e.target.checked;
            document.body.classList.toggle('edit-mode', this.isEditMode);
            this.updateTitleEditability();
            this.resetQuiz(); this.renderTOC(); this.renderTable();
        });
        this.checkAnswersBtn.addEventListener('click', () => this.batchCheckAnswers());
        this.resetQuizBtn.addEventListener('click', () => this.resetQuiz());
        this.addFolderBtn.addEventListener('click', () => this.addNewFolder());
        this.addPageBtn.addEventListener('click', () => this.addNewPage());
        this.addRowBtn.addEventListener('click', () => this.addNewRow());
        this.addColumnBtn.addEventListener('click', () => this.addNewColumn());
        this.clearDataBtn.addEventListener('click', () => this.clearData());
        this.deletePageBtn.addEventListener('click', () => this.deleteCurrentPage());
        this.clonePageBtn.addEventListener('click', () => this.cloneCurrentPage());

        this.genWeakBtn.addEventListener('click', () => this.generateSpecialQuiz('weak'));
        this.genRareBtn.addEventListener('click', () => this.generateSpecialQuiz('rare'));
        if (this.genRandomBtn) this.genRandomBtn.addEventListener('click', () => this.generateSpecialQuiz('random'));

        Object.keys(this.chartBtns).forEach(mode => {
            this.chartBtns[mode].addEventListener('click', () => {
                this.chartMode = mode;
                this.updateChartTabs();
                this.renderChart();
            });
        });
        this.tocList.addEventListener('click', (e) => { if (e.target.tagName === 'A') { e.preventDefault(); this.isAutoGenerated = false; this.loadSet(e.target.getAttribute('href').substring(1)); } });

        // Update TOC real-time when editing title
        this.quizTitle.addEventListener('input', () => {
            if (this.isEditMode && !this.isAutoGenerated) {
                const set = this.quizData.find(s => s.id === this.currentSetId);
                if (set) {
                    set.title = this.quizTitle.textContent.trim();
                    this.renderTOC();
                }
            }
        });

        this.quizTitle.addEventListener('blur', () => {
            if (this.isEditMode && !this.isAutoGenerated) {
                const set = this.quizData.find(s => s.id === this.currentSetId);
                if (set) {
                    set.title = this.quizTitle.textContent.trim();
                    this.saveData();
                }
            }
        });
        this.menuToggle.addEventListener('click', () => { this.sidebar.classList.toggle('open'); });

        // Data management events
        this.exportJsonBtn.addEventListener('click', () => this.exportToJSON());
        this.importJsonBtn.addEventListener('click', () => { this.dataImportInput.accept = '.json'; this.dataImportInput.click(); });
        this.exportCsvBtn.addEventListener('click', () => this.exportToCSV());
        this.importCsvBtn.addEventListener('click', () => { this.dataImportInput.accept = '.csv'; this.dataImportInput.click(); });
        this.dataImportInput.addEventListener('change', (e) => this.handleFileImport(e));

        // Recovery button for internal backup
        const forceRestoreBtn = document.getElementById('force-restore-internal-btn');
        if (forceRestoreBtn) {
            forceRestoreBtn.addEventListener('click', () => this.checkAndOfferRecovery(true));
        }
    }

    init() {
        this.renderTOC();
        this.loadSet(this.currentSetId);
        this.checkAndOfferRecovery();
        this.checkBackupFrequency();
    }

    loadData() { const saved = localStorage.getItem('sharoQuizData'); return saved ? JSON.parse(saved) : JSON.parse(JSON.stringify(DEFAULT_QUIZ_DATA)); }
    saveData() {
        const dataStr = JSON.stringify(this.quizData);
        localStorage.setItem('sharoQuizData', dataStr);
        // Internal Redundancy: Also save to a backup key
        localStorage.setItem('sharo_auto_backup', JSON.stringify({
            quizData: this.quizData,
            history: this.history,
            questionStats: this.questionStats,
            savedAt: new Date().toISOString()
        }));
    }
    loadHistory() { const saved = localStorage.getItem('sharoQuizHistory'); return saved ? JSON.parse(saved) : []; }
    saveHistory() { localStorage.setItem('sharoQuizHistory', JSON.stringify(this.history)); }
    loadQuestionStats() { const saved = localStorage.getItem('sharoQuestionStats'); return saved ? JSON.parse(saved) : {}; }
    saveQuestionStats() { localStorage.setItem('sharoQuestionStats', JSON.stringify(this.questionStats)); }

    switchView(view) {
        this.tabQuiz.classList.toggle('active', view === 'quiz');
        this.tabStats.classList.toggle('active', view === 'stats');
        this.quizView.classList.toggle('hidden', view !== 'quiz');
        this.statsView.classList.toggle('hidden', view !== 'stats');
        if (view === 'stats') this.renderStats();
    }

    loadSet(id) {
        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === id);
        if (!set || set.type === 'folder') return;

        this.currentSetId = id;
        this.quizTitle.textContent = set.title;
        this.updateTitleEditability();

        this.resetQuiz();
        this.renderTable();
        this.updateActiveTOC(id);
    }

    updateActiveTOC(id) {
        const tocLinks = this.tocList.querySelectorAll('a');
        tocLinks.forEach(a => {
            const isActive = !this.isAutoGenerated && a.getAttribute('href') === `#${id}`;
            a.classList.toggle('active', isActive);
        });
    }

    updateTitleEditability() {
        this.quizTitle.contentEditable = this.isEditMode && !this.isAutoGenerated;
    }

    resetQuiz() { this.userAnswers = {}; this.isChecked = false; this.scoreDisplay.textContent = "æ­£è§£æ•°: 0 / 0"; this.renderTable(); }

    batchCheckAnswers() {
        if (this.isChecked) return;
        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === this.currentSetId);
        let correctCount = 0; let answeredCount = 0;
        set.questions.forEach((q) => {
            const userAnswer = this.userAnswers[q.id];
            if (!userAnswer || (Array.isArray(userAnswer) && userAnswer.length === 0)) return;
            answeredCount++;

            let isCorrect = false;
            const isMulti = this.isAutoGenerated ? q.isMultiSelect : set.isMultiSelect;
            if (isMulti) {
                const correctSet = new Set(q.answer);
                const userSet = new Set(userAnswer);
                isCorrect = (correctSet.size === userSet.size && [...correctSet].every(item => userSet.has(item)));
            } else {
                isCorrect = userAnswer === q.answer;
            }

            if (isCorrect) correctCount++;
            const statKey = q.id;
            if (!this.questionStats[statKey]) {
                this.questionStats[statKey] = { correct: 0, total: 0, recent: [], page: q.origPage || set.title, text: q.text };
            }
            if (!this.questionStats[statKey].recent) this.questionStats[statKey].recent = [];

            this.questionStats[statKey].total++;
            if (isCorrect) this.questionStats[statKey].correct++;

            // Record recent history (last 5)
            this.questionStats[statKey].recent.push(isCorrect ? 1 : 0);
            if (this.questionStats[statKey].recent.length > 5) this.questionStats[statKey].recent.shift();

            this.questionStats[statKey].text = q.text; this.questionStats[statKey].page = q.origPage || set.title;
        });
        this.isChecked = true;
        this.scoreDisplay.textContent = `æ­£è§£æ•°: ${correctCount} / ${answeredCount} (ãƒšãƒ¼ã‚¸åˆè¨ˆ: ${set.questions.length})`;
        this.history.unshift({ timestamp: new Date().toLocaleString(), page: set.title, score: `${correctCount} / ${answeredCount}`, accuracy: answeredCount > 0 ? Math.round((correctCount / answeredCount) * 100) : 0 });
        if (this.history.length > 50) this.history.pop();
        this.saveHistory(); this.saveQuestionStats(); this.renderTable();
    }

    renderStats() {
        if (this.history.length === 0) {
            this.totalAccuracy.textContent = "0%"; this.totalAnsweredDisplay.textContent = "0";
            this.historyBody.innerHTML = '<tr><td colspan="4">å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</td></tr>';
            this.weakQuestionsBody.innerHTML = '<tr><td colspan="4">ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</td></tr>';
            return;
        }
        const avg = Math.round(this.history.reduce((a, b) => a + b.accuracy, 0) / this.history.length);
        this.totalAccuracy.textContent = `${avg}%`; this.totalAnsweredDisplay.textContent = this.history.length;
        this.historyBody.innerHTML = this.history.map(h => `<tr><td>${h.timestamp}</td><td>${h.page}</td><td>${h.score}</td><td>${h.accuracy}%</td></tr>`).join('');

        const statsArray = Object.values(this.questionStats).map(s => {
            const recent = s.recent || [];
            const rTotal = recent.length;
            const rCorrect = recent.reduce((a, b) => a + b, 0);
            const accuracy = rTotal > 0 ? Math.round((rCorrect / rTotal) * 100) : 0;
            return { ...s, accuracy, rTotal, rCorrect };
        }).filter(s => s.total > 0).sort((a, b) => {
            if (a.accuracy !== b.accuracy) return a.accuracy - b.accuracy;
            return a.total - b.total;
        }).slice(0, 10);

        this.weakQuestionsBody.innerHTML = statsArray.map(s => `<tr><td style="text-align: left;">${s.text}</td><td>${s.page}</td><td>${s.total}</td><td style="color: ${s.accuracy < 50 ? 'var(--error)' : 'var(--text-primary)'}">${s.accuracy}%</td></tr>`).join('');
        this.updateChartTabs(); this.renderChart();
    }

    updateChartTabs() { Object.keys(this.chartBtns).forEach(mode => { this.chartBtns[mode].classList.toggle('active', this.chartMode === mode); }); }

    renderChart() {
        const ctx = document.getElementById('statsChart').getContext('2d');
        if (this.statsChart) this.statsChart.destroy();
        const allStats = Object.values(this.questionStats).filter(s => s.total > 0).map(s => {
            const recent = s.recent || [];
            const rTotal = recent.length;
            const rCorrect = recent.reduce((a, b) => a + b, 0);
            const accuracy = rTotal > 0 ? Math.round((rCorrect / rTotal) * 100) : 0;
            const errors = rTotal - rCorrect;
            return { ...s, accuracy, errors, rTotal, rCorrect };
        });
        let sortedStats, data, label, color;
        if (this.chartMode === 'accuracy') { sortedStats = allStats.sort((a, b) => a.accuracy - b.accuracy).slice(0, 10); data = sortedStats.map(s => s.accuracy); label = 'æ­£ç­”ç‡ (%)'; color = '#4cc9f0'; }
        else if (this.chartMode === 'frequency') { sortedStats = allStats.sort((a, b) => b.total - a.total).slice(0, 10); data = sortedStats.map(s => s.total); label = 'è§£ç­”å›æ•° (å›)'; color = '#f72585'; }
        else { sortedStats = allStats.sort((a, b) => b.errors - a.errors).slice(0, 10); data = sortedStats.map(s => s.errors); label = 'æœ€è¿‘ã®èª¤ç­”å›æ•° (å›/5å›ä¸­)'; color = '#ff9f1c'; }
        const labels = sortedStats.map(s => s.text.length > 8 ? s.text.substring(0, 7) + '...' : s.text);
        this.statsChart = new Chart(ctx, {
            type: 'bar', data: { labels: labels, datasets: [{ label: label, data: data, backgroundColor: color + 'dd', borderColor: color, borderWidth: 1, borderRadius: 8 }] },
            options: { responsive: true, maintainAspectRatio: false, indexAxis: 'y', plugins: { legend: { display: false }, tooltip: { callbacks: { title: (items) => sortedStats[items[0].dataIndex].text, label: (item) => `${label}: ${item.raw}` } } }, scales: { x: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: 'rgba(255,255,255,0.6)' } }, y: { grid: { display: false }, ticks: { color: 'rgba(255,255,255,0.8)', font: { size: 12 } } } } }
        });
    }

    generateSpecialQuiz(type) {
        const allQuestions = [];
        this.quizData.forEach(set => {
            set.questions.forEach(q => {
                if (q.isInPool === false) return;
                const stat = this.questionStats[q.id] || { correct: 0, total: 0, recent: [] };
                const recent = stat.recent || [];
                const rTotal = recent.length;
                const rCorrect = recent.reduce((a, b) => a + b, 0);
                const accuracy = rTotal > 0 ? (rCorrect / rTotal) : -1;

                allQuestions.push({
                    id: q.id,
                    text: q.text,
                    answer: q.answer,
                    memo: q.memo || '',
                    origPage: set.title,
                    columns: set.columns,
                    accuracy: accuracy,
                    total: stat.total,
                    isMultiSelect: set.isMultiSelect
                });
            });
        });
        if (allQuestions.length === 0) return;
        let filtered, title;
        if (type === 'weak') {
            title = "ç‰¹è¨“ï¼šè‹¦æ‰‹ãªå•é¡Œãƒ¯ãƒ¼ã‚¹ãƒˆ10";
            filtered = allQuestions.filter(q => q.total > 0).sort((a, b) => {
                if (a.accuracy !== b.accuracy) return a.accuracy - b.accuracy;
                return b.total - a.total;
            }).slice(0, 10);
            if (filtered.length === 0) {
                alert('ã¾ã é–“é•ãˆãŸè¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã¾ãšã¯æ™®é€šã«å­¦ç¿’ã—ã¦å›ç­”ã‚’è¨˜éŒ²ã—ã¦ãã ã•ã„ã€‚');
                return;
            }
        } else if (type === 'random') {
            title = "ç‰¹è¨“ï¼šå…¨å•é¡Œã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ 10å•";
            filtered = allQuestions.sort(() => Math.random() - 0.5).slice(0, 10);
        } else {
            title = "ç‰¹è¨“ï¼šæœªå­¦ç¿’ãƒ»ä½é »åº¦ãªå•é¡Œ10å•";
            filtered = allQuestions.sort((a, b) => {
                if (a.total !== b.total) return a.total - b.total;
                return a.accuracy - b.accuracy;
            }).slice(0, 10);
        }
        this.autoGeneratedSet = { id: 'temp-autogen', title: title, questions: filtered };
        this.isAutoGenerated = true;
        this.switchView('quiz');
        this.loadSet('temp-autogen');
    }

    renderTable() {
        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === this.currentSetId);
        if (!set) return;
        this.tableHead.innerHTML = '';
        const headTr = document.createElement('tr');
        if (this.isAutoGenerated) {
            // Determine columns based on the first question for consistency, or generic if mixed
            const firstQ = set.questions[0];
            const cols = firstQ.columns || ["é …ç›®", "é¸æŠè‚¢"];
            headTr.innerHTML = `<th>${cols[0]}</th>`;
            for (let i = 1; i < cols.length; i++) {
                const th = document.createElement('th');
                th.textContent = cols[i];
                headTr.appendChild(th);
            }
        } else {
            // Pool inclusion checkbox header
            if (this.isEditMode) {
                const thPool = document.createElement('th');
                thPool.innerHTML = 'ç‰¹è¨“';
                thPool.className = 'pool-cell';
                thPool.title = 'ç‰¹è¨“ï¼ˆãŠä»»ã›å•é¡Œï¼‰ã®å¯¾è±¡ã«å«ã‚ã‚‹ã‹';
                headTr.appendChild(thPool);
            }

            set.columns.forEach((col, index) => {
                const th = document.createElement('th');
                const span = document.createElement('span');
                span.textContent = col;
                if (this.isEditMode) {
                    span.contentEditable = true;
                    span.onblur = () => {
                        const oldVal = col;
                        const newVal = span.textContent.trim();
                        if (oldVal !== newVal) {
                            set.columns[index] = newVal;
                            set.questions.forEach(q => {
                                if (Array.isArray(q.answer)) {
                                    q.answer = q.answer.map(a => a === oldVal ? newVal : a);
                                } else if (q.answer === oldVal) q.answer = newVal;
                            });
                            this.saveData();
                            this.renderTable();
                        }
                    };
                    if (index > 0) {
                        const delBtn = document.createElement('span');
                        delBtn.className = 'delete-col-btn';
                        delBtn.innerHTML = 'Ã—';
                        delBtn.onclick = (e) => {
                            e.stopPropagation();
                            this.deleteColumn(index);
                        };
                        th.appendChild(delBtn);
                    }
                }
                th.appendChild(span);
                headTr.appendChild(th);
            });
        }
        this.tableHead.appendChild(headTr);
        this.tableBody.innerHTML = '';
        set.questions.forEach((q) => {
            const tr = document.createElement('tr'); tr.id = `row-${q.id}`;
            const isSetMulti = this.isAutoGenerated ? q.isMultiSelect : set.isMultiSelect;

            if (this.isChecked) {
                const userAnswer = this.userAnswers[q.id];
                if (userAnswer && (!Array.isArray(userAnswer) || userAnswer.length > 0)) {
                    let isAllCorrect = false;
                    if (isSetMulti) {
                        const correctSet = new Set(q.answer); const userSet = new Set(userAnswer);
                        isAllCorrect = (correctSet.size === userSet.size && [...correctSet].every(item => userSet.has(item)));
                    } else { isAllCorrect = userAnswer === q.answer; }
                    tr.classList.add(isAllCorrect ? 'row-correct' : 'row-wrong');
                }
            }
            const tdQ = document.createElement('td'); tdQ.className = 'question-cell';
            if (this.isEditMode && !this.isAutoGenerated) {
                const rowControls = document.createElement('div');
                rowControls.className = 'row-edit-controls';

                const delBtn = document.createElement('span'); delBtn.className = 'delete-row-btn'; delBtn.innerHTML = 'Ã—';
                delBtn.title = 'è¡Œã‚’å‰Šé™¤';
                delBtn.onclick = () => this.deleteRow(q.id);

                const upBtn = document.createElement('span'); upBtn.className = 'move-row-btn'; upBtn.innerHTML = 'â†‘';
                upBtn.title = 'ä¸Šã«ç§»å‹•';
                upBtn.onclick = () => this.moveRow(q.id, -1);

                const downBtn = document.createElement('span'); downBtn.className = 'move-row-btn'; downBtn.innerHTML = 'â†“';
                downBtn.title = 'ä¸‹ã«ç§»å‹•';
                downBtn.onclick = () => this.moveRow(q.id, 1);

                rowControls.appendChild(delBtn);
                rowControls.appendChild(upBtn);
                rowControls.appendChild(downBtn);
                tdQ.appendChild(rowControls);
            }
            if (this.isAutoGenerated && q.origPage) { const tag = document.createElement('div'); tag.className = 'page-tag'; tag.textContent = q.origPage; tdQ.appendChild(tag); }

            // Pool inclusion checkbox cell
            if (!this.isAutoGenerated && this.isEditMode) {
                const tdPool = document.createElement('td');
                tdPool.className = 'pool-cell';
                const poolCheck = document.createElement('input');
                poolCheck.type = 'checkbox';
                poolCheck.checked = q.isInPool !== false;
                poolCheck.onchange = (e) => {
                    q.isInPool = e.target.checked;
                    this.saveData();
                };
                tdPool.appendChild(poolCheck);
                tr.appendChild(tdPool);
            }

            const spanText = document.createElement('span'); spanText.textContent = q.text;
            if (this.isEditMode && !this.isAutoGenerated) { spanText.contentEditable = true; spanText.onblur = () => { q.text = spanText.textContent.trim(); this.saveData(); }; }
            tdQ.appendChild(spanText);

            // Memo block
            if (this.isEditMode && !this.isAutoGenerated) {
                const memoEl = document.createElement('div');
                memoEl.className = 'memo-input';
                memoEl.placeholder = 'ãƒ¡ãƒ¢ãƒ»è§£èª¬ã‚’å…¥åŠ›...';
                memoEl.contentEditable = true;
                memoEl.textContent = q.memo || '';
                memoEl.onblur = () => { q.memo = memoEl.textContent.trim(); this.saveData(); };
                tdQ.appendChild(memoEl);
            } else if (this.isChecked && q.memo) {
                const memoEl = document.createElement('div');
                memoEl.className = 'memo-display';
                memoEl.innerHTML = `<strong>è§£èª¬:</strong> ${q.memo.replace(/\n/g, '<br>')}`;
                tdQ.appendChild(memoEl);
            }

            tr.appendChild(tdQ);

            const activeCols = this.isAutoGenerated ? q.columns || set.columns : set.columns;

            for (let i = 1; i < activeCols.length; i++) {
                const choiceName = activeCols[i]; const td = document.createElement('td'); td.className = 'choice-cell'; td.textContent = choiceName;
                if (isSetMulti) td.classList.add('multi-select');

                if (this.isEditMode && !this.isAutoGenerated) {
                    const isCorrect = isSetMulti ? (Array.isArray(q.answer) && q.answer.includes(choiceName)) : (q.answer === choiceName);
                    if (isCorrect) td.classList.add(isSetMulti ? 'multi-selected' : 'correct');
                    td.onclick = () => {
                        if (isSetMulti) {
                            if (!Array.isArray(q.answer)) q.answer = [];
                            if (q.answer.includes(choiceName)) q.answer = q.answer.filter(a => a !== choiceName);
                            else q.answer.push(choiceName);
                        } else { q.answer = choiceName; }
                        this.saveData(); this.renderTable();
                    };
                } else {
                    const userAnswer = this.userAnswers[q.id];
                    const isSelected = isSetMulti ? (Array.isArray(userAnswer) && userAnswer.includes(choiceName)) : (userAnswer === choiceName);

                    if (this.isChecked) {
                        const isCorrectAnswer = isSetMulti ? (Array.isArray(q.answer) && q.answer.includes(choiceName)) : (q.answer === choiceName);
                        if (isCorrectAnswer) td.classList.add('correct');
                        else if (isSelected) td.classList.add('wrong');
                    } else if (isSelected) td.classList.add('selected');

                    td.onclick = () => {
                        if (!this.isChecked) {
                            if (isSetMulti) {
                                if (!Array.isArray(this.userAnswers[q.id])) this.userAnswers[q.id] = [];
                                if (this.userAnswers[q.id].includes(choiceName)) this.userAnswers[q.id] = this.userAnswers[q.id].filter(a => a !== choiceName);
                                else this.userAnswers[q.id].push(choiceName);
                            } else { this.userAnswers[q.id] = choiceName; }
                            this.renderTable();
                        }
                    };
                }
                tr.appendChild(td);
            }
            this.tableBody.appendChild(tr);
        });
    }

    deleteRow(id) {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (set.questions.length <= 1) { alert('æœ€ä½1è¡Œã¯å¿…è¦ã§ã™ã€‚'); return; }
        if (confirm('ã“ã®è¡Œã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
            set.questions = set.questions.filter(q => q.id !== id);
            this.saveData(); this.renderTable();
        }
    }

    moveRow(id, direction) {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        const index = set.questions.findIndex(q => q.id === id);
        if (index === -1) return;

        const newIndex = index + direction;
        if (newIndex < 0 || newIndex >= set.questions.length) return;

        // Swap
        const temp = set.questions[index];
        set.questions[index] = set.questions[newIndex];
        set.questions[newIndex] = temp;

        this.saveData();
        this.renderTable();
    }

    deleteColumn(index) {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (set.columns.length <= 2) { alert('æœ€ä½1ã¤ã®é¸æŠè‚¢ã¯å¿…è¦ã§ã™ã€‚'); return; }
        const colName = set.columns[index];
        if (confirm(`åˆ—ã€Œ${colName}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
            set.columns.splice(index, 1);
            set.questions.forEach(q => {
                if (Array.isArray(q.answer)) q.answer = q.answer.filter(a => a !== colName);
                else if (q.answer === colName) q.answer = set.columns[1];
            });
            this.saveData(); this.renderTable();
        }
    }

    renderTOC() {
        const renderLevel = (parentId = null) => {
            const items = this.quizData.filter(item => item.parentId === parentId);
            return items.map(s => {
                const globalIndex = this.quizData.findIndex(item => item.id === s.id);
                const isFolder = s.type === 'folder';
                const isActive = s.id === this.currentSetId && !this.isAutoGenerated && !isFolder;

                return `
                <li class="${isActive ? 'active' : ''} ${isFolder ? 'type-folder' : 'type-page'}" 
                    draggable="${this.isEditMode}" 
                    ondragstart="app.handleDragStart(event, ${globalIndex})" 
                    ondragover="app.handleDragOver(event, ${globalIndex})" 
                    ondrop="app.handleDrop(event, ${globalIndex})" 
                    ondragend="app.handleDragEnd(event)">
                    <div class="item-container ${isFolder ? 'folder-item' : ''}">
                        ${isFolder ? `
                            <span class="folder-toggle" onclick="event.stopPropagation(); app.toggleFolder('${s.id}')">
                                ${s.isCollapsed ? 'â–¶' : 'â–¼'}
                            </span>
                            <span class="folder-icon">${s.isCollapsed ? 'ğŸ“' : 'ğŸ“‚'}</span>
                        ` : ''}
                        <a href="#${s.id}" onclick="if('${isFolder}' === 'true') { event.preventDefault(); app.toggleFolder('${s.id}'); }">
                            ${s.title}
                        </a>
                        <div class="reorder-btns">
                            <button class="reorder-btn" onclick="event.stopPropagation(); app.movePage(${globalIndex}, -1)">â–²</button>
                            <button class="reorder-btn" onclick="event.stopPropagation(); app.movePage(${globalIndex}, 1)">â–¼</button>
                        </div>
                    </div>
                    ${(isFolder && !s.isCollapsed) ? `<ul>${renderLevel(s.id)}</ul>` : ''}
                </li>`;
            }).join('');
        };
        this.tocList.innerHTML = renderLevel(null);
    }

    handleDragStart(e, index) {
        if (!this.isEditMode) return;
        this.draggedItemIndex = index;
        const item = this.quizData[index];
        e.dataTransfer.setData('text/plain', item.id);
        e.target.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
    }

    handleDragOver(e, index) {
        if (!this.isEditMode) return;
        e.preventDefault();
        const item = this.quizData[index];
        const li = e.target.closest('li');

        // Folder highlights
        if (item.type === 'folder') {
            li.classList.add('drag-over-folder');
        } else {
            li.classList.add('drag-over');
        }
    }

    handleDrop(e, index) {
        if (!this.isEditMode) return;
        e.preventDefault();
        const targetItem = this.quizData[index];
        const draggedItem = this.quizData[this.draggedItemIndex];

        if (draggedItem.id === targetItem.id) return;

        // Reset classes
        const li = e.target.closest('li');
        if (li) {
            li.classList.remove('drag-over');
            li.classList.remove('drag-over-folder');
        }

        const data = [...this.quizData];
        const item = data.splice(this.draggedItemIndex, 1)[0];

        // If dropped on a folder, make it a child
        if (targetItem.type === 'folder' && !e.shiftKey) {
            item.parentId = targetItem.id;
            targetItem.isCollapsed = false; // Auto expand
            data.push(item); // Put at end of global list, renderTOC handles hierarchy
        } else {
            // Drop between/relative to target
            item.parentId = targetItem.parentId;
            const newIndex = data.findIndex(d => d.id === targetItem.id);
            data.splice(newIndex, 0, item);
        }

        this.quizData = data;
        this.saveData();
        this.renderTOC();
    }

    handleDragEnd(e) {
        const draggingItems = this.tocList.querySelectorAll('.dragging');
        draggingItems.forEach(item => item.classList.remove('dragging'));
        const overItems = this.tocList.querySelectorAll('.drag-over, .drag-over-folder');
        overItems.forEach(item => item.classList.remove('drag-over', 'drag-over-folder'));
    }

    toggleFolder(id) {
        const folder = this.quizData.find(s => s.id === id);
        if (folder && folder.type === 'folder') {
            folder.isCollapsed = !folder.isCollapsed;
            this.saveData();
            this.renderTOC();
        }
    }

    addNewFolder() {
        const title = prompt('ãƒ•ã‚©ãƒ«ãƒ€å:');
        if (!title) return;
        const id = 'f-' + Date.now();
        this.quizData.push({
            id, title, type: 'folder', parentId: null, isCollapsed: false
        });
        this.saveData();
        this.renderTOC();
    }

    movePage(index, direction) {
        const itemsAtSameLevel = this.quizData.filter(item => item.parentId === this.quizData[index].parentId);
        const localIndex = itemsAtSameLevel.findIndex(item => item.id === this.quizData[index].id);
        const newLocalIndex = localIndex + direction;

        if (newLocalIndex < 0 || newLocalIndex >= itemsAtSameLevel.length) return;

        const targetGlobalIndex = this.quizData.findIndex(item => item.id === itemsAtSameLevel[newLocalIndex].id);

        const temp = this.quizData[index];
        this.quizData[index] = this.quizData[targetGlobalIndex];
        this.quizData[targetGlobalIndex] = temp;

        this.saveData();
        this.renderTOC();
    }

    updateActiveTOC(id) {
        this.tocList.querySelectorAll('li').forEach(li => {
            const a = li.querySelector('a');
            const isActive = a && a.getAttribute('href') === `#${id}`;
            li.classList.toggle('active', isActive);
        });
    }

    addNewPage() {
        const title = prompt('ã‚¿ã‚¤ãƒˆãƒ«:'); if (!title) return;
        const isMulti = confirm('è¤‡æ•°é¸æŠï¼ˆãƒ©ãƒ³ã‚­ãƒ³ã‚°å½¢å¼ï¼‰ã«ã—ã¾ã™ã‹ï¼Ÿ\nOK: è¤‡æ•°é¸æŠ, ã‚­ãƒ£ãƒ³ã‚»ãƒ«: å˜ä¸€é¸æŠ');
        const id = 'p-' + Date.now();
        const cols = isMulti ? [
            "é †ä½", "ã€ç”Ÿè¨ˆç¶­æŒã€‘", "ã€ç”Ÿè¨ˆåŒä¸€ã€‘", "é…å¶è€…", "å­", "çˆ¶æ¯", "å­«", "ç¥–çˆ¶æ¯", "å…„å¼Ÿå§‰å¦¹", "3è¦ªç­‰ä»¥å†…", "å¯¾è±¡ãªã—"
        ] : ["é …ç›®", "é¸æŠ1", "é¸æŠ2"];

        const questions = [];
        if (isMulti) {
            for (let i = 1; i <= 6; i++) {
                questions.push({ id: 'q-' + Date.now() + i, text: `ç¬¬${i}é †ä½`, answer: [] });
            }
        } else {
            questions.push({ id: 'q-' + Date.now(), text: "æ–°å•é¡Œ", answer: cols[1] });
        }

        const newPage = {
            id, title, type: 'page', parentId: null, isMultiSelect: isMulti,
            columns: cols,
            questions: questions
        };

        // If current viewing is a folder, maybe add to it? For now, just add to root
        this.quizData.push(newPage);

        this.isAutoGenerated = false;
        this.saveData();
        this.renderTOC();
        this.loadSet(id);

        // Scroll to the new page in the sidebar
        setTimeout(() => {
            const newElem = this.tocList.querySelector(`a[href="#${id}"]`);
            if (newElem) newElem.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 100);
    }

    addNewRow() {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        set.questions.push({
            id: 'q-' + Date.now(),
            text: "æ–°å•é¡Œ...",
            memo: "",
            answer: set.isMultiSelect ? [] : set.columns[1]
        });
        this.saveData();
        this.renderTable();
    }
    addNewColumn() { if (this.isAutoGenerated) return; const set = this.quizData.find(s => s.id === this.currentSetId); const name = prompt('åˆ—å:'); if (!name) return; set.columns.push(name); this.saveData(); this.renderTable(); }

    deleteCurrentPage() {
        if (this.quizData.length <= 1 || this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (confirm(`ã“ã®ãƒšãƒ¼ã‚¸ï¼ˆ${set.title}ï¼‰ã®å…¨å•é¡Œãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚`)) {
            this.quizData = this.quizData.filter(s => s.id !== this.currentSetId);
            this.saveData(); this.currentSetId = this.quizData[0].id; this.renderTOC(); this.loadSet(this.currentSetId);
        }
    }

    cloneCurrentPage() {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (!set) return;

        const newId = 'p-' + Date.now();
        const clonedSet = JSON.parse(JSON.stringify(set));
        clonedSet.id = newId;
        clonedSet.title = clonedSet.title + 'ï¼ˆã‚³ãƒ”ãƒ¼ï¼‰';

        // Re-generate question IDs to avoid conflicts and start fresh stats
        clonedSet.questions.forEach((q, i) => {
            q.id = 'q-' + Date.now() + '-' + i + '-' + Math.random().toString(36).substr(2, 5);
        });

        this.quizData.push(clonedSet);
        this.saveData();
        this.isAutoGenerated = false;
        this.renderTOC();
        this.loadSet(newId);
    }

    clearData() {
        const input = prompt('ã™ã¹ã¦ã®å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã¨å±¥æ­´ã‚’å®Œå…¨ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nå‰Šé™¤ã™ã‚‹å ´åˆã¯ã€ç¢ºèªã®ãŸã‚ã€ŒRESETã€ã¨å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚\næ³¨ï¼šäº‹å‰ã«ã€Œãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¿å­˜ã€ã‚’è¡Œã†ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚');
        if (input === 'RESET') { localStorage.clear(); window.location.reload(); } else if (input !== null) { alert('å…¥åŠ›ãŒæ­£ã—ããªã„ãŸã‚ã€å‰Šé™¤ã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚'); }
    }

    // --- Data Management (Export/Import) ---

    getTimestamp() {
        const now = new Date();
        const pad = (n) => n.toString().padStart(2, '0');
        return `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    }

    async exportToJSON() {
        const fullData = {
            quizData: this.quizData,
            history: this.history,
            questionStats: this.questionStats,
            exportedAt: new Date().toISOString()
        };
        const fileName = `sharo_study_backup_${this.getTimestamp()}.json`;
        const jsonContent = JSON.stringify(fullData, null, 2);

        // Try File System Access API for folder selection
        if (window.showSaveFilePicker) {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{ description: 'JSON File', accept: { 'application/json': ['.json'] } }]
                });
                const writable = await handle.createWritable();
                await writable.write(jsonContent);
                await writable.close();
                this.updateDataStatus("JSONã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚");
                return;
            } catch (err) {
                if (err.name === 'AbortError') return;
                console.error("showSaveFilePicker failed:", err);
            }
        }

        // Fallback for older browsers
        const blob = new Blob([jsonContent], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
        this.updateDataStatus("JSONå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸï¼ˆãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€ã«ä¿å­˜ï¼‰ã€‚");
    }

    async exportToCSV() {
        // CSV is focused on quiz questions only (for spreadsheet editing)
        let csv = '\uFEFF'; // UTF-8 BOM
        csv += 'ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ«,ID,å•é¡Œæ–‡,æ­£è§£(ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š),è§£èª¬,é¸æŠè‚¢1,é¸æŠè‚¢2,é¸æŠè‚¢3,é¸æŠè‚¢4,é¸æŠè‚¢5,é¸æŠè‚¢6,é¸æŠè‚¢7,é¸æŠè‚¢8,é¸æŠè‚¢9,é¸æŠè‚¢10\n';

        this.quizData.forEach(page => {
            page.questions.forEach(q => {
                const row = [
                    page.title,
                    q.id,
                    q.text,
                    Array.isArray(q.answer) ? q.answer.join('|') : q.answer,
                    q.memo || '',
                    ...(page.columns.slice(1)) // choice choices
                ].map(val => `"${(val || "").toString().replace(/"/g, '""')}"`).join(',');
                csv += row + '\n';
            });
        });

        const fileName = `sharo_questions_${this.getTimestamp()}.csv`;

        if (window.showSaveFilePicker) {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{ description: 'CSV File', accept: { 'text/csv': ['.csv'] } }]
                });
                const writable = await handle.createWritable();
                await writable.write(csv);
                await writable.close();
                this.updateDataStatus("CSVã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚");
                return;
            } catch (err) {
                if (err.name === 'AbortError') return;
                console.error("showSaveFilePicker failed:", err);
            }
        }

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
        this.updateDataStatus("CSVå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸï¼ˆãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€ã«ä¿å­˜ï¼‰ã€‚");
    }

    handleFileImport(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            const content = event.target.result;
            if (file.name.endsWith('.json')) {
                this.importFromJSON(content);
            } else if (file.name.endsWith('.csv')) {
                this.importFromCSV(content);
            }
        };
        reader.readAsText(file);
    }

    importFromJSON(jsonString) {
        try {
            const data = JSON.parse(jsonString);
            if (!data.quizData) throw new Error('Invalid backup format');

            if (confirm('ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã™ã¹ã¦ä¸Šæ›¸ãã—ã¦å¾©æ—§ã—ã¾ã™ã‹ï¼Ÿ\nï¼ˆç¾åœ¨ã®å•é¡Œãƒ»å±¥æ­´ãƒ»çµ±è¨ˆãŒã™ã¹ã¦æ¶ˆãˆã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã«ç½®ãæ›ã‚ã‚Šã¾ã™ï¼‰')) {
                this.quizData = data.quizData;
                this.history = data.history || [];
                this.questionStats = data.questionStats || {};

                this.saveData();
                this.saveHistory();
                this.saveQuestionStats();

                alert('ãƒ‡ãƒ¼ã‚¿ã‚’æ­£å¸¸ã«å¾©å…ƒã—ã¾ã—ãŸã€‚');
                window.location.reload();
            }
        } catch (err) {
            console.error(err);
            alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æœ‰åŠ¹ãªJSONãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
        }
    }

    importFromCSV(csvString) {
        try {
            const lines = csvString.split(/\r?\n/);
            if (lines.length < 2) return;

            // Simple CSV parser (not handling all escapes, but works for standard export)
            const parseCSVLine = (line) => {
                const parts = [];
                let current = '';
                let inQuotes = false;
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"' && line[i + 1] === '"') { current += '"'; i++; }
                    else if (char === '"') inQuotes = !inQuotes;
                    else if (char === ',' && !inQuotes) { parts.push(current); current = ''; }
                    else current += char;
                }
                parts.push(current);
                return parts;
            };

            const header = parseCSVLine(lines[0]);
            const newPages = new Map();

            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                const row = parseCSVLine(lines[i]);
                const pageTitle = row[0];
                const id = row[1] || ('q-' + Math.random().toString(36).substr(2, 9));
                const text = row[2];
                const answerRaw = row[3];
                const choices = row.slice(4).filter(c => c !== undefined && c !== "");

                if (!pageTitle || !text) continue;

                if (!newPages.has(pageTitle)) {
                    newPages.set(pageTitle, {
                        id: 'p-' + Date.now() + Math.random().toString(36).substr(2, 5),
                        title: pageTitle,
                        columns: ["é …ç›®", ...choices],
                        questions: [],
                        isMultiSelect: answerRaw.includes('|')
                    });
                }

                const page = newPages.get(pageTitle);
                page.questions.push({
                    id: id,
                    text: text,
                    answer: page.isMultiSelect ? answerRaw.split('|') : answerRaw,
                    isInPool: true
                });
            }

            if (confirm(`CSVã‹ã‚‰ ${newPages.size} ãƒšãƒ¼ã‚¸ã®å•é¡Œã‚’å–ã‚Šè¾¼ã¿ã¾ã™ã‹ï¼Ÿ\næ—¢å­˜ã®ãƒšãƒ¼ã‚¸ã¯ç¶­æŒã•ã‚Œã€æœ«å°¾ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚`)) {
                this.quizData.push(...Array.from(newPages.values()));
                this.saveData();
                alert('CSVã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’æ­£å¸¸ã«å–ã‚Šè¾¼ã¿ã¾ã—ãŸã€‚');
                this.renderTOC();
                this.loadSet(this.currentSetId);
            }
        } catch (err) {
            console.error(err);
            alert('CSVã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
        }
    }

    updateDataStatus(msg) {
        if (this.dataStatusMsg) {
            this.dataStatusMsg.textContent = `${msg} (${new Date().toLocaleTimeString()})`;
            this.dataStatusMsg.style.color = 'var(--success)';
            setTimeout(() => {
                this.dataStatusMsg.style.color = 'var(--text-secondary)';
            }, 5000);
        }
        // Save export timestamp for reminder
        if (msg.includes("ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ")) {
            localStorage.setItem('sharo_last_export_at', new Date().toISOString());
            this.checkBackupFrequency();
        }
    }

    // --- Automatic Recovery and Protection ---

    checkAndOfferRecovery(manual = false) {
        const backupStr = localStorage.getItem('sharo_auto_backup');
        if (!backupStr) {
            if (manual) alert('å†…éƒ¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
            return;
        }

        try {
            const backup = JSON.parse(backupStr);
            const isMainEmpty = (this.quizData.length <= DEFAULT_QUIZ_DATA.length && this.history.length === 0);

            if (manual || isMainEmpty) {
                const date = new Date(backup.savedAt).toLocaleString();
                const msg = manual
                    ? `å†…éƒ¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼ˆä¿å­˜æ—¥æ™‚: ${date}ï¼‰ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ\nç¾åœ¨ç·¨é›†ä¸­ã®å†…å®¹ã¯ä¸Šæ›¸ãã•ã‚Œã¾ã™ã€‚`
                    : `ã€ãƒ‡ãƒ¼ã‚¿å¾©æ—§ã®æ¡ˆå†…ã€‘\nãƒ¡ã‚¤ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒåˆæœŸçŠ¶æ…‹ã®ã‚ˆã†ã§ã™ãŒã€å†…éƒ¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼ˆä¿å­˜æ—¥æ™‚: ${date}ï¼‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚\nä»¥å‰ã®çŠ¶æ…‹ã‚’å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ`;

                if (confirm(msg)) {
                    this.quizData = backup.quizData;
                    this.history = backup.history || [];
                    this.questionStats = backup.questionStats || {};
                    this.saveData();
                    this.saveHistory();
                    this.saveQuestionStats();
                    alert('ãƒ‡ãƒ¼ã‚¿ã‚’æ­£å¸¸ã«å¾©å…ƒã—ã¾ã—ãŸã€‚');
                    window.location.reload();
                }
            }
        } catch (e) {
            console.error("Backup parse error", e);
        }
    }

    checkBackupFrequency() {
        const lastExport = localStorage.getItem('sharo_last_export_at');
        if (!lastExport) return;

        const hoursSince = (Date.now() - new Date(lastExport).getTime()) / (1000 * 60 * 60);
        if (hoursSince > 24) {
            const reminderArea = document.getElementById('backup-reminder');
            if (reminderArea) {
                reminderArea.style.display = 'block';
                reminderArea.innerHTML = `âš ï¸ æœ€çµ‚ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‹ã‚‰24æ™‚é–“ä»¥ä¸ŠçµŒéã—ã¦ã„ã¾ã™ã€‚å¤§åˆ‡ãªãƒ‡ãƒ¼ã‚¿ã‚’å®ˆã‚‹ãŸã‚ã€<span style="color:var(--accent); cursor:pointer; text-decoration:underline;" onclick="app.exportToJSON()">JSONãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ä¿å­˜</span>ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚`;
            }
        } else {
            const reminderArea = document.getElementById('backup-reminder');
            if (reminderArea) reminderArea.style.display = 'none';
        }
    }
}
let app;
document.addEventListener('DOMContentLoaded', () => {
    app = new QuizApp();
    window.app = app; // Correctly expose app to global for onclick handlers
});
