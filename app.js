const DEFAULT_QUIZ_DATA = [
    {
        id: "pension-1",
        title: "国民年金法 資格喪失の時期 (法9条) 強制被保険者",
        columns: ["項目", "当日喪失", "翌日喪失"],
        questions: [
            { id: "q-1", text: "イ）死亡したとき", answer: "翌日喪失" },
            { id: "q-2", text: "ニ）厚生年金保険法に基づく老齢給付等を受けることができる者その他この法律の適用を除外すべき特別の理由がある者として厚生労働省令で定める者となったとき（第2号被保険者又は第3号被保険者に該当するときを除く）", answer: "当日喪失" },
            { id: "q-3", text: "ハ）60歳に達したとき（第2号被保険者に該当するときを除く）", answer: "当日喪失" }
        ]
    },
    {
        id: "survivor-rank-1",
        title: "【特訓】遺族の順位判定（スリム版）",
        isMultiSelect: true,
        columns: [
            "順位", "【生計維持】", "【生計同一】", "配偶者", "子", "父母", "孫", "祖父母", "兄弟姉妹", "3親等以内", "対象なし"
        ],
        questions: [
            { id: "q-surv-1", text: "第1順位", answer: ["配偶者", "子", "【生計維持】"] },
            { id: "q-surv-2", text: "第2順位", answer: ["父母", "【生計維持】"] },
            { id: "q-surv-3", text: "第3順位", answer: ["孫", "【生計維持】"] },
            { id: "q-surv-4", text: "第4順位", answer: ["祖父母", "【生計維持】"] },
            { id: "q-surv-5", text: "第5順位", answer: ["対象なし"] },
            { id: "q-surv-6", text: "第6順位", answer: ["対象なし"] }
        ]
    }
];

class QuizApp {
    constructor() {
        this.quizData = this.loadData();
        this.history = this.loadHistory();
        this.questionStats = this.loadQuestionStats();
        this.currentSetId = this.quizData[0].id;
        this.isEditMode = false;
        this.isAutoGenerated = false;

        this.userAnswers = {};
        this.isChecked = false;
        this.sortColumnIndex = -1;
        this.sortDirection = 1;

        this.chartMode = 'accuracy';
        this.statsChart = null;

        this.migrateData();
        this.cacheDOM();
        this.bindEvents();
        this.init();
    }

    migrateData() {
        let modified = false;

        // 1. Inject/Update Survivor Sample (Check for "スリム版" or column count change)
        const currentRank = this.quizData.find(s => s.id === "survivor-rank-1");
        const defaultRank = DEFAULT_QUIZ_DATA.find(s => s.id === "survivor-rank-1");

        if (!currentRank || (currentRank.columns && currentRank.columns[1] !== "【生計維持】")) {
            if (currentRank) {
                this.quizData = this.quizData.filter(s => s.id !== "survivor-rank-1");
            }
            this.quizData.push(JSON.parse(JSON.stringify(defaultRank)));
            modified = true;
        }

        this.quizData.forEach(set => {
            if (!set.questions) return;
            set.questions.forEach(q => {
                if (!q.id) { q.id = 'q-' + Math.random().toString(36).substr(2, 9) + Date.now(); modified = true; }
                if (set.isMultiSelect && typeof q.answer === 'string') {
                    q.answer = [q.answer];
                    modified = true;
                }
                if (q.isInPool === undefined) {
                    q.isInPool = true;
                    modified = true;
                }
            });
        });

        // 2. Safe cleanup of questionStats
        // BUG FIX: Only cleanup stats if quizData is successfully loaded and has content.
        // If quizData is somehow empty or fallback-only but stats exist, we MUST NOT wipe them.
        if (this.quizData && this.quizData.length > 0) {
            const cleanedStats = {};
            const allIds = new Set();
            this.quizData.forEach(set => {
                if (set.questions) set.questions.forEach(q => allIds.add(q.id));
            });

            let hasWiped = false;
            Object.keys(this.questionStats).forEach(key => {
                if (allIds.has(key)) {
                    cleanedStats[key] = this.questionStats[key];
                    // Initialize recent history for older data
                    if (!cleanedStats[key].recent) {
                        const t = cleanedStats[key].total || 0;
                        const c = cleanedStats[key].correct || 0;
                        const count = Math.min(t, 5);
                        const r = [];
                        const recentCorrect = t > 0 ? Math.round((c / t) * count) : 0;
                        for (let i = 0; i < count; i++) r.push(i < recentCorrect ? 1 : 0);
                        cleanedStats[key].recent = r;
                    }
                } else {
                    // Log or backup orphaned stats if needed, but for now, just track if we're deleting
                    hasWiped = true;
                }
            });

            // SAFETY: If we are about to wipe more than 50% of stats, something might be wrong.
            // In a real data loss scenario, quizData might be default (2 items) while stats are 100+.
            if (hasWiped && Object.keys(this.questionStats).length > 10 && Object.keys(cleanedStats).length < (Object.keys(this.questionStats).length / 2)) {
                console.warn("Migration safety triggered: Excessive stat cleanup prevented.");
            } else {
                this.questionStats = cleanedStats;
            }
        }

        if (modified) this.saveData();
        this.saveQuestionStats();
    }

    cacheDOM() {
        this.tabQuiz = document.getElementById('tab-quiz');
        this.tabStats = document.getElementById('tab-stats');
        this.quizView = document.getElementById('quiz-view');
        this.statsView = document.getElementById('stats-view');
        this.tocList = document.getElementById('toc-list');
        this.quizTitle = document.getElementById('quiz-title');
        this.tableHead = document.getElementById('table-head');
        this.tableBody = document.getElementById('table-body');
        this.scoreDisplay = document.getElementById('score');
        this.editModeToggle = document.getElementById('edit-mode-toggle');
        this.addPageBtn = document.getElementById('add-page-btn');
        this.addRowBtn = document.getElementById('add-row-btn');
        this.addColumnBtn = document.getElementById('add-column-btn');
        this.clearDataBtn = document.getElementById('clear-data-btn');
        this.deletePageBtn = document.getElementById('delete-page-btn');
        this.clonePageBtn = document.getElementById('clone-page-btn');
        this.checkAnswersBtn = document.getElementById('check-answers-btn');
        this.resetQuizBtn = document.getElementById('reset-quiz-btn');

        this.totalAccuracy = document.getElementById('total-accuracy');
        this.totalAnsweredDisplay = document.getElementById('total-answered');
        this.historyBody = document.getElementById('history-body');
        this.weakQuestionsBody = document.getElementById('weak-questions-body');
        this.genWeakBtn = document.getElementById('gen-weak-btn');
        this.genRareBtn = document.getElementById('gen-rare-btn');
        this.genRandomBtn = document.getElementById('gen-random-btn');

        this.chartBtns = {
            accuracy: document.getElementById('show-accuracy-btn'),
            frequency: document.getElementById('show-frequency-btn'),
            errors: document.getElementById('show-errors-btn')
        };
        this.sidebar = document.getElementById('sidebar');
        this.sidebarContent = document.getElementById('quiz-sidebar-content');
        this.menuToggle = document.getElementById('menu-toggle');

        // Data management
        this.exportJsonBtn = document.getElementById('export-json-btn');
        this.importJsonBtn = document.getElementById('import-json-btn');
        this.exportCsvBtn = document.getElementById('export-csv-btn');
        this.importCsvBtn = document.getElementById('import-csv-btn');
        this.dataImportInput = document.getElementById('data-import-input');
        this.dataStatusMsg = document.getElementById('data-status-msg');
    }

    bindEvents() {
        this.tabQuiz.addEventListener('click', () => this.switchView('quiz'));
        this.tabStats.addEventListener('click', () => this.switchView('stats'));
        this.editModeToggle.addEventListener('change', (e) => {
            this.isEditMode = e.target.checked;
            document.body.classList.toggle('edit-mode', this.isEditMode);
            this.updateTitleEditability();
            this.resetQuiz(); this.renderTOC(); this.renderTable();
        });
        this.checkAnswersBtn.addEventListener('click', () => this.batchCheckAnswers());
        this.resetQuizBtn.addEventListener('click', () => this.resetQuiz());
        this.addPageBtn.addEventListener('click', () => this.addNewPage());
        this.addRowBtn.addEventListener('click', () => this.addNewRow());
        this.addColumnBtn.addEventListener('click', () => this.addNewColumn());
        this.clearDataBtn.addEventListener('click', () => this.clearData());
        this.deletePageBtn.addEventListener('click', () => this.deleteCurrentPage());
        this.clonePageBtn.addEventListener('click', () => this.cloneCurrentPage());

        this.genWeakBtn.addEventListener('click', () => this.generateSpecialQuiz('weak'));
        this.genRareBtn.addEventListener('click', () => this.generateSpecialQuiz('rare'));
        if (this.genRandomBtn) this.genRandomBtn.addEventListener('click', () => this.generateSpecialQuiz('random'));

        Object.keys(this.chartBtns).forEach(mode => {
            this.chartBtns[mode].addEventListener('click', () => {
                this.chartMode = mode;
                this.updateChartTabs();
                this.renderChart();
            });
        });
        this.tocList.addEventListener('click', (e) => { if (e.target.tagName === 'A') { e.preventDefault(); this.isAutoGenerated = false; this.loadSet(e.target.getAttribute('href').substring(1)); } });

        // Update TOC real-time when editing title
        this.quizTitle.addEventListener('input', () => {
            if (this.isEditMode && !this.isAutoGenerated) {
                const set = this.quizData.find(s => s.id === this.currentSetId);
                if (set) {
                    set.title = this.quizTitle.textContent.trim();
                    this.renderTOC();
                }
            }
        });

        this.quizTitle.addEventListener('blur', () => {
            if (this.isEditMode && !this.isAutoGenerated) {
                const set = this.quizData.find(s => s.id === this.currentSetId);
                if (set) {
                    set.title = this.quizTitle.textContent.trim();
                    this.saveData();
                }
            }
        });
        this.menuToggle.addEventListener('click', () => { this.sidebar.classList.toggle('open'); });

        // Data management events
        this.exportJsonBtn.addEventListener('click', () => this.exportToJSON());
        this.importJsonBtn.addEventListener('click', () => { this.dataImportInput.accept = '.json'; this.dataImportInput.click(); });
        this.exportCsvBtn.addEventListener('click', () => this.exportToCSV());
        this.importCsvBtn.addEventListener('click', () => { this.dataImportInput.accept = '.csv'; this.dataImportInput.click(); });
        this.dataImportInput.addEventListener('change', (e) => this.handleFileImport(e));

        // Recovery button for internal backup
        const forceRestoreBtn = document.getElementById('force-restore-internal-btn');
        if (forceRestoreBtn) {
            forceRestoreBtn.addEventListener('click', () => this.checkAndOfferRecovery(true));
        }
    }

    init() {
        this.renderTOC();
        this.loadSet(this.currentSetId);
        this.checkAndOfferRecovery();
        this.checkBackupFrequency();
    }

    loadData() { const saved = localStorage.getItem('sharoQuizData'); return saved ? JSON.parse(saved) : JSON.parse(JSON.stringify(DEFAULT_QUIZ_DATA)); }
    saveData() {
        const dataStr = JSON.stringify(this.quizData);
        localStorage.setItem('sharoQuizData', dataStr);
        // Internal Redundancy: Also save to a backup key
        localStorage.setItem('sharo_auto_backup', JSON.stringify({
            quizData: this.quizData,
            history: this.history,
            questionStats: this.questionStats,
            savedAt: new Date().toISOString()
        }));
    }
    loadHistory() { const saved = localStorage.getItem('sharoQuizHistory'); return saved ? JSON.parse(saved) : []; }
    saveHistory() { localStorage.setItem('sharoQuizHistory', JSON.stringify(this.history)); }
    loadQuestionStats() { const saved = localStorage.getItem('sharoQuestionStats'); return saved ? JSON.parse(saved) : {}; }
    saveQuestionStats() { localStorage.setItem('sharoQuestionStats', JSON.stringify(this.questionStats)); }

    switchView(view) {
        this.tabQuiz.classList.toggle('active', view === 'quiz');
        this.tabStats.classList.toggle('active', view === 'stats');
        this.quizView.classList.toggle('hidden', view !== 'quiz');
        this.statsView.classList.toggle('hidden', view !== 'stats');
        if (view === 'stats') this.renderStats();
    }

    loadSet(id) {
        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === id);
        if (!set) return;

        this.currentSetId = id;
        this.quizTitle.textContent = set.title;
        this.updateTitleEditability();

        this.resetQuiz();
        this.renderTable();
        this.updateActiveTOC(id);
    }

    updateActiveTOC(id) {
        const tocLinks = this.tocList.querySelectorAll('a');
        tocLinks.forEach(a => {
            const isActive = !this.isAutoGenerated && a.getAttribute('href') === `#${id}`;
            a.classList.toggle('active', isActive);
        });
    }

    updateTitleEditability() {
        this.quizTitle.contentEditable = this.isEditMode && !this.isAutoGenerated;
    }

    resetQuiz() { this.userAnswers = {}; this.isChecked = false; this.scoreDisplay.textContent = "正解数: 0 / 0"; this.renderTable(); }

    batchCheckAnswers() {
        if (this.isChecked) return;
        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === this.currentSetId);
        let correctCount = 0; let answeredCount = 0;
        set.questions.forEach((q) => {
            const userAnswer = this.userAnswers[q.id];
            if (!userAnswer || (Array.isArray(userAnswer) && userAnswer.length === 0)) return;
            answeredCount++;

            let isCorrect = false;
            const isMulti = this.isAutoGenerated ? q.isMultiSelect : set.isMultiSelect;
            if (isMulti) {
                const correctSet = new Set(q.answer);
                const userSet = new Set(userAnswer);
                isCorrect = (correctSet.size === userSet.size && [...correctSet].every(item => userSet.has(item)));
            } else {
                isCorrect = userAnswer === q.answer;
            }

            if (isCorrect) correctCount++;
            const statKey = q.id;
            if (!this.questionStats[statKey]) {
                this.questionStats[statKey] = { correct: 0, total: 0, recent: [], page: q.origPage || set.title, text: q.text };
            }
            if (!this.questionStats[statKey].recent) this.questionStats[statKey].recent = [];

            this.questionStats[statKey].total++;
            if (isCorrect) this.questionStats[statKey].correct++;

            // Record recent history (last 5)
            this.questionStats[statKey].recent.push(isCorrect ? 1 : 0);
            if (this.questionStats[statKey].recent.length > 5) this.questionStats[statKey].recent.shift();

            this.questionStats[statKey].text = q.text; this.questionStats[statKey].page = q.origPage || set.title;
        });
        this.isChecked = true;
        this.scoreDisplay.textContent = `正解数: ${correctCount} / ${answeredCount} (ページ合計: ${set.questions.length})`;
        this.history.unshift({ timestamp: new Date().toLocaleString(), page: set.title, score: `${correctCount} / ${answeredCount}`, accuracy: answeredCount > 0 ? Math.round((correctCount / answeredCount) * 100) : 0 });
        if (this.history.length > 50) this.history.pop();
        this.saveHistory(); this.saveQuestionStats(); this.renderTable();
    }

    renderStats() {
        if (this.history.length === 0) {
            this.totalAccuracy.textContent = "0%"; this.totalAnsweredDisplay.textContent = "0";
            this.historyBody.innerHTML = '<tr><td colspan="4">履歴がありません</td></tr>';
            this.weakQuestionsBody.innerHTML = '<tr><td colspan="4">データがありません</td></tr>';
            return;
        }
        const avg = Math.round(this.history.reduce((a, b) => a + b.accuracy, 0) / this.history.length);
        this.totalAccuracy.textContent = `${avg}%`; this.totalAnsweredDisplay.textContent = this.history.length;
        this.historyBody.innerHTML = this.history.map(h => `<tr><td>${h.timestamp}</td><td>${h.page}</td><td>${h.score}</td><td>${h.accuracy}%</td></tr>`).join('');

        const statsArray = Object.values(this.questionStats).map(s => {
            const recent = s.recent || [];
            const rTotal = recent.length;
            const rCorrect = recent.reduce((a, b) => a + b, 0);
            const accuracy = rTotal > 0 ? Math.round((rCorrect / rTotal) * 100) : 0;
            return { ...s, accuracy, rTotal, rCorrect };
        }).filter(s => s.total > 0).sort((a, b) => {
            if (a.accuracy !== b.accuracy) return a.accuracy - b.accuracy;
            return a.total - b.total;
        }).slice(0, 10);

        this.weakQuestionsBody.innerHTML = statsArray.map(s => `<tr><td style="text-align: left;">${s.text}</td><td>${s.page}</td><td>${s.total}</td><td style="color: ${s.accuracy < 50 ? 'var(--error)' : 'var(--text-primary)'}">${s.accuracy}%</td></tr>`).join('');
        this.updateChartTabs(); this.renderChart();
    }

    updateChartTabs() { Object.keys(this.chartBtns).forEach(mode => { this.chartBtns[mode].classList.toggle('active', this.chartMode === mode); }); }

    renderChart() {
        const ctx = document.getElementById('statsChart').getContext('2d');
        if (this.statsChart) this.statsChart.destroy();
        const allStats = Object.values(this.questionStats).filter(s => s.total > 0).map(s => {
            const recent = s.recent || [];
            const rTotal = recent.length;
            const rCorrect = recent.reduce((a, b) => a + b, 0);
            const accuracy = rTotal > 0 ? Math.round((rCorrect / rTotal) * 100) : 0;
            const errors = rTotal - rCorrect;
            return { ...s, accuracy, errors, rTotal, rCorrect };
        });
        let sortedStats, data, label, color;
        if (this.chartMode === 'accuracy') { sortedStats = allStats.sort((a, b) => a.accuracy - b.accuracy).slice(0, 10); data = sortedStats.map(s => s.accuracy); label = '正答率 (%)'; color = '#4cc9f0'; }
        else if (this.chartMode === 'frequency') { sortedStats = allStats.sort((a, b) => b.total - a.total).slice(0, 10); data = sortedStats.map(s => s.total); label = '解答回数 (回)'; color = '#f72585'; }
        else { sortedStats = allStats.sort((a, b) => b.errors - a.errors).slice(0, 10); data = sortedStats.map(s => s.errors); label = '最近の誤答回数 (回/5回中)'; color = '#ff9f1c'; }
        const labels = sortedStats.map(s => s.text.length > 8 ? s.text.substring(0, 7) + '...' : s.text);
        this.statsChart = new Chart(ctx, {
            type: 'bar', data: { labels: labels, datasets: [{ label: label, data: data, backgroundColor: color + 'dd', borderColor: color, borderWidth: 1, borderRadius: 8 }] },
            options: { responsive: true, maintainAspectRatio: false, indexAxis: 'y', plugins: { legend: { display: false }, tooltip: { callbacks: { title: (items) => sortedStats[items[0].dataIndex].text, label: (item) => `${label}: ${item.raw}` } } }, scales: { x: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: 'rgba(255,255,255,0.6)' } }, y: { grid: { display: false }, ticks: { color: 'rgba(255,255,255,0.8)', font: { size: 12 } } } } }
        });
    }

    generateSpecialQuiz(type) {
        const allQuestions = [];
        this.quizData.forEach(set => {
            set.questions.forEach(q => {
                if (q.isInPool === false) return;
                const stat = this.questionStats[q.id] || { correct: 0, total: 0, recent: [] };
                const recent = stat.recent || [];
                const rTotal = recent.length;
                const rCorrect = recent.reduce((a, b) => a + b, 0);
                const accuracy = rTotal > 0 ? (rCorrect / rTotal) : -1;

                allQuestions.push({
                    id: q.id,
                    text: q.text,
                    answer: q.answer,
                    memo: q.memo || '',
                    origPage: set.title,
                    columns: set.columns,
                    accuracy: accuracy,
                    total: stat.total,
                    isMultiSelect: set.isMultiSelect
                });
            });
        });
        if (allQuestions.length === 0) return;
        let filtered, title;
        if (type === 'weak') {
            title = "特訓：苦手な問題ワースト10";
            filtered = allQuestions.filter(q => q.total > 0).sort((a, b) => {
                if (a.accuracy !== b.accuracy) return a.accuracy - b.accuracy;
                return b.total - a.total;
            }).slice(0, 10);
            if (filtered.length === 0) {
                alert('まだ間違えた記録がありません。まずは普通に学習して回答を記録してください。');
                return;
            }
        } else if (type === 'random') {
            title = "特訓：全問題からランダム10問";
            filtered = allQuestions.sort(() => Math.random() - 0.5).slice(0, 10);
        } else {
            title = "特訓：未学習・低頻度な問題10問";
            filtered = allQuestions.sort((a, b) => {
                if (a.total !== b.total) return a.total - b.total;
                return a.accuracy - b.accuracy;
            }).slice(0, 10);
        }
        this.autoGeneratedSet = { id: 'temp-autogen', title: title, questions: filtered };
        this.isAutoGenerated = true;
        this.switchView('quiz');
        this.loadSet('temp-autogen');
    }

    renderTable() {
        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === this.currentSetId);
        if (!set) return;
        this.tableHead.innerHTML = '';
        const headTr = document.createElement('tr');
        if (this.isAutoGenerated) {
            // Determine columns based on the first question for consistency, or generic if mixed
            const firstQ = set.questions[0];
            const cols = firstQ.columns || ["項目", "選択肢"];
            headTr.innerHTML = `<th>${cols[0]}</th>`;
            for (let i = 1; i < cols.length; i++) {
                const th = document.createElement('th');
                th.textContent = cols[i];
                headTr.appendChild(th);
            }
        } else {
            // Pool inclusion checkbox header
            if (this.isEditMode) {
                const thPool = document.createElement('th');
                thPool.innerHTML = '特訓';
                thPool.className = 'pool-cell';
                thPool.title = '特訓（お任せ問題）の対象に含めるか';
                headTr.appendChild(thPool);
            }

            set.columns.forEach((col, index) => {
                const th = document.createElement('th');
                const span = document.createElement('span');
                span.textContent = col;
                if (this.isEditMode) {
                    span.contentEditable = true;
                    span.onblur = () => {
                        const oldVal = col;
                        const newVal = span.textContent.trim();
                        if (oldVal !== newVal) {
                            set.columns[index] = newVal;
                            set.questions.forEach(q => {
                                if (Array.isArray(q.answer)) {
                                    q.answer = q.answer.map(a => a === oldVal ? newVal : a);
                                } else if (q.answer === oldVal) q.answer = newVal;
                            });
                            this.saveData();
                            this.renderTable();
                        }
                    };
                    if (index > 0) {
                        const delBtn = document.createElement('span');
                        delBtn.className = 'delete-col-btn';
                        delBtn.innerHTML = '×';
                        delBtn.onclick = (e) => {
                            e.stopPropagation();
                            this.deleteColumn(index);
                        };
                        th.appendChild(delBtn);
                    }
                }
                th.appendChild(span);
                headTr.appendChild(th);
            });
        }
        this.tableHead.appendChild(headTr);
        this.tableBody.innerHTML = '';
        set.questions.forEach((q) => {
            const tr = document.createElement('tr'); tr.id = `row-${q.id}`;
            const isSetMulti = this.isAutoGenerated ? q.isMultiSelect : set.isMultiSelect;

            if (this.isChecked) {
                const userAnswer = this.userAnswers[q.id];
                if (userAnswer && (!Array.isArray(userAnswer) || userAnswer.length > 0)) {
                    let isAllCorrect = false;
                    if (isSetMulti) {
                        const correctSet = new Set(q.answer); const userSet = new Set(userAnswer);
                        isAllCorrect = (correctSet.size === userSet.size && [...correctSet].every(item => userSet.has(item)));
                    } else { isAllCorrect = userAnswer === q.answer; }
                    tr.classList.add(isAllCorrect ? 'row-correct' : 'row-wrong');
                }
            }
            const tdQ = document.createElement('td'); tdQ.className = 'question-cell';
            if (this.isEditMode && !this.isAutoGenerated) {
                const rowControls = document.createElement('div');
                rowControls.className = 'row-edit-controls';

                const delBtn = document.createElement('span'); delBtn.className = 'delete-row-btn'; delBtn.innerHTML = '×';
                delBtn.title = '行を削除';
                delBtn.onclick = () => this.deleteRow(q.id);

                const upBtn = document.createElement('span'); upBtn.className = 'move-row-btn'; upBtn.innerHTML = '↑';
                upBtn.title = '上に移動';
                upBtn.onclick = () => this.moveRow(q.id, -1);

                const downBtn = document.createElement('span'); downBtn.className = 'move-row-btn'; downBtn.innerHTML = '↓';
                downBtn.title = '下に移動';
                downBtn.onclick = () => this.moveRow(q.id, 1);

                rowControls.appendChild(delBtn);
                rowControls.appendChild(upBtn);
                rowControls.appendChild(downBtn);
                tdQ.appendChild(rowControls);
            }
            if (this.isAutoGenerated && q.origPage) { const tag = document.createElement('div'); tag.className = 'page-tag'; tag.textContent = q.origPage; tdQ.appendChild(tag); }

            // Pool inclusion checkbox cell
            if (!this.isAutoGenerated && this.isEditMode) {
                const tdPool = document.createElement('td');
                tdPool.className = 'pool-cell';
                const poolCheck = document.createElement('input');
                poolCheck.type = 'checkbox';
                poolCheck.checked = q.isInPool !== false;
                poolCheck.onchange = (e) => {
                    q.isInPool = e.target.checked;
                    this.saveData();
                };
                tdPool.appendChild(poolCheck);
                tr.appendChild(tdPool);
            }

            const spanText = document.createElement('span'); spanText.textContent = q.text;
            if (this.isEditMode && !this.isAutoGenerated) { spanText.contentEditable = true; spanText.onblur = () => { q.text = spanText.textContent.trim(); this.saveData(); }; }
            tdQ.appendChild(spanText);

            // Memo block
            if (this.isEditMode && !this.isAutoGenerated) {
                const memoEl = document.createElement('div');
                memoEl.className = 'memo-input';
                memoEl.placeholder = 'メモ・解説を入力...';
                memoEl.contentEditable = true;
                memoEl.textContent = q.memo || '';
                memoEl.onblur = () => { q.memo = memoEl.textContent.trim(); this.saveData(); };
                tdQ.appendChild(memoEl);
            } else if (this.isChecked && q.memo) {
                const memoEl = document.createElement('div');
                memoEl.className = 'memo-display';
                memoEl.innerHTML = `<strong>解説:</strong> ${q.memo.replace(/\n/g, '<br>')}`;
                tdQ.appendChild(memoEl);
            }

            tr.appendChild(tdQ);

            const activeCols = this.isAutoGenerated ? q.columns || set.columns : set.columns;

            for (let i = 1; i < activeCols.length; i++) {
                const choiceName = activeCols[i]; const td = document.createElement('td'); td.className = 'choice-cell'; td.textContent = choiceName;
                if (isSetMulti) td.classList.add('multi-select');

                if (this.isEditMode && !this.isAutoGenerated) {
                    const isCorrect = isSetMulti ? (Array.isArray(q.answer) && q.answer.includes(choiceName)) : (q.answer === choiceName);
                    if (isCorrect) td.classList.add(isSetMulti ? 'multi-selected' : 'correct');
                    td.onclick = () => {
                        if (isSetMulti) {
                            if (!Array.isArray(q.answer)) q.answer = [];
                            if (q.answer.includes(choiceName)) q.answer = q.answer.filter(a => a !== choiceName);
                            else q.answer.push(choiceName);
                        } else { q.answer = choiceName; }
                        this.saveData(); this.renderTable();
                    };
                } else {
                    const userAnswer = this.userAnswers[q.id];
                    const isSelected = isSetMulti ? (Array.isArray(userAnswer) && userAnswer.includes(choiceName)) : (userAnswer === choiceName);

                    if (this.isChecked) {
                        const isCorrectAnswer = isSetMulti ? (Array.isArray(q.answer) && q.answer.includes(choiceName)) : (q.answer === choiceName);
                        if (isCorrectAnswer) td.classList.add('correct');
                        else if (isSelected) td.classList.add('wrong');
                    } else if (isSelected) td.classList.add('selected');

                    td.onclick = () => {
                        if (!this.isChecked) {
                            if (isSetMulti) {
                                if (!Array.isArray(this.userAnswers[q.id])) this.userAnswers[q.id] = [];
                                if (this.userAnswers[q.id].includes(choiceName)) this.userAnswers[q.id] = this.userAnswers[q.id].filter(a => a !== choiceName);
                                else this.userAnswers[q.id].push(choiceName);
                            } else { this.userAnswers[q.id] = choiceName; }
                            this.renderTable();
                        }
                    };
                }
                tr.appendChild(td);
            }
            this.tableBody.appendChild(tr);
        });
    }

    deleteRow(id) {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (set.questions.length <= 1) { alert('最低1行は必要です。'); return; }
        if (confirm('この行を削除しますか？')) {
            set.questions = set.questions.filter(q => q.id !== id);
            this.saveData(); this.renderTable();
        }
    }

    moveRow(id, direction) {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        const index = set.questions.findIndex(q => q.id === id);
        if (index === -1) return;

        const newIndex = index + direction;
        if (newIndex < 0 || newIndex >= set.questions.length) return;

        // Swap
        const temp = set.questions[index];
        set.questions[index] = set.questions[newIndex];
        set.questions[newIndex] = temp;

        this.saveData();
        this.renderTable();
    }

    deleteColumn(index) {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (set.columns.length <= 2) { alert('最低1つの選択肢は必要です。'); return; }
        const colName = set.columns[index];
        if (confirm(`列「${colName}」を削除しますか？`)) {
            set.columns.splice(index, 1);
            set.questions.forEach(q => {
                if (Array.isArray(q.answer)) q.answer = q.answer.filter(a => a !== colName);
                else if (q.answer === colName) q.answer = set.columns[1];
            });
            this.saveData(); this.renderTable();
        }
    }

    renderTOC() {
        this.tocList.innerHTML = this.quizData.map((s, i) => `
            <li draggable="${this.isEditMode}" 
                ondragstart="app.handleDragStart(event, ${i})" 
                ondragover="app.handleDragOver(event, ${i})" 
                ondrop="app.handleDrop(event, ${i})" 
                ondragend="app.handleDragEnd(event)" 
                class="${s.id === this.currentSetId && !this.isAutoGenerated ? 'active' : ''}">
                <a href="#${s.id}">${s.title}</a>
                <div class="reorder-btns">
                    <button class="reorder-btn" onclick="event.stopPropagation(); app.movePage(${i}, -1)">▲</button>
                    <button class="reorder-btn" onclick="event.stopPropagation(); app.movePage(${i}, 1)">▼</button>
                </div>
            </li>`).join('');
    }

    handleDragStart(e, index) {
        if (!this.isEditMode) return;
        this.draggedItemIndex = index;
        e.target.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
    }

    handleDragOver(e, index) {
        if (!this.isEditMode) return;
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        const li = e.target.closest('li');
        if (li) li.classList.add('drag-over');
    }

    handleDrop(e, index) {
        if (!this.isEditMode) return;
        e.preventDefault();
        const li = e.target.closest('li');
        if (li) li.classList.remove('drag-over');

        if (this.draggedItemIndex === index) return;

        const data = [...this.quizData];
        const draggedItem = data.splice(this.draggedItemIndex, 1)[0];
        data.splice(index, 0, draggedItem);

        this.quizData = data;
        this.saveData();
        this.renderTOC();
    }

    handleDragEnd(e) {
        const draggingItems = this.tocList.querySelectorAll('.dragging');
        draggingItems.forEach(item => item.classList.remove('dragging'));
        const overItems = this.tocList.querySelectorAll('.drag-over');
        overItems.forEach(item => item.classList.remove('drag-over'));
    }

    movePage(index, direction) { const newIndex = index + direction; if (newIndex < 0 || newIndex >= this.quizData.length) return; const temp = this.quizData[index]; this.quizData[index] = this.quizData[newIndex]; this.quizData[newIndex] = temp; this.saveData(); this.renderTOC(); }
    updateActiveTOC(id) { this.tocList.querySelectorAll('a').forEach(a => a.classList.toggle('active', a.getAttribute('href') === `#${id}`)); }

    addNewPage() {
        const title = prompt('タイトル:'); if (!title) return;
        const isMulti = confirm('複数選択（ランキング形式）にしますか？\nOK: 複数選択, キャンセル: 単一選択');
        const id = 'p-' + Date.now();
        const cols = isMulti ? [
            "順位", "【生計維持】", "【生計同一】", "配偶者", "子", "父母", "孫", "祖父母", "兄弟姉妹", "3親等以内", "対象なし"
        ] : ["項目", "選択1", "選択2"];

        const questions = [];
        if (isMulti) {
            for (let i = 1; i <= 6; i++) {
                questions.push({ id: 'q-' + Date.now() + i, text: `第${i}順位`, answer: [] });
            }
        } else {
            questions.push({ id: 'q-' + Date.now(), text: "新問題", answer: cols[1] });
        }

        this.quizData.push({
            id, title, isMultiSelect: isMulti,
            columns: cols,
            questions: questions
        });

        this.isAutoGenerated = false;
        this.saveData();
        this.renderTOC();
        this.loadSet(id);

        // Scroll to the new page in the sidebar
        setTimeout(() => {
            const newElem = this.tocList.lastElementChild;
            if (newElem) newElem.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 100);
    }

    addNewRow() {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        set.questions.push({
            id: 'q-' + Date.now(),
            text: "新問題...",
            memo: "",
            answer: set.isMultiSelect ? [] : set.columns[1]
        });
        this.saveData();
        this.renderTable();
    }
    addNewColumn() { if (this.isAutoGenerated) return; const set = this.quizData.find(s => s.id === this.currentSetId); const name = prompt('列名:'); if (!name) return; set.columns.push(name); this.saveData(); this.renderTable(); }

    deleteCurrentPage() {
        if (this.quizData.length <= 1 || this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (confirm(`このページ（${set.title}）の全問題データを削除しますか？\nこの操作は取り消せません。`)) {
            this.quizData = this.quizData.filter(s => s.id !== this.currentSetId);
            this.saveData(); this.currentSetId = this.quizData[0].id; this.renderTOC(); this.loadSet(this.currentSetId);
        }
    }

    cloneCurrentPage() {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (!set) return;

        const newId = 'p-' + Date.now();
        const clonedSet = JSON.parse(JSON.stringify(set));
        clonedSet.id = newId;
        clonedSet.title = clonedSet.title + '（コピー）';

        // Re-generate question IDs to avoid conflicts and start fresh stats
        clonedSet.questions.forEach((q, i) => {
            q.id = 'q-' + Date.now() + '-' + i + '-' + Math.random().toString(36).substr(2, 5);
        });

        this.quizData.push(clonedSet);
        this.saveData();
        this.isAutoGenerated = false;
        this.renderTOC();
        this.loadSet(newId);
    }

    clearData() {
        const input = prompt('すべての学習データと履歴を完全に削除しますか？\n削除する場合は、確認のため「RESET」と入力してください。\n注：事前に「バックアップ保存」を行うことをお勧めします。');
        if (input === 'RESET') { localStorage.clear(); window.location.reload(); } else if (input !== null) { alert('入力が正しくないため、削除はキャンセルされました。'); }
    }

    // --- Data Management (Export/Import) ---

    getTimestamp() {
        const now = new Date();
        const pad = (n) => n.toString().padStart(2, '0');
        return `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    }

    async exportToJSON() {
        const fullData = {
            quizData: this.quizData,
            history: this.history,
            questionStats: this.questionStats,
            exportedAt: new Date().toISOString()
        };
        const fileName = `sharo_study_backup_${this.getTimestamp()}.json`;
        const jsonContent = JSON.stringify(fullData, null, 2);

        // Try File System Access API for folder selection
        if (window.showSaveFilePicker) {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{ description: 'JSON File', accept: { 'application/json': ['.json'] } }]
                });
                const writable = await handle.createWritable();
                await writable.write(jsonContent);
                await writable.close();
                this.updateDataStatus("JSONを保存しました。");
                return;
            } catch (err) {
                if (err.name === 'AbortError') return;
                console.error("showSaveFilePicker failed:", err);
            }
        }

        // Fallback for older browsers
        const blob = new Blob([jsonContent], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
        this.updateDataStatus("JSON形式でエクスポートしました（ダウンロードフォルダに保存）。");
    }

    async exportToCSV() {
        // CSV is focused on quiz questions only (for spreadsheet editing)
        let csv = '\uFEFF'; // UTF-8 BOM
        csv += 'ページタイトル,ID,問題文,正解(カンマ区切り),解説,選択肢1,選択肢2,選択肢3,選択肢4,選択肢5,選択肢6,選択肢7,選択肢8,選択肢9,選択肢10\n';

        this.quizData.forEach(page => {
            page.questions.forEach(q => {
                const row = [
                    page.title,
                    q.id,
                    q.text,
                    Array.isArray(q.answer) ? q.answer.join('|') : q.answer,
                    q.memo || '',
                    ...(page.columns.slice(1)) // choice choices
                ].map(val => `"${(val || "").toString().replace(/"/g, '""')}"`).join(',');
                csv += row + '\n';
            });
        });

        const fileName = `sharo_questions_${this.getTimestamp()}.csv`;

        if (window.showSaveFilePicker) {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{ description: 'CSV File', accept: { 'text/csv': ['.csv'] } }]
                });
                const writable = await handle.createWritable();
                await writable.write(csv);
                await writable.close();
                this.updateDataStatus("CSVを保存しました。");
                return;
            } catch (err) {
                if (err.name === 'AbortError') return;
                console.error("showSaveFilePicker failed:", err);
            }
        }

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
        this.updateDataStatus("CSV形式でエクスポートしました（ダウンロードフォルダに保存）。");
    }

    handleFileImport(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            const content = event.target.result;
            if (file.name.endsWith('.json')) {
                this.importFromJSON(content);
            } else if (file.name.endsWith('.csv')) {
                this.importFromCSV(content);
            }
        };
        reader.readAsText(file);
    }

    importFromJSON(jsonString) {
        try {
            const data = JSON.parse(jsonString);
            if (!data.quizData) throw new Error('Invalid backup format');

            if (confirm('現在のデータをすべて上書きして復旧しますか？\n（現在の問題・履歴・統計がすべて消え、ファイルの内容に置き換わります）')) {
                this.quizData = data.quizData;
                this.history = data.history || [];
                this.questionStats = data.questionStats || {};

                this.saveData();
                this.saveHistory();
                this.saveQuestionStats();

                alert('データを正常に復元しました。');
                window.location.reload();
            }
        } catch (err) {
            console.error(err);
            alert('ファイルの読み込みに失敗しました。有効なJSONバックアップファイルであることを確認してください。');
        }
    }

    importFromCSV(csvString) {
        try {
            const lines = csvString.split(/\r?\n/);
            if (lines.length < 2) return;

            // Simple CSV parser (not handling all escapes, but works for standard export)
            const parseCSVLine = (line) => {
                const parts = [];
                let current = '';
                let inQuotes = false;
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"' && line[i + 1] === '"') { current += '"'; i++; }
                    else if (char === '"') inQuotes = !inQuotes;
                    else if (char === ',' && !inQuotes) { parts.push(current); current = ''; }
                    else current += char;
                }
                parts.push(current);
                return parts;
            };

            const header = parseCSVLine(lines[0]);
            const newPages = new Map();

            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                const row = parseCSVLine(lines[i]);
                const pageTitle = row[0];
                const id = row[1] || ('q-' + Math.random().toString(36).substr(2, 9));
                const text = row[2];
                const answerRaw = row[3];
                const choices = row.slice(4).filter(c => c !== undefined && c !== "");

                if (!pageTitle || !text) continue;

                if (!newPages.has(pageTitle)) {
                    newPages.set(pageTitle, {
                        id: 'p-' + Date.now() + Math.random().toString(36).substr(2, 5),
                        title: pageTitle,
                        columns: ["項目", ...choices],
                        questions: [],
                        isMultiSelect: answerRaw.includes('|')
                    });
                }

                const page = newPages.get(pageTitle);
                page.questions.push({
                    id: id,
                    text: text,
                    answer: page.isMultiSelect ? answerRaw.split('|') : answerRaw,
                    isInPool: true
                });
            }

            if (confirm(`CSVから ${newPages.size} ページの問題を取り込みますか？\n既存のページは維持され、末尾に追加されます。`)) {
                this.quizData.push(...Array.from(newPages.values()));
                this.saveData();
                alert('CSVからデータを正常に取り込みました。');
                this.renderTOC();
                this.loadSet(this.currentSetId);
            }
        } catch (err) {
            console.error(err);
            alert('CSVの解析に失敗しました。');
        }
    }

    updateDataStatus(msg) {
        if (this.dataStatusMsg) {
            this.dataStatusMsg.textContent = `${msg} (${new Date().toLocaleTimeString()})`;
            this.dataStatusMsg.style.color = 'var(--success)';
            setTimeout(() => {
                this.dataStatusMsg.style.color = 'var(--text-secondary)';
            }, 5000);
        }
        // Save export timestamp for reminder
        if (msg.includes("エクスポート")) {
            localStorage.setItem('sharo_last_export_at', new Date().toISOString());
            this.checkBackupFrequency();
        }
    }

    // --- Automatic Recovery and Protection ---

    checkAndOfferRecovery(manual = false) {
        const backupStr = localStorage.getItem('sharo_auto_backup');
        if (!backupStr) {
            if (manual) alert('内部バックアップが見つかりません。');
            return;
        }

        try {
            const backup = JSON.parse(backupStr);
            const isMainEmpty = (this.quizData.length <= DEFAULT_QUIZ_DATA.length && this.history.length === 0);

            if (manual || isMainEmpty) {
                const date = new Date(backup.savedAt).toLocaleString();
                const msg = manual
                    ? `内部バックアップ（保存日時: ${date}）からデータを復元しますか？\n現在編集中の内容は上書きされます。`
                    : `【データ復旧の案内】\nメインデータが初期状態のようですが、内部バックアップ（保存日時: ${date}）が見つかりました。\n以前の状態を復元しますか？`;

                if (confirm(msg)) {
                    this.quizData = backup.quizData;
                    this.history = backup.history || [];
                    this.questionStats = backup.questionStats || {};
                    this.saveData();
                    this.saveHistory();
                    this.saveQuestionStats();
                    alert('データを正常に復元しました。');
                    window.location.reload();
                }
            }
        } catch (e) {
            console.error("Backup parse error", e);
        }
    }

    checkBackupFrequency() {
        const lastExport = localStorage.getItem('sharo_last_export_at');
        if (!lastExport) return;

        const hoursSince = (Date.now() - new Date(lastExport).getTime()) / (1000 * 60 * 60);
        if (hoursSince > 24) {
            const reminderArea = document.getElementById('backup-reminder');
            if (reminderArea) {
                reminderArea.style.display = 'block';
                reminderArea.innerHTML = `⚠️ 最終エクスポートから24時間以上経過しています。大切なデータを守るため、<span style="color:var(--accent); cursor:pointer; text-decoration:underline;" onclick="app.exportToJSON()">JSONバックアップの保存</span>をお勧めします。`;
            }
        } else {
            const reminderArea = document.getElementById('backup-reminder');
            if (reminderArea) reminderArea.style.display = 'none';
        }
    }
}
let app;
document.addEventListener('DOMContentLoaded', () => {
    app = new QuizApp();
    window.app = app; // Correctly expose app to global for onclick handlers
});
