const DEFAULT_QUIZ_DATA = [
    {
        id: "pension-1",
        title: "å›½æ°‘å¹´é‡‘æ³• è³‡æ ¼å–ªå¤±ã®æ™‚æœŸ (æ³•9æ¡) å¼·åˆ¶è¢«ä¿é™ºè€…",
        columns: ["é …ç›®", "å½“æ—¥å–ªå¤±", "ç¿Œæ—¥å–ªå¤±"],
        questions: [
            { id: "q-1", text: "ã‚¤ï¼‰æ­»äº¡ã—ãŸã¨ã", answer: "ç¿Œæ—¥å–ªå¤±" },
            { id: "q-2", text: "ãƒ‹ï¼‰åšç”Ÿå¹´é‡‘ä¿é™ºæ³•ã«åŸºã¥ãè€é½¢çµ¦ä»˜ç­‰ã‚’å—ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹è€…ãã®ä»–ã“ã®æ³•å¾‹ã®é©ç”¨ã‚’é™¤å¤–ã™ã¹ãç‰¹åˆ¥ã®ç†ç”±ãŒã‚ã‚‹è€…ã¨ã—ã¦åšç”ŸåŠ´åƒçœä»¤ã§å®šã‚ã‚‹è€…ã¨ãªã£ãŸã¨ãï¼ˆç¬¬2å·è¢«ä¿é™ºè€…åˆã¯ç¬¬3å·è¢«ä¿é™ºè€…ã«è©²å½“ã™ã‚‹ã¨ãã‚’é™¤ãï¼‰", answer: "å½“æ—¥å–ªå¤±" },
            { id: "q-3", text: "ãƒï¼‰60æ­³ã«é”ã—ãŸã¨ãï¼ˆç¬¬2å·è¢«ä¿é™ºè€…ã«è©²å½“ã™ã‚‹ã¨ãã‚’é™¤ãï¼‰", answer: "å½“æ—¥å–ªå¤±" }
        ]
    },
    {
        id: "survivor-rank-1",
        title: "ã€ç‰¹è¨“ã€‘éºæ—ã®é †ä½åˆ¤å®šï¼ˆã‚¹ãƒªãƒ ç‰ˆï¼‰",
        isMultiSelect: true,
        columns: [
            "é †ä½", "ã€ç”Ÿè¨ˆç¶­æŒã€‘", "ã€ç”Ÿè¨ˆåŒä¸€ã€‘", "é…å¶è€…", "å­", "çˆ¶æ¯", "å­«", "ç¥–çˆ¶æ¯", "å…„å¼Ÿå§‰å¦¹", "3è¦ªç­‰ä»¥å†…", "å¯¾è±¡ãªã—"
        ],
        questions: [
            { id: "q-surv-1", text: "ç¬¬1é †ä½", answer: ["é…å¶è€…", "å­", "ã€ç”Ÿè¨ˆç¶­æŒã€‘"] },
            { id: "q-surv-2", text: "ç¬¬2é †ä½", answer: ["çˆ¶æ¯", "ã€ç”Ÿè¨ˆç¶­æŒã€‘"] },
            { id: "q-surv-3", text: "ç¬¬3é †ä½", answer: ["å­«", "ã€ç”Ÿè¨ˆç¶­æŒã€‘"] },
            { id: "q-surv-4", text: "ç¬¬4é †ä½", answer: ["ç¥–çˆ¶æ¯", "ã€ç”Ÿè¨ˆç¶­æŒã€‘"] },
            { id: "q-surv-5", text: "ç¬¬5é †ä½", answer: ["å¯¾è±¡ãªã—"] },
            { id: "q-surv-6", text: "ç¬¬6é †ä½", answer: ["å¯¾è±¡ãªã—"] }
        ]
    },
    {
        id: "clause-sample-1",
        title: "é›‡ç”¨ä¿é™ºæ³• ç¬¬1æ¡ï¼ˆç›®çš„ï¼‰",
        type: "clause",
        text: "é›‡ç”¨ä¿é™ºã¯ã€åŠ´åƒè€…ãŒ[[å¤±æ¥­]]ã—ãŸå ´åˆåŠã³åŠ´åƒè€…ã«ã¤ã„ã¦[[é›‡ç”¨ã®ç¶™ç¶š]]ãŒå›°é›£ã¨ãªã‚‹äº‹ç”±ãŒç”Ÿã˜ãŸå ´åˆã«å¿…è¦ãªçµ¦ä»˜ã‚’è¡Œã†ã»ã‹ã€åŠ´åƒè€…ãŒè‡ªã‚‰è·æ¥­ã«é–¢ã™ã‚‹[[æ•™è‚²è¨“ç·´]]ã‚’å—ã‘ãŸå ´åˆä¸¦ã³ã«åŠ´åƒè€…ãŒ[[å­ã‚’é¤Šè‚²]]ã™ã‚‹ãŸã‚ã®ä¼‘æ¥­åŠã³[[æ‰€å®šåŠ´åƒæ™‚é–“]]ã‚’çŸ­ç¸®ã™ã‚‹ã“ã¨ã«ã‚ˆã‚‹å°±æ¥­ã‚’ã—ãŸå ´åˆã«å¿…è¦ãªçµ¦ä»˜ã‚’è¡Œã†ã“ã¨ã«ã‚ˆã‚Šã€åŠ´åƒè€…ã®[[ç”Ÿæ´»åŠã³é›‡ç”¨]]ã®å®‰å®šã‚’å›³ã‚‹ã¨ã¨ã‚‚ã«ã€[[æ±‚è·æ´»å‹•]]ã‚’å®¹æ˜“ã«ã™ã‚‹ç­‰ãã®å°±è·ã‚’ä¿ƒé€²ã—ã€ã‚ã‚ã›ã¦ã€åŠ´åƒè€…ã®[[è·æ¥­ã®å®‰å®š]]ã«è³‡ã™ã‚‹ãŸã‚ã€[[å¤±æ¥­ã®äºˆé˜²]]ã€é›‡ç”¨çŠ¶æ…‹ã®æ˜¯æ­£åŠã³[[é›‡ç”¨æ©Ÿä¼šã®å¢—å¤§]]ã€åŠ´åƒè€…ã®[[èƒ½åŠ›ã®é–‹ç™º]]åŠã³å‘ä¸Šãã®ä»–åŠ´åƒè€…ã®[[ç¦ç¥‰ã®å¢—é€²]]ã‚’å›³ã‚‹ã“ã¨ã‚’ç›®çš„ã¨ã™ã‚‹ã€‚",
        dummies: ["è€é½¢åŸºç¤å¹´é‡‘", "åšç”ŸåŠ´åƒå¤§è‡£", "60æ—¥ä»¥å†…"],
        questions: []
    }
];

// Spaced Repetition System (SRS) intervals in days
// Level 0: New, Level 1: 1 day, Level 2: 2 days, Level 3: 4 days, etc.
const SRS_INTERVALS = [0, 1, 2, 4, 7, 14, 30, 60, 120, 180, 365];


class QuizApp {
    constructor() {
        this.quizData = this.loadData();
        this.history = this.loadHistory();
        this.questionStats = this.loadQuestionStats();
        this.currentSetId = this.quizData[0].id;
        this.isEditMode = false;
        this.isAutoGenerated = false;
        this.selectedKeyword = null; // Track clicked keyword for "Click-to-Fill" fallback

        this.userAnswers = {};
        this.isChecked = false;
        this.sortColumnIndex = -1;
        this.sortDirection = 1;

        this.chartMode = 'accuracy';
        this.statsChart = null;
        this.questionObserver = null;
        this.isBankMinimized = false; // Persistent state for the session
        this.dailyGoal = 50;

        this.migrateData();
        this.cacheDOM();
        this.bindEvents();
        if (this.closeModalBtn) {
            this.closeModalBtn.addEventListener('click', () => this.srsModal.classList.add('hidden'));
        }
        window.addEventListener('click', (e) => {
            if (e.target === this.srsModal) this.srsModal.classList.add('hidden');
        });

        // Initial call
        this.init();
        this.updateDashboard();

    }

    migrateData() {
        let modified = false;

        // 1. Inject/Update Survivor Sample (Check for "ã‚¹ãƒªãƒ ç‰ˆ" or column count change)
        const currentRank = this.quizData.find(s => s.id === "survivor-rank-1");
        const defaultRank = DEFAULT_QUIZ_DATA.find(s => s.id === "survivor-rank-1");

        if (!currentRank || (currentRank.columns && currentRank.columns[1] !== "ã€ç”Ÿè¨ˆç¶­æŒã€‘")) {
            if (currentRank) {
                this.quizData = this.quizData.filter(s => s.id !== "survivor-rank-1");
            }
            this.quizData.push(JSON.parse(JSON.stringify(defaultRank)));
            modified = true;
        }

        // SAFETY: Circular reference and orphaned item rescue
        const reachableIds = new Set();
        const walk = (parentId) => {
            this.quizData.filter(item => item.parentId === parentId).forEach(item => {
                if (reachableIds.has(item.id)) return; // Prevent infinite loop
                reachableIds.add(item.id);
                walk(item.id);
            });
        };
        walk(null); // Start from root

        this.quizData.forEach(set => {
            if (!set.type) set.type = 'page';
            if (set.parentId === undefined) set.parentId = null;
            if (set.isCollapsed === undefined) set.isCollapsed = false;
            if (set.isInPool === undefined) set.isInPool = true;

            if (!reachableIds.has(set.id)) {
                // Rescue item by moving to root
                set.parentId = null;
                reachableIds.add(set.id); // Mark as now reachable to prevent redundant rescue
                modified = true;
            }

            if (set.type === 'page') {
                if (!set.questions) return;
                set.questions.forEach(q => {
                    if (!q.id) { q.id = 'q-' + Math.random().toString(36).substr(2, 9) + Date.now(); modified = true; }
                    if (set.isMultiSelect && typeof q.answer === 'string') {
                        q.answer = [q.answer];
                        modified = true;
                    }
                    if (q.isInPool === undefined) {
                        q.isInPool = true;
                        modified = true;
                    }
                });
            }
        });

        // 2. Safe cleanup of questionStats
        // BUG FIX: Only cleanup stats if quizData is successfully loaded and has content.
        // If quizData is somehow empty or fallback-only but stats exist, we MUST NOT wipe them.
        if (this.quizData && this.quizData.length > 0) {
            const cleanedStats = {};
            const allIds = new Set();
            this.quizData.forEach(set => {
                if (set.type === 'page' && set.questions) {
                    set.questions.forEach(q => allIds.add(q.id));
                } else if (set.type === 'clause' && set.text) {
                    // Include summary ID and individual IDs for each blank
                    allIds.add(`clause-summary-${set.id}`);
                    const blankCount = set.text.split('[[').length - 1;
                    for (let i = 0; i < blankCount; i++) {
                        allIds.add(`clause-${set.id}-${i}`);
                    }
                }
            });

            let hasWiped = false;
            Object.keys(this.questionStats).forEach(key => {
                // Determine base ID to check if it's still reachable
                let baseId = key;
                if (key.startsWith('clause-summary-')) baseId = key.replace('clause-summary-', '');
                else if (key.startsWith('clause-')) {
                    const parts = key.split('-');
                    // e.g. clause-p-123-0 -> baseId = p-123
                    if (parts.length >= 3) baseId = parts.slice(1, -1).join('-');
                }

                if (allIds.has(baseId) || allIds.has(key)) {
                    cleanedStats[key] = this.questionStats[key];
                    // Initialize recent history for older data
                    if (!cleanedStats[key].recent) {
                        const t = cleanedStats[key].total || 0;
                        const c = cleanedStats[key].correct || 0;
                        const count = Math.min(t, 5);
                        const r = [];
                        const recentCorrect = t > 0 ? Math.round((c / t) * count) : 0;
                        for (let i = 0; i < count; i++) r.push(i < recentCorrect ? 1 : 0);
                        cleanedStats[key].recent = r;
                    }
                    // Initialize SRS fields
                    if (cleanedStats[key].srsLevel === undefined) cleanedStats[key].srsLevel = 0;

                    // CRITICAL: Only Summaries or regular Questions should have a review schedule.
                    // Clear nextReview from individual blanks (clause-ID-index) to prevent overcounting.
                    const isBlankStat = key.startsWith('clause-') && !key.startsWith('clause-summary-');
                    if (isBlankStat) {
                        cleanedStats[key].nextReview = null;
                    } else if (cleanedStats[key].nextReview === undefined) {
                        cleanedStats[key].nextReview = null;
                    }
                } else {
                    hasWiped = true;
                }
            });

            // SAFETY: If we are about to wipe more than 50% of stats, something might be wrong.
            if (hasWiped && Object.keys(this.questionStats).length > 10 && Object.keys(cleanedStats).length < (Object.keys(this.questionStats).length / 2)) {
                console.warn("Migration safety triggered: Excessive stat cleanup prevented.");
            } else {
                this.questionStats = cleanedStats;
            }
        }

        this.isChecked = false;
        this.shuffledCache = {};

        if (modified) this.saveData();
        this.saveQuestionStats();
    }

    cacheDOM() {
        this.tabQuiz = document.getElementById('tab-quiz');
        this.tabStats = document.getElementById('tab-stats');
        this.quizView = document.getElementById('quiz-view');
        this.statsView = document.getElementById('stats-view');
        this.tocList = document.getElementById('toc-list');
        this.quizTitle = document.getElementById('quiz-title');
        this.tableHead = document.getElementById('table-head');
        this.tableBody = document.getElementById('table-body');
        this.scoreDisplay = document.getElementById('score');
        this.editModeToggle = document.getElementById('edit-mode-toggle');
        this.addFolderBtn = document.getElementById('add-folder-btn');
        this.addPageBtn = document.getElementById('add-page-btn');
        this.addClauseBtn = document.getElementById('add-clause-btn');
        this.addRowBtn = document.getElementById('add-row-btn');
        this.addColumnBtn = document.getElementById('add-column-btn');
        this.clearDataBtn = document.getElementById('clear-data-btn');
        this.deletePageBtn = document.getElementById('delete-page-btn');
        this.clonePageBtn = document.getElementById('clone-page-btn');
        this.checkAnswersBtn = document.getElementById('check-answers-btn');
        this.resetWrongBtn = document.getElementById('reset-wrong-btn');
        this.resetAllBtn = document.getElementById('reset-all-btn');
        this.peekAnswersBtn = document.getElementById('peek-answers-btn');

        this.homeBtn = document.getElementById('home-btn');
        this.homeDashboard = document.getElementById('home-dashboard');
        this.quizArea = document.getElementById('quiz-area');
        this.dueListContainer = document.getElementById('due-questions-container');
        this.dueListBody = document.getElementById('due-questions-body');
        this.dueCard = document.getElementById('due-card');
        this.startClauseOneReviewBtn = document.getElementById('start-clause-one-review-btn');
        this.startClauseReviewBtn = document.getElementById('start-clause-review-btn');
        this.startPageReviewBtn = document.getElementById('start-page-review-btn');

        this.totalAccuracy = document.getElementById('total-accuracy');
        this.totalAnsweredDisplay = document.getElementById('total-answered');
        this.historyBody = document.getElementById('history-body');
        this.weakQuestionsBody = document.getElementById('weak-questions-body');
        this.genWeakBtn = document.getElementById('gen-weak-btn');
        this.genWeakClauseBtn = document.getElementById('gen-weak-clause-btn');
        this.genRareBtn = document.getElementById('gen-rare-btn');
        this.genRandomBtn = document.getElementById('gen-random-btn');
        this.genSRSClauseBtn = document.getElementById('gen-srs-clause-btn');
        this.genSRSPageBtn = document.getElementById('gen-srs-page-btn');
        this.sidebarGenSRSClauseBtn = document.getElementById('sidebar-gen-srs-clause-btn');
        this.sidebarGenSRSPageBtn = document.getElementById('sidebar-gen-srs-page-btn');

        this.chartBtns = {
            accuracy: document.getElementById('show-accuracy-btn'),
            frequency: document.getElementById('show-frequency-btn'),
            errors: document.getElementById('show-errors-btn')
        };
        this.sidebar = document.getElementById('sidebar');
        this.sidebarContent = document.getElementById('quiz-sidebar-content');
        this.menuToggle = document.getElementById('menu-toggle');
        this.sidebarCloseBtn = document.getElementById('sidebar-close-btn');

        // Data management
        this.exportJsonBtn = document.getElementById('export-json-btn');
        this.importJsonBtn = document.getElementById('import-json-btn');
        this.sidebarExportBtn = document.getElementById('sidebar-export-json-btn');
        this.sidebarImportBtn = document.getElementById('sidebar-import-json-btn');
        this.exportCsvBtn = document.getElementById('export-csv-btn');
        this.importCsvBtn = document.getElementById('import-csv-btn');
        this.dataImportInput = document.getElementById('data-import-input');
        this.dataStatusMsg = document.getElementById('data-status-msg');
        this.understandingMap = document.getElementById('understanding-map');
        this.srsModal = document.getElementById('srs-modal');
        this.srsInfo = document.getElementById('srs-info');
        this.srsModalTitle = document.getElementById('srs-modal-title');
        this.closeModalBtn = document.getElementById('close-modal');
        this.srsDetailChart = null;
        this.clauseEditor = document.getElementById('clause-editor');

        this.clauseTextEditor = document.getElementById('clause-text-editor');
        this.clauseDummiesEditor = document.getElementById('clause-dummies-editor');
        this.clauseDisplay = document.getElementById('clause-display');
        this.tableWrapper = document.querySelector('.table-wrapper');
        this.columnControls = document.querySelector('.column-controls');
        this.tableControls = document.querySelector('.table-controls');
        this.insertTableBtn = document.getElementById('insert-table-btn');
        this.clearPoolBtn = document.getElementById('clear-pool-btn');
        this.selectAllPoolBtn = document.getElementById('select-all-pool-btn');
        this.globalKeywordBank = document.getElementById('global-keyword-bank');

        // GitHub Sync UI
        this.ghTokenInput = document.getElementById('gh-token');
        this.ghRepoInput = document.getElementById('gh-repo');
        this.ghPathInput = document.getElementById('gh-path');
        this.ghSyncStatus = document.getElementById('github-sync-status');
        this.ghSaveConfigBtn = document.getElementById('gh-save-config-btn');
        this.ghSyncNowBtn = document.getElementById('gh-sync-now-btn');
        this.sidebarGhSyncBtn = document.getElementById('sidebar-gh-sync-btn');
    }

    bindEvents() {
        if (this.tabQuiz) this.tabQuiz.addEventListener('click', () => this.switchView('quiz'));
        if (this.tabStats) this.tabStats.addEventListener('click', () => this.switchView('stats'));
        if (this.clearPoolBtn) {
            this.clearPoolBtn.addEventListener('click', () => this.clearAllPoolSelections());
        }
        if (this.selectAllPoolBtn) {
            this.selectAllPoolBtn.addEventListener('click', () => this.selectAllPoolSelections());
        }
        if (this.editModeToggle) {
            this.editModeToggle.addEventListener('change', (e) => {
                this.isEditMode = e.target.checked;
                document.body.classList.toggle('edit-mode', this.isEditMode);
                this.updateTitleEditability();
                this.resetQuiz(); this.renderTOC(); this.renderTable();
            });
        }
        if (this.checkAnswersBtn) this.checkAnswersBtn.addEventListener('click', () => this.batchCheckAnswers());
        if (this.resetWrongBtn) this.resetWrongBtn.addEventListener('click', () => this.resetWrongAnswers());
        if (this.resetAllBtn) this.resetAllBtn.addEventListener('click', () => this.resetQuiz());
        if (this.peekAnswersBtn) {
            this.peekAnswersBtn.addEventListener('click', () => {
                const isRevealed = this.quizView.classList.toggle('answers-revealed');
                this.peekAnswersBtn.innerHTML = isRevealed ? 'ğŸ‘ï¸ ç­”ãˆã‚’éš ã™' : 'ğŸ‘ï¸ ç­”ãˆã‚’è¡¨ç¤ºã™ã‚‹';
                this.peekAnswersBtn.classList.toggle('active', isRevealed);
            });
        }
        if (this.addFolderBtn) this.addFolderBtn.addEventListener('click', () => this.addNewFolder());
        if (this.addPageBtn) this.addPageBtn.addEventListener('click', () => this.addNewPage());
        if (this.addClauseBtn) this.addClauseBtn.addEventListener('click', () => this.addNewClausePage());
        if (this.addRowBtn) this.addRowBtn.addEventListener('click', () => this.addNewRow());
        if (this.addColumnBtn) this.addColumnBtn.addEventListener('click', () => this.addNewColumn());
        if (this.clearDataBtn) this.clearDataBtn.addEventListener('click', () => this.clearData());
        if (this.deletePageBtn) this.deletePageBtn.addEventListener('click', () => this.deleteCurrentPage());
        if (this.clonePageBtn) this.clonePageBtn.addEventListener('click', () => this.cloneCurrentPage());

        if (this.insertTableBtn && this.clauseTextEditor) {
            this.insertTableBtn.addEventListener('click', () => {
                const template = "\n| é …ç›® | å†…å®¹ | å‚™è€ƒ |\n| --- | --- | --- |\n| [[ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰1]] | å†…å®¹1 | å‚™è€ƒ1 |\n| [[ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰2]] | å†…å®¹2 | å‚™è€ƒ2 |\n";
                const start = this.clauseTextEditor.selectionStart;
                const end = this.clauseTextEditor.selectionEnd;
                const text = this.clauseTextEditor.value;
                this.clauseTextEditor.value = text.substring(0, start) + template + text.substring(end);
                this.clauseTextEditor.dispatchEvent(new Event('input')); // Trigger update
            });
        }

        if (this.genWeakBtn) this.genWeakBtn.addEventListener('click', () => this.generateSpecialQuiz('weak'));
        if (this.genWeakClauseBtn) {
            this.genWeakClauseBtn.addEventListener('click', () => this.generateSpecialQuiz('clause-weak'));
        }
        if (this.genRareBtn) this.genRareBtn.addEventListener('click', () => this.generateSpecialQuiz('rare'));
        if (this.genRandomBtn) this.genRandomBtn.addEventListener('click', () => this.generateSpecialQuiz('random'));
        if (this.genSRSClauseBtn) this.genSRSClauseBtn.addEventListener('click', () => this.generateSpecialQuiz('srs-clause'));
        if (this.genSRSPageBtn) this.genSRSPageBtn.addEventListener('click', () => this.generateSpecialQuiz('srs-page'));
        if (this.sidebarGenSRSClauseBtn) this.sidebarGenSRSClauseBtn.addEventListener('click', () => this.generateSpecialQuiz('srs-clause'));
        if (this.sidebarGenSRSPageBtn) this.sidebarGenSRSPageBtn.addEventListener('click', () => this.generateSpecialQuiz('srs-page'));

        if (this.chartBtns) {
            Object.keys(this.chartBtns).forEach(mode => {
                if (this.chartBtns[mode]) {
                    this.chartBtns[mode].addEventListener('click', () => {
                        this.chartMode = mode;
                        this.updateChartTabs();
                        this.renderChart();
                    });
                }
            });
        }
        if (this.tocList) {
            this.tocList.addEventListener('click', (e) => {
                if (e.target.tagName === 'A') {
                    e.preventDefault();
                    const id = e.target.getAttribute('href').substring(1);
                    const item = this.quizData.find(s => s.id === id);
                    if (item && item.type === 'folder') {
                        this.toggleFolder(id);
                    } else if (item) {
                        this.isAutoGenerated = false;
                        this.currentSetId = id;
                        this.loadSet(id);

                        // Auto-close sidebar on mobile/tablet after selection
                        if (window.innerWidth <= 1024 && this.sidebar) {
                            this.sidebar.classList.remove('open');
                        }
                    }
                }
            });
        }

        // Update TOC real-time when editing title
        if (this.quizTitle) {
            this.quizTitle.addEventListener('input', () => {
                if (this.isEditMode && !this.isAutoGenerated) {
                    const set = this.quizData.find(s => s.id === this.currentSetId);
                    if (set) {
                        set.title = this.quizTitle.textContent.trim();
                        this.renderTOC();
                    }
                }
            });

            this.quizTitle.addEventListener('blur', () => {
                if (this.isEditMode && !this.isAutoGenerated) {
                    const set = this.quizData.find(s => s.id === this.currentSetId);
                    if (set) {
                        set.title = this.quizTitle.textContent.trim();
                        this.saveData();
                    }
                }
            });
        }
        if (this.sidebar && this.menuToggle) {
            this.menuToggle.addEventListener('click', () => {
                if (window.innerWidth > 1024) {
                    // Desktop: Toggle permanent hide/show
                    document.body.classList.toggle('sidebar-hidden');
                } else {
                    // Mobile/Tablet: Toggle slide-in drawer
                    this.sidebar.classList.toggle('open');
                }
            });
        }
        if (this.sidebarCloseBtn) {
            this.sidebarCloseBtn.addEventListener('click', () => {
                if (window.innerWidth > 1024) {
                    document.body.classList.add('sidebar-hidden');
                } else {
                    this.sidebar.classList.remove('open');
                }
            });
        }
        if (this.homeBtn) {
            this.homeBtn.addEventListener('click', () => {
                this.isAutoGenerated = false;
                this.loadSet(null);
                this.switchView('quiz');
            });
        }
        if (this.dueCard) {
            this.dueCard.addEventListener('click', (e) => {
                if (e.target.tagName !== 'BUTTON') this.toggleDueList();
            });
        }
        if (this.startClauseOneReviewBtn) {
            this.startClauseOneReviewBtn.addEventListener('click', () => this.generateDueReview('clause', 1));
        }
        if (this.startClauseReviewBtn) {
            this.startClauseReviewBtn.addEventListener('click', () => this.generateDueReview('clause', 3));
        }
        if (this.startPageReviewBtn) {
            this.startPageReviewBtn.addEventListener('click', () => this.generateDueReview('page', 10));
        }

        // Data management events
        if (this.exportJsonBtn) this.exportJsonBtn.addEventListener('click', () => this.exportToJSON());
        if (this.importJsonBtn && this.dataImportInput) {
            this.importJsonBtn.addEventListener('click', () => { this.dataImportInput.accept = '.json'; this.dataImportInput.click(); });
        }
        if (this.sidebarExportBtn) this.sidebarExportBtn.addEventListener('click', () => this.exportToJSON());
        if (this.sidebarImportBtn && this.dataImportInput) {
            this.sidebarImportBtn.addEventListener('click', () => { this.dataImportInput.accept = '.json'; this.dataImportInput.click(); });
        }
        if (this.exportCsvBtn) this.exportCsvBtn.addEventListener('click', () => this.exportToCSV());
        if (this.importCsvBtn && this.dataImportInput) {
            this.importCsvBtn.addEventListener('click', () => { this.dataImportInput.accept = '.csv'; this.dataImportInput.click(); });
        }
        if (this.dataImportInput) {
            this.dataImportInput.addEventListener('change', (e) => this.handleFileImport(e));
        }

        // GitHub Sync events
        if (this.ghSaveConfigBtn) this.ghSaveConfigBtn.addEventListener('click', () => this.saveGitHubConfig());
        if (this.ghSyncNowBtn) this.ghSyncNowBtn.addEventListener('click', () => this.syncWithGitHub());
        if (this.sidebarGhSyncBtn) this.sidebarGhSyncBtn.addEventListener('click', () => this.syncWithGitHub());

        // Recovery button for internal backup
        const forceRestoreBtn = document.getElementById('force-restore-internal-btn');
        if (forceRestoreBtn) {
            forceRestoreBtn.addEventListener('click', () => this.checkAndOfferRecovery(true));
        }
    }

    init() {
        this.renderTOC();
        // If no specifically saved set, or just starting, show home dashboard
        if (!this.currentSetId) {
            this.loadSet(null);
        } else {
            this.loadSet(this.currentSetId);
        }
        this.checkAndOfferRecovery();
        this.checkBackupFrequency();
        this.updateDashboard();
        this.loadGitHubConfig();
    }

    loadData() { const saved = localStorage.getItem('sharoQuizData'); return saved ? JSON.parse(saved) : JSON.parse(JSON.stringify(DEFAULT_QUIZ_DATA)); }
    saveData() {
        this.pruneData();
        const dataStr = JSON.stringify(this.quizData);
        localStorage.setItem('sharoQuizData', dataStr);
        // Internal Redundancy: Also save to a backup key
        localStorage.setItem('sharo_auto_backup', JSON.stringify({
            quizData: this.quizData,
            history: this.history,
            questionStats: this.questionStats,
            savedAt: new Date().toISOString()
        }));
    }
    loadHistory() { const saved = localStorage.getItem('sharoQuizHistory'); return saved ? JSON.parse(saved) : []; }
    saveHistory() { localStorage.setItem('sharoQuizHistory', JSON.stringify(this.history)); }
    loadQuestionStats() { const saved = localStorage.getItem('sharoQuestionStats'); return saved ? JSON.parse(saved) : {}; }
    saveQuestionStats() { this.pruneData(); localStorage.setItem('sharoQuestionStats', JSON.stringify(this.questionStats)); }

    pruneData() {
        if (!this.quizData) return;
        const validIds = new Set();
        const walk = (items) => {
            items.forEach(item => {
                if (item.type === 'clause') {
                    validIds.add(`clause-summary-${item.id}`);
                }
                if (item.questions) {
                    item.questions.forEach(q => validIds.add(q.id));
                }
                if (item.children) walk(item.children);
            });
        };
        walk(this.quizData);

        // Prune entries that aren't in current quiz data
        Object.keys(this.questionStats).forEach(id => {
            if (!validIds.has(id)) {
                delete this.questionStats[id];
            } else {
                // Limit history to last 20 entries to save space
                if (this.questionStats[id].history && Array.isArray(this.questionStats[id].history) && this.questionStats[id].history.length > 20) {
                    this.questionStats[id].history = this.questionStats[id].history.slice(-20);
                }
            }
        });
    }

    updateSRS(stat, isCorrect) {
        if (!stat) return;
        if (stat.srsLevel === undefined) stat.srsLevel = 0;
        if (!stat.history) stat.history = [];

        // Record attempt
        stat.history.push({
            date: new Date().toISOString(),
            isCorrect: isCorrect,
            level: stat.srsLevel
        });
        if (stat.history.length > 20) stat.history.shift();

        if (isCorrect) {
            stat.srsLevel = Math.min(stat.srsLevel + 1, SRS_INTERVALS.length - 1);
        } else {
            // Drop 2 levels on mistake, but keep at least 0
            stat.srsLevel = Math.max(0, stat.srsLevel - 2);
        }

        const days = SRS_INTERVALS[stat.srsLevel];
        const nextDate = new Date();
        nextDate.setDate(nextDate.getDate() + days);
        // Reset to beginning of day for simpler comparison (optional, but good for "daily" review)
        nextDate.setHours(0, 0, 0, 0);
        stat.nextReview = nextDate.toISOString();
    }

    normalizeInput(str) {
        if (!str) return "";
        return str.trim().replace(/[ï¼-ï¼™]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
    }

    showSRSDetail(statKey) {
        const stat = this.questionStats[statKey];
        if (!stat) return;

        this.srsModal.classList.remove('hidden');
        this.srsModalTitle.textContent = `è¨˜æ†¶å®šç€ã®æ¨ç§»: ${stat.text.substring(0, 40)}${stat.text.length > 40 ? '...' : ''}`;

        // Ensure history exists or reconstruct from recent for legacy data
        let history = stat.history || [];
        if (history.length === 0 && stat.recent && stat.recent.length > 0) {
            history = stat.recent.map((isCorrect, i) => ({
                date: new Date(Date.now() - (stat.recent.length - 1 - i) * 60000).toISOString(),
                isCorrect: !!isCorrect
            }));
            // Persist the reconstructed history so it shows up next time and is synced
            stat.history = history;
            this.saveQuestionStats();
        }

        const nextReview = stat.nextReview ? new Date(stat.nextReview) : null;

        const labels = history.map((h, i) => {
            const d = new Date(h.date);
            const dateStr = isNaN(d) ? '?' : (d.getMonth() + 1) + '/' + d.getDate();
            return `${i + 1}å›ç›® (${dateStr})`;
        });

        const data = history.map((h, index) => {
            // ç›´è¿‘5å›åˆ†ï¼ˆè‡ªåˆ†ã‚’å«ã‚€ï¼‰ã®æ­£ç­”ç‡ã‚’è¨ˆç®—
            const start = Math.max(0, index - 4);
            const window = history.slice(start, index + 1);
            const correctInWindow = window.filter(x => x.isCorrect).length;
            return Math.round((correctInWindow / window.length) * 100);
        });

        const pointColors = history.map(h => h.isCorrect ? '#4ade80' : '#f72585');

        // ç›´è¿‘5å›ã®æ­£ç­”ç‡ã‚’å–å¾—ï¼ˆæœ€æ–°ã®ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ï¼‰
        const recentAccuracy = data.length > 0 ? data[data.length - 1] : 0;

        if (nextReview) {
            labels.push(`æ¬¡å› (${(nextReview.getMonth() + 1)}/${nextReview.getDate()})`);
            data.push(recentAccuracy);
            pointColors.push('#ffd166');
        }

        if (this.srsDetailChart) {
            this.srsDetailChart.destroy();
            this.srsDetailChart = null;
        }

        // Use a short delay to ensure canvas is ready and sized
        setTimeout(() => {
            const canvas = document.getElementById('srsDetailChart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            this.srsDetailChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'æ­£ç­”ç‡ (%)',
                        data: data,
                        borderColor: '#4cc9f0',
                        backgroundColor: 'rgba(76, 201, 240, 0.2)',
                        fill: true,
                        tension: 0.1, // Reduced tension to avoid weird curves with few points
                        pointBackgroundColor: pointColors,
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        showLine: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            ticks: { color: 'rgba(255,255,255,0.8)', font: { size: 10 } }
                        },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            ticks: {
                                color: 'rgba(255,255,255,0.8)',
                                stepSize: 20,
                                callback: (value) => value + '%'
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const idx = context.dataIndex;
                                    if (idx < history.length) {
                                        return `æ­£ç­”ç‡: ${context.raw}% (${history[idx].isCorrect ? 'æ­£è§£' : 'ä¸æ­£è§£'})`;
                                    }
                                    return `ç¾åœ¨ã®æ­£ç­”ç‡: ${context.raw}%`;
                                }
                            }
                        }
                    }
                }
            });
        }, 100);

        // Calculate recent accuracy from indices
        const recentHistory = history.slice(-5);
        const recentCorrect = recentHistory.filter(h => h.isCorrect).length;
        const recentTotal = recentHistory.length;
        const recentRate = recentTotal > 0 ? Math.round((recentCorrect / recentTotal) * 100) : 0;

        this.srsInfo.innerHTML = `
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem; background: rgba(255,255,255,0.03); padding: 1.5rem; border-radius: 12px;">
                <div>
                    <p><strong>ç¾åœ¨ã®ç¿’ç†Ÿåº¦:</strong> Lv.${stat.srsLevel || 0}</p>
                    <p><strong>å¾©ç¿’é–“éš”:</strong> ${SRS_INTERVALS[stat.srsLevel || 0]} æ—¥</p>
                </div>
                <div>
                    <p><strong>æ¬¡å›ã®å¾©ç¿’äºˆå®š:</strong> ${nextReview ? nextReview.toLocaleDateString() : 'æœªå®š'}</p>
                    <p><strong>ç›´è¿‘5å›ã®æˆç¸¾:</strong> ${recentCorrect}/${recentTotal} (${recentRate}%)</p>
                </div>
            </div>
            <p style="margin-top: 0.5rem; opacity: 0.6; font-size: 0.75rem; text-align: right;">ç´¯è¨ˆæˆç¸¾: ${stat.correct}/${stat.total} (${stat.total > 0 ? Math.round((stat.correct / stat.total) * 100) : 0}%)</p>
            <p style="margin-top: 1rem; opacity: 0.7; font-size: 0.8rem;">â€»ã‚°ãƒ©ãƒ•ã¯ç›´è¿‘5å›åˆ†ã®ç§»å‹•å¹³å‡ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚ <span style="color:#4ade80">â—</span> ãŒæ­£è§£ã€<span style="color:#f72585">â—</span> ãŒä¸æ­£è§£ã§ã™ã€‚</p>
        `;
    }


    switchView(view) {
        // Toggle active classes based on view and current state
        const isHome = view === 'quiz' && this.currentSetId === null;
        const isQuiz = view === 'quiz' && this.currentSetId !== null;
        const isStats = view === 'stats';

        if (this.homeBtn) this.homeBtn.classList.toggle('active', isHome);
        if (this.tabQuiz) this.tabQuiz.classList.toggle('active', isQuiz);
        if (this.tabStats) this.tabStats.classList.toggle('active', isStats);

        this.quizView.classList.toggle('hidden', view !== 'quiz');
        this.statsView.classList.toggle('hidden', view !== 'stats');

        if (view === 'stats') {
            this.renderStats();
            if (this.globalKeywordBank) this.globalKeywordBank.classList.add('hidden');
        } else if (view === 'quiz') {
            // Recalculate bank visibility when switching to quiz
            setTimeout(() => this.activateFirstVisibleBank(), 100);
        }
    }

    loadSet(id) {
        if (id === null) {
            this.currentSetId = null;
            if (this.quizTitle) this.quizTitle.textContent = "ãƒ›ãƒ¼ãƒ  / å¯Œå£«ç™»å±±";
            if (this.homeDashboard) this.homeDashboard.classList.remove('hidden');
            if (this.quizArea) this.quizArea.classList.add('hidden');
            this.updateActiveTOC(null);
            this.updateDashboard();
            if (this.globalKeywordBank) {
                this.globalKeywordBank.classList.add('hidden');
                this.globalKeywordBank.classList.remove('active-bank');
            }
            this.switchView('quiz');
            return;
        }

        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === id);
        if (!set || set.type === 'folder') return;

        if (this.homeDashboard) this.homeDashboard.classList.add('hidden');
        if (this.quizArea) this.quizArea.classList.remove('hidden');

        this.currentSetId = id;
        this.quizTitle.textContent = set.title;
        this.updateTitleEditability();

        this.resetQuiz();
        this.renderTable();
        this.updateActiveTOC(id);
        this.updateDashboard();
        this.switchView('quiz'); // Ensure tab active state updates
    }

    updateActiveTOC(id) {
        const tocLinks = this.tocList.querySelectorAll('a');
        tocLinks.forEach(a => {
            const isActive = !this.isAutoGenerated && a.getAttribute('href') === `#${id}`;
            a.classList.toggle('active', isActive);
        });
    }

    updateTitleEditability() {
        this.quizTitle.contentEditable = this.isEditMode && !this.isAutoGenerated;
    }

    navigateToQuestion(pageId) {
        if (!pageId) return;
        this.isAutoGenerated = false;
        this.currentSetId = pageId;
        this.switchView('quiz');
        this.loadSet(pageId);
    }

    resetQuiz() {
        this.userAnswers = {};
        this.isChecked = false;
        if (this.peekAnswersBtn) {
            this.peekAnswersBtn.innerHTML = 'ğŸ‘ï¸ ç­”ãˆã‚’è¡¨ç¤ºã™ã‚‹';
            this.peekAnswersBtn.classList.remove('active');
        }
        if (this.quizView) this.quizView.classList.remove('answers-revealed');
        this.shuffledCache = {};
        this.selectedKeyword = null; // Reset selected keyword
        this.scoreDisplay.textContent = "æ­£è§£æ•°: 0 / 0";
        this.renderTable();
    }

    resetWrongAnswers() {
        if (!this.isChecked) {
            alert('ç­”ãˆåˆã‚ã›ã‚’ã—ãŸå¾Œã«ä½¿ç”¨ã§ãã¾ã™ã€‚');
            return;
        }

        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === this.currentSetId);
        if (!set) return;

        if (set.type === 'clause') {
            const keywordData = [];
            const parts = set.text.split(/(\[\[.*?\]\]|\(\(.*?\)\))/g);
            parts.forEach(part => {
                if (part.startsWith('[[') && part.endsWith(']]')) {
                    keywordData.push({ text: part.substring(2, part.length - 2), type: 'drag' });
                } else if (part.startsWith('((') && part.endsWith('))')) {
                    keywordData.push({ text: part.substring(2, part.length - 2), type: 'input' });
                }
            });

            keywordData.forEach((kwInfo, idx) => {
                const key = `${set.id}-${idx}`;
                const userAnswer = (this.userAnswers[key] || "").toString();
                const isCorrect = kwInfo.type === 'drag'
                    ? userAnswer === kwInfo.text
                    : this.normalizeInput(userAnswer) === this.normalizeInput(kwInfo.text);

                if (!isCorrect) {
                    delete this.userAnswers[key];
                }
            });
        } else {
            set.questions.forEach((q) => {
                if (q.type === 'clause' || /\[\[|ï¼»ï¼»|\(\(|ï¼ˆï¼ˆ/.test(q.text)) {
                    const keywordData = [];
                    const parts = q.text.split(/(\[\[.*?\]\]|ï¼»ï¼».*?ï¼½ï¼½|\(\(.*?\)\)|ï¼ˆï¼ˆ.*?ï¼‰ï¼‰)/g);
                    parts.forEach(part => {
                        if ((part.startsWith('[[') && part.endsWith(']]')) || (part.startsWith('ï¼»ï¼»') && part.endsWith('ï¼½ï¼½'))) {
                            keywordData.push({ text: part.substring(2, part.length - 2), type: 'drag' });
                        } else if ((part.startsWith('((') && part.endsWith('))')) || (part.startsWith('ï¼ˆï¼ˆ') && part.endsWith('ï¼‰ï¼‰'))) {
                            keywordData.push({ text: part.substring(2, part.length - 2), type: 'input' });
                        }
                    });

                    keywordData.forEach((kwInfo, idx) => {
                        const key = `${q.id}-${idx}`;
                        const val = (this.userAnswers[key] || "").toString();
                        if (val) {
                            const isCorrect = kwInfo.type === 'drag'
                                ? val === kwInfo.text
                                : this.normalizeInput(val) === this.normalizeInput(kwInfo.text);
                            if (!isCorrect) delete this.userAnswers[key];
                        }
                    });
                } else {
                    const userAnswer = this.userAnswers[q.id];
                    const isQMulti = this.isAutoGenerated ? q.isMultiSelect : set.isMultiSelect;
                    let isAllCorrect = false;
                    if (isQMulti) {
                        const correctSet = new Set(q.answer);
                        const userSet = new Set(userAnswer || []);
                        isAllCorrect = (correctSet.size === userSet.size && [...correctSet].every(item => userSet.has(item)));
                    } else {
                        isAllCorrect = userAnswer === q.answer;
                    }
                    if (!isAllCorrect) delete this.userAnswers[q.id];
                }
            });
        }

        this.isChecked = false; // Return to answering mode
        this.renderTable();
    }

    batchCheckAnswers() {
        if (this.isChecked) return;
        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === this.currentSetId);
        let correctCount = 0; let answeredCount = 0;

        if (set.type === 'clause') {
            const keywordData = [];
            // Match both [[...]] and ((...)) in order
            const parts = set.text.split(/(\[\[.*?\]\]|\(\(.*?\)\))/g);
            parts.forEach(part => {
                if (part.startsWith('[[') && part.endsWith(']]')) {
                    keywordData.push({ text: part.substring(2, part.length - 2), type: 'drag' });
                } else if (part.startsWith('((') && part.endsWith('))')) {
                    keywordData.push({ text: part.substring(2, part.length - 2), type: 'input' });
                }
            });

            let allBlanksCorrect = true;
            keywordData.forEach((kwInfo, idx) => {
                const userAnswer = (this.userAnswers[`${set.id}-${idx}`] || "").toString();
                if (!userAnswer && kwInfo.type === 'drag') {
                    allBlanksCorrect = false;
                    return;
                }
                answeredCount++;

                const isCorrect = kwInfo.type === 'drag'
                    ? userAnswer === kwInfo.text
                    : this.normalizeInput(userAnswer) === this.normalizeInput(kwInfo.text);

                if (isCorrect) correctCount++;
                else allBlanksCorrect = false;

                // Detailed stat per blank
                const statKey = `clause-${set.id}-${idx}`;
                if (!this.questionStats[statKey]) {
                    this.questionStats[statKey] = {
                        correct: 0, total: 0, recent: [],
                        page: set.title, pageId: set.id,
                        text: `ç©´åŸ‹ã‚: ${kwInfo.text}`
                    };
                }
                const stat = this.questionStats[statKey];
                stat.total++;
                if (isCorrect) stat.correct++;
                if (!stat.recent) stat.recent = [];
                stat.recent.push(isCorrect ? 1 : 0);
                if (stat.recent.length > 5) stat.recent.shift();
                stat.text = `ç©´åŸ‹ã‚: ${kwInfo.text}`; stat.page = set.title;
                this.updateSRS(stat, isCorrect);
            });


            // Summary stat for the whole clause
            const summaryKey = `clause-summary-${set.id}`;
            if (!this.questionStats[summaryKey]) {
                this.questionStats[summaryKey] = {
                    correct: 0, total: 0, recent: [],
                    page: set.title, pageId: set.id,
                    text: `æ¡æ–‡å…¨ä½“: ${set.title}`
                };
            }
            const summaryStat = this.questionStats[summaryKey];
            summaryStat.total++;
            if (allBlanksCorrect) summaryStat.correct++;
            if (!summaryStat.recent) summaryStat.recent = [];
            summaryStat.recent.push(allBlanksCorrect ? 1 : 0);
            if (summaryStat.recent.length > 5) summaryStat.recent.shift();
            summaryStat.text = `æ¡æ–‡å…¨ä½“: ${set.title}`; summaryStat.page = set.title;
            this.updateSRS(summaryStat, allBlanksCorrect);
        } else {
            set.questions.forEach((q) => {
                let isCorrect = false;
                const userAnswer = this.userAnswers[q.id];

                // Treat any question with [[...]] or ((...)) as a clause/blank type
                if (q.type === 'clause' || /\[\[|ï¼»ï¼»|\(\(|ï¼ˆï¼ˆ/.test(q.text)) {
                    // For clause type in special quiz, count individual blanks
                    const keywordData = [];
                    const parts = q.text.split(/(\[\[.*?\]\]|ï¼»ï¼».*?ï¼½ï¼½|\(\(.*?\)\)|ï¼ˆï¼ˆ.*?ï¼‰ï¼‰)/g);
                    parts.forEach(part => {
                        if ((part.startsWith('[[') && part.endsWith(']]')) || (part.startsWith('ï¼»ï¼»') && part.endsWith('ï¼½ï¼½'))) {
                            keywordData.push({ text: part.substring(2, part.length - 2), type: 'drag' });
                        } else if ((part.startsWith('((') && part.endsWith('))')) || (part.startsWith('ï¼ˆï¼ˆ') && part.endsWith('ï¼‰ï¼‰'))) {
                            keywordData.push({ text: part.substring(2, part.length - 2), type: 'input' });
                        }
                    });

                    let rowCorrectBlanks = 0;
                    let rowAnsweredBlanks = 0;
                    keywordData.forEach((kwInfo, idx) => {
                        const val = this.userAnswers[`${q.id}-${idx}`];
                        if (val) {
                            rowAnsweredBlanks++;
                            const isKwCorrect = kwInfo.type === 'drag'
                                ? val === kwInfo.text
                                : this.normalizeInput(val) === this.normalizeInput(kwInfo.text);
                            if (isKwCorrect) rowCorrectBlanks++;
                        }
                    });

                    answeredCount += rowAnsweredBlanks;
                    correctCount += rowCorrectBlanks;
                    // For the overall row status/stat, consider it correct only if all blanks are correct
                    isCorrect = (keywordData.length > 0 && rowAnsweredBlanks === keywordData.length && rowCorrectBlanks === keywordData.length);
                } else {
                    if (!userAnswer || (Array.isArray(userAnswer) && userAnswer.length === 0)) return;
                    answeredCount++;

                    const isMulti = this.isAutoGenerated ? q.isMultiSelect : set.isMultiSelect;
                    if (isMulti) {
                        const correctSet = new Set(q.answer);
                        const userSet = new Set(userAnswer);
                        isCorrect = (correctSet.size === userSet.size && [...correctSet].every(item => userSet.has(item)));
                    } else {
                        isCorrect = userAnswer === q.answer;
                    }
                    if (isCorrect) correctCount++;
                }

                const statKey = q.type === 'clause' ? `clause-summary-${q.id}` : q.id;
                if (!this.questionStats[statKey]) {
                    this.questionStats[statKey] = {
                        correct: 0, total: 0, recent: [],
                        page: q.origPage || set.title,
                        pageId: q.pageId || set.id,
                        text: q.type === 'clause' ? `æ¡æ–‡å…¨ä½“: ${q.title || set.title}` : q.text
                    };
                }
                const stat = this.questionStats[statKey];
                stat.total++;
                if (isCorrect) stat.correct++;
                if (!stat.recent) stat.recent = [];
                stat.recent.push(isCorrect ? 1 : 0);
                if (stat.recent.length > 5) stat.recent.shift();
                stat.text = q.type === 'clause' ? `æ¡æ–‡å…¨ä½“: ${q.origPage}` : q.text;
                stat.page = q.origPage || set.title;
                this.updateSRS(stat, isCorrect);
            });
        }

        this.isChecked = true;

        // Calculate total items correctly: sum of questions (standard) + sum of blanks (clause)
        let totalItems = 0;
        if (set.type === 'clause') {
            totalItems = (set.text.match(/\[\[/g) || []).length;
        } else {
            set.questions.forEach(q => {
                if (q.type === 'clause') {
                    totalItems += (q.text.match(/\[\[/g) || []).length;
                } else {
                    totalItems++;
                }
            });
        }

        this.scoreDisplay.textContent = `æ­£è§£æ•°: ${correctCount} / ${answeredCount} (åˆè¨ˆ: ${totalItems})`;
        this.history.unshift({
            timestamp: new Date().toLocaleString(),
            isoDate: new Date().toISOString(),
            page: set.title,
            pageId: set.id,
            score: `${correctCount} / ${answeredCount}`,
            accuracy: answeredCount > 0 ? Math.round((correctCount / answeredCount) * 100) : 0
        });
        if (this.history.length > 50) this.history.pop();
        this.saveHistory(); this.saveQuestionStats(); this.renderTable();
        this.updateDashboard();
    }

    renderStats() {
        if (this.history.length === 0) {
            this.totalAccuracy.textContent = "0%"; this.totalAnsweredDisplay.textContent = "0";
            this.historyBody.innerHTML = '<tr><td colspan="4">å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</td></tr>';
            this.weakQuestionsBody.innerHTML = '<tr><td colspan="4">ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</td></tr>';
            return;
        }

        // å…¨ä½“ã®æ­£ç­”ç‡ã¨ç·è§£ç­”æ•°ã‚’ã€å±¥æ­´ï¼ˆä¸Šé™50ä»¶ï¼‰ã§ã¯ãªãå„å•é¡Œã®çµ±è¨ˆã‹ã‚‰ç®—å‡ºã™ã‚‹ã‚ˆã†ã«å¤‰æ›´
        const allStatsValues = Object.values(this.questionStats);
        const totalCorrect = allStatsValues.reduce((sum, s) => sum + (s.correct || 0), 0);
        const totalTotal = allStatsValues.reduce((sum, s) => sum + (s.total || 0), 0);
        const avg = totalTotal > 0 ? Math.round((totalCorrect / totalTotal) * 100) : 0;

        this.totalAccuracy.textContent = `${avg}%`;
        this.totalAnsweredDisplay.textContent = totalTotal;
        this.updateDashboard();

        this.historyBody.innerHTML = this.history.map(h => `<tr><td>${h.timestamp}</td><td><span class="question-link" onclick="app.navigateToQuestion('${h.pageId}')">${h.page}</span></td><td>${h.score}</td><td>${h.accuracy}%</td></tr>`).join('');

        const statsArray = Object.entries(this.questionStats).map(([id, s]) => {
            const recent = s.recent || [];
            const rTotal = recent.length;
            const rCorrect = recent.reduce((a, b) => a + b, 0);
            const accuracy = rTotal > 0 ? Math.round((rCorrect / rTotal) * 100) : 0;

            // Get pageId (fallback for old data)
            let pageId = s.pageId;
            if (!pageId) {
                if (id.startsWith('clause-summary-')) pageId = id.replace('clause-summary-', '');
                else if (id.startsWith('clause-')) {
                    const parts = id.split('-');
                    if (parts.length >= 3) pageId = parts[1];
                } else {
                    const foundSet = this.quizData.find(st => st.questions && st.questions.some(q => q.id === id));
                    if (foundSet) pageId = foundSet.id;
                }
            }

            return { ...s, id, pageId, accuracy, rTotal, rCorrect };
        }).filter(s => s.total > 0).sort((a, b) => {
            if (a.accuracy !== b.accuracy) return a.accuracy - b.accuracy;
            return a.total - b.total;
        }).slice(0, 10);

        this.weakQuestionsBody.innerHTML = statsArray.map(s => {
            const nextRev = s.nextReview ? new Date(s.nextReview) : null;
            const isDue = nextRev && nextRev <= new Date();
            const srsStatus = nextRev
                ? `<span class="srs-badge level-${s.srsLevel} ${isDue ? 'due' : ''}">${s.srsLevel} (${nextRev.toLocaleDateString()})</span>`
                : '<span class="srs-badge level-0">æ–°è¦</span>';

            return `<tr>
                <td style="text-align: left;">
                    <span class="question-link" onclick="app.navigateToQuestion('${s.pageId}')">${s.text}</span> 
                    <span class="history-icon-btn" onclick="app.showSRSDetail('${s.id}')" title="è¨˜æ†¶å®šç€ã®æ¨ç§»ã‚’è¦‹ã‚‹">ğŸ“ˆ</span>
                </td>
                <td>${s.page}</td>
                <td>${s.total}</td>
                <td style="color: ${s.accuracy < 50 ? 'var(--error)' : 'var(--text-primary)'}">${s.accuracy}%</td>
                <td>${srsStatus}</td>
            </tr>`;
        }).join('');
        this.updateChartTabs(); this.renderChart();
        this.renderUnderstandingMap();
    }

    updateChartTabs() { Object.keys(this.chartBtns).forEach(mode => { this.chartBtns[mode].classList.toggle('active', this.chartMode === mode); }); }

    renderUnderstandingMap() {
        if (!this.understandingMap) return;
        this.understandingMap.innerHTML = '';

        const allQuestions = [];
        this.quizData.forEach(set => {
            if (set.type === 'page' && set.questions) {
                set.questions.forEach(q => {
                    const stat = this.questionStats[q.id] || { correct: 0, total: 0, recent: [] };
                    const recent = stat.recent || [];
                    const rTotal = recent.length;
                    const rCorrect = recent.reduce((a, b) => a + b, 0);
                    const accuracy = recent.length > 0 ? Math.round((recent.reduce((a, b) => a + b, 0) / recent.length) * 100) : -1;
                    const nextReview = stat.nextReview ? new Date(stat.nextReview).toLocaleDateString() : 'æœªå®š';

                    allQuestions.push({
                        id: q.id,
                        type: 'page',
                        text: q.text,
                        page: set.title,
                        accuracy: accuracy,
                        total: stat.total,
                        srsLevel: stat.srsLevel || 0,
                        nextReview: nextReview,
                        pageId: set.id
                    });
                });
            } else if (set.type === 'clause' && set.text) {
                const statKey = `clause-summary-${set.id}`;
                const stat = this.questionStats[statKey] || { correct: 0, total: 0, recent: [] };
                const recent = stat.recent || [];
                const accuracy = recent.length > 0 ? Math.round((recent.reduce((a, b) => a + b, 0) / recent.length) * 100) : -1;
                const nextReview = stat.nextReview ? new Date(stat.nextReview).toLocaleDateString() : 'æœªå®š';

                allQuestions.push({
                    id: set.id,
                    type: 'clause',
                    text: `æ¡æ–‡æš—è¨˜: ${set.title}`,
                    page: set.title,
                    accuracy: accuracy,
                    total: stat.total,
                    srsLevel: stat.srsLevel || 0,
                    nextReview: nextReview,
                    pageId: set.id
                });

            }
        });

        allQuestions.forEach(q => {
            const cell = document.createElement('div');
            cell.className = 'map-cell';

            let bgColor = 'rgba(255, 255, 255, 0.1)'; // æœªå­¦ç¿’
            if (q.accuracy !== -1) {
                // Determine 10% step (0, 10, 20... 100)
                const step = Math.floor(q.accuracy / 10) * 10;
                // Map 0-100 to HSL hue 0-120 (Red to Green)
                const hue = (step * 1.2);
                bgColor = `hsl(${hue}, 70%, 50%)`;
            }

            cell.style.backgroundColor = bgColor;
            cell.setAttribute('data-tooltip', `ã€${q.page}ã€‘\n${q.text}\næ­£ç­”ç‡: ${q.accuracy === -1 ? 'æœªè§£ç­”' : q.accuracy + '%'}\nç¿’ç†Ÿåº¦: Lv.${q.srsLevel} / æ¬¡å›äºˆå®š: ${q.nextReview}`);

            cell.onclick = () => {
                if (q.pageId) {
                    this.switchView('quiz');
                    this.loadSet(q.pageId);
                    if (q.type === 'page') {
                        setTimeout(() => {
                            const row = document.getElementById(`row-${q.id}`);
                            if (row) row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }, 100);
                    }
                }
            };

            this.understandingMap.appendChild(cell);
        });
    }

    renderClauseView(set) {
        this.clauseEditor.classList.remove('hidden'); // Ensure it's not logically blocked
        this.clauseEditor.classList.toggle('hidden-quiz', !this.isEditMode);
        this.clauseDisplay.classList.remove('hidden');
        this.tableWrapper.classList.add('hidden');
        this.columnControls.classList.add('hidden');
        this.tableControls.classList.add('hidden');

        if (this.clauseDisplay) {
            this.clauseDisplay.innerHTML = '';
            this.clauseDisplay.classList.remove('hidden');
        }

        if (this.isEditMode) {
            // Only set value if not focused to avoid cursor jumping
            if (this.clauseTextEditor && document.activeElement !== this.clauseTextEditor) {
                this.clauseTextEditor.value = set.text || '';
            }
            if (this.clauseDummiesEditor && document.activeElement !== this.clauseDummiesEditor) {
                this.clauseDummiesEditor.value = (set.dummies || []).join(', ');
            }

            this.clauseTextEditor.oninput = () => {
                set.text = this.clauseTextEditor.value;
                this.saveData();
                this.renderClauseView(set);
            };
            this.clauseDummiesEditor.oninput = () => {
                set.dummies = this.clauseDummiesEditor.value.split(/[ï¼Œ,]/).map(s => s.trim()).filter(s => s);
                this.saveData();
                this.renderClauseView(set);
            };
        }

        const container = document.createElement('div');
        container.className = 'clause-container';

        // Add history graph button if stats exist
        const summaryKey = `clause-summary-${set.id}`;
        if (this.questionStats[summaryKey] && !this.isEditMode) {
            const historyBtn = document.createElement('button');
            historyBtn.className = 'clause-history-btn';
            historyBtn.innerHTML = 'ğŸ“ˆ æ­£ç­”ç‡ã®æ¨ç§»ã‚’ç¢ºèª';
            historyBtn.onclick = () => this.showSRSDetail(summaryKey);
            container.appendChild(historyBtn);
        }

        const clauseText = document.createElement('div');
        clauseText.className = 'clause-text';

        // Render clause content (with table support)
        const rawText = set.text || '(æ¡æ–‡ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“)';
        const lines = rawText.split('\n');
        const hasTable = lines.some(l => l.trim().startsWith('|'));

        let htmlContent = '';
        if (hasTable) {
            let processedHtml = '';
            let tableLines = [];

            lines.forEach(line => {
                if (line.trim().startsWith('|')) {
                    tableLines.push(line);
                } else {
                    if (tableLines.length > 0) {
                        processedHtml += this.renderTableFromMarkdown(tableLines);
                        tableLines = [];
                    }
                    processedHtml += line + '<br>';
                }
            });
            if (tableLines.length > 0) {
                processedHtml += this.renderTableFromMarkdown(tableLines);
            }
            htmlContent = processedHtml;
        } else {
            htmlContent = rawText.replace(/\n/g, '<br>');
        }
        const keywords = [];
        let blankIndex = 0;

        // Use placeholder strategy for blanks
        const finalHtml = htmlContent.replace(/\[\[(.*?)\]\]|ï¼»ï¼»(.*?)ï¼½ï¼½|\(\((.*?)\)\)|ï¼ˆï¼ˆ(.*?)ï¼‰ï¼‰/g, (match, p1, p2, p3, p4) => {
            const keyword = p1 || p2 || p3 || p4;
            const type = (p1 || p2) ? 'drag' : 'input';
            keywords.push({ text: keyword, type: type });
            return `<span id="placeholder-${set.id.replace(/[^a-zA-Z0-9]/g, '-')}-${blankIndex++}"></span>`;
        });

        clauseText.innerHTML = finalHtml;

        // Replace placeholders with real interactive blanks
        for (let i = 0; i < blankIndex; i++) {
            const placeholder = clauseText.querySelector(`#placeholder-${set.id.replace(/[^a-zA-Z0-9]/g, '-')}-${i}`);
            if (!placeholder) continue;

            const kwInfo = keywords[i];
            const currentIdx = i;

            if (kwInfo.type === 'drag') {
                const blank = document.createElement('div');
                blank.className = 'clause-blank';
                blank.id = `blank-${currentIdx}`;

                const savedAnswer = this.userAnswers[`${set.id}-${currentIdx}`];
                blank.dataset.answer = kwInfo.text; // Store correct answer for peek
                if (savedAnswer) {
                    blank.textContent = savedAnswer;
                    blank.classList.add('filled');
                } else {
                    blank.innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';
                }

                if (!this.isChecked) {
                    blank.ondragover = (e) => { e.preventDefault(); blank.classList.add('drag-over'); };
                    blank.ondragleave = () => blank.classList.remove('drag-over');
                    blank.ondrop = (e) => {
                        e.preventDefault();
                        blank.classList.remove('drag-over');
                        const text = e.dataTransfer.getData('text/plain');
                        if (text) {
                            this.userAnswers[`${set.id}-${currentIdx}`] = text;
                            // Auto-fill other blanks with same correct answer
                            keywords.forEach((otherKw, j) => {
                                if (otherKw.text === kwInfo.text) this.userAnswers[`${set.id}-${j}`] = text;
                            });
                            this.renderClauseView(set);
                        }
                    };
                    blank.onclick = () => {
                        if (this.selectedKeyword) {
                            // Click-to-Fill logic
                            const val = this.selectedKeyword;
                            this.userAnswers[`${set.id}-${currentIdx}`] = val;
                            // Auto-fill other blanks with same correct answer
                            keywords.forEach((otherKw, j) => {
                                if (otherKw.text === kwInfo.text) this.userAnswers[`${set.id}-${j}`] = val;
                            });
                            this.selectedKeyword = null;
                            this.renderClauseView(set);
                        } else if (this.userAnswers[`${set.id}-${currentIdx}`]) {
                            const val = this.userAnswers[`${set.id}-${currentIdx}`];
                            delete this.userAnswers[`${set.id}-${currentIdx}`];
                            // Sync removal
                            keywords.forEach((otherKw, j) => {
                                if (otherKw.text === kwInfo.text && this.userAnswers[`${set.id}-${j}`] === val) {
                                    delete this.userAnswers[`${set.id}-${j}`];
                                }
                            });
                            this.renderClauseView(set);
                        }
                    };
                } else {
                    const isCorrect = savedAnswer === kwInfo.text;
                    blank.classList.add(isCorrect ? 'correct' : 'wrong');
                    if (!isCorrect) {
                        const reveal = document.createElement('span');
                        reveal.className = 'reveal-correct';
                        reveal.textContent = ` (${kwInfo.text})`;
                        blank.appendChild(reveal);
                    }
                }
                const peek = document.createElement('span');
                peek.className = 'peek-answer';
                peek.textContent = `(${kwInfo.text})`;
                placeholder.replaceWith(blank, peek);
            } else {
                // Input type
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'clause-input-blank';
                input.id = `input-${currentIdx}`;

                const savedAnswer = this.userAnswers[`${set.id}-${currentIdx}`] || '';
                input.value = savedAnswer;

                const peek = document.createElement('span');
                peek.className = 'peek-answer';
                peek.textContent = `(${kwInfo.text})`;

                if (!this.isChecked) {
                    input.oninput = () => {
                        this.userAnswers[`${set.id}-${currentIdx}`] = input.value;
                    };
                } else {
                    input.disabled = true;
                    const isCorrect = this.normalizeInput(savedAnswer) === this.normalizeInput(kwInfo.text);
                    input.classList.add(isCorrect ? 'correct' : 'wrong');
                    if (!isCorrect) {
                        const tip = document.createElement('span');
                        tip.className = 'reveal-correct';
                        tip.textContent = ` (${kwInfo.text})`;
                        placeholder.parentNode.insertBefore(tip, placeholder.nextSibling);
                    }
                }
                placeholder.replaceWith(input, peek);
            }
        }

        container.appendChild(clauseText);
        this.clauseDisplay.appendChild(container);

        // Keyword Bank - Link to Global Bank in single view
        if (!this.isChecked && !this.isEditMode) {
            const dragKeywords = keywords.filter(kw => kw.type === 'drag');
            const dragTexts = dragKeywords.map(kw => kw.text);
            const allOptions = [...new Set([...dragTexts, ...(set.dummies || [])])];

            if (allOptions.length > 0) {
                this.updateGlobalKeywordBank({
                    id: `cl-${set.id}`,
                    dataset: {
                        qid: set.id,
                        keywords: JSON.stringify(allOptions),
                        requiredCounts: JSON.stringify(dragTexts.reduce((acc, t) => { acc[t] = (acc[t] || 0) + 1; return acc; }, {}))
                    }
                });
            }
        }
    }

    updateDashboard() {
        // Overall Mastery (Mt. Fuji)
        // Weighted Progress: sum of levels (capped at 8) / (total * 8)
        const allStats = Object.values(this.questionStats);

        // Better total questions calculation (flatten all)
        const getFlatTotal = (list) => {
            let count = 0;
            list.forEach(item => {
                if (item.type === 'clause') count++;
                else if (item.questions) count += item.questions.length;
                if (item.children) count += getFlatTotal(item.children);
            });
            return count;
        };
        const realTotalQuestions = getFlatTotal(this.quizData);

        const sumOfLevels = allStats.reduce((acc, s) => acc + Math.min(8, (s.srsLevel || 0)), 0);
        const maxPossibleLevels = (realTotalQuestions || 1) * 8;
        const masteryPercent = Math.min(100, Math.round((sumOfLevels / maxPossibleLevels) * 100 * 10) / 10);

        // Map 0-100% to 0-3776m
        const heightMeters = Math.round(masteryPercent * 37.76);

        // SRS Due Today calculation (Consolidated: only count summaries or independent questions)
        const now = new Date();
        const dueCount = Object.entries(this.questionStats).filter(([key, s]) => {
            if (!s.nextReview) return false;
            // Ignore individual blanks (clause-ID-index) to avoid overcounting
            if (key.startsWith('clause-') && !key.startsWith('clause-summary-')) return false;
            return new Date(s.nextReview) <= now;
        }).length;

        // Update UI
        const masteryEl = document.getElementById('mastery-percent');
        const heightEl = document.getElementById('climb-height');
        const dueCountEl = document.getElementById('srs-due-count');
        const hikerMarker = document.getElementById('hiker-marker');
        const fujiSvg = document.querySelector('.fuji-svg');

        if (masteryEl) masteryEl.textContent = `${masteryPercent}%`;
        if (heightEl) heightEl.textContent = `${heightMeters} m`;
        if (dueCountEl) {
            dueCountEl.textContent = dueCount;
            const card = dueCountEl.closest('.main-stat-card');
            if (card) card.classList.toggle('due-active', dueCount > 0);
        }

        if (hikerMarker) {
            // Mt Fuji path logic in SVG: Base (20, 110) to Summit (100, 20)
            const startX = 20; const startY = 110;
            const endX = 100; const endY = 20;
            const currentX = startX + (endX - startX) * (masteryPercent / 100);
            const currentY = startY + (endY - startY) * (masteryPercent / 100);

            // Trigger Walking Animation
            hikerMarker.classList.add('walking');
            hikerMarker.style.setProperty('--hiker-x', `${currentX}px`);
            hikerMarker.style.setProperty('--hiker-y', `${currentY}px`);
            hikerMarker.setAttribute('transform', `translate(${currentX}, ${currentY})`);

            setTimeout(() => hikerMarker.classList.remove('walking'), 2000);
        }

        // Daily Progress
        const nowTime = new Date();
        nowTime.setHours(0, 0, 0, 0);
        const todayAnswers = this.history.filter(h => {
            const hDate = h.isoDate ? new Date(h.isoDate) : new Date(h.timestamp);
            hDate.setHours(0, 0, 0, 0);
            return hDate.getTime() === nowTime.getTime();
        }).reduce((acc, h) => {
            const scoreParts = h.score.split(' / ');
            // Number of questions answered is in the second part of "Correct / Answered"
            return acc + (parseInt(scoreParts[1]) || 0);
        }, 0);

        const dailyCountEl = document.getElementById('daily-count');
        const dailyBarFill = document.getElementById('daily-bar-fill');

        if (dailyCountEl) dailyCountEl.textContent = `${todayAnswers} / ${this.dailyGoal}`;
        if (dailyBarFill) {
            const dailyPercent = Math.min(100, (todayAnswers / this.dailyGoal) * 100);
            dailyBarFill.style.width = `${dailyPercent}%`;

            // Celebration color for daily goal
            if (dailyPercent >= 100) {
                dailyBarFill.style.background = 'linear-gradient(90deg, #ff9e00, #ff5400)';
                if (fujiSvg) {
                    const sky = fujiSvg.querySelector('#skyGradient stop:last-child');
                    if (sky) sky.style.stopColor = '#4338ca'; // Deepen the sky
                }
            } else {
                dailyBarFill.style.background = 'linear-gradient(90deg, #4cc9f0, #4361ee)';
            }
        }

        // Show/Hide Review Buttons based on content
        const dueItems = this.getDueQuestions();
        const hasClauses = dueItems.some(i => i.type === 'clause');
        const hasPages = dueItems.some(i => i.type === 'page');

        if (this.startClauseOneReviewBtn) this.startClauseOneReviewBtn.classList.toggle('hidden', !hasClauses);
        if (this.startClauseReviewBtn) this.startClauseReviewBtn.classList.toggle('hidden', !hasClauses);
        if (this.startPageReviewBtn) this.startPageReviewBtn.classList.toggle('hidden', !hasPages);
    }

    getDueQuestions() {
        const now = new Date();
        const due = [];
        // Helper to find question in quizData
        const findQuestion = (qId) => {
            const isClauseSummary = qId.startsWith('clause-summary-');
            const searchId = isClauseSummary ? qId.replace('clause-summary-', '') : qId;

            for (const set of this.quizData) {
                if (set.type === 'clause' && set.id === searchId) return { set, q: set };
                if (set.questions) {
                    const q = set.questions.find(item => item.id === qId);
                    if (q) return { set, q };
                }
            }
            return null;
        };

        Object.entries(this.questionStats).forEach(([id, stat]) => {
            // Ignore individual blanks for due list (Summaries only)
            if (id.startsWith('clause-') && !id.startsWith('clause-summary-')) return;

            if (stat.nextReview && new Date(stat.nextReview) <= now) {
                const found = findQuestion(id);
                if (found) {
                    due.push({
                        id,
                        type: found.set.type === 'clause' ? 'clause' : 'page',
                        text: found.q.text || found.set.title,
                        setName: found.set.title,
                        fullSet: found.set,
                        qObj: found.q
                    });
                }
            }
        });
        return due;
    }

    toggleDueList() {
        if (!this.dueListContainer) return;
        const isHidden = this.dueListContainer.classList.contains('hidden');
        if (!isHidden) {
            this.dueListContainer.classList.add('hidden');
            return;
        }

        const dueItems = this.getDueQuestions();
        if (dueItems.length === 0) {
            alert("ç¾åœ¨ã€å¾©ç¿’å¾…ã¡ã®å•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚");
            return;
        }

        this.dueListBody.innerHTML = dueItems.map(item => `
            <tr>
                <td><span class="badge ${item.type === 'clause' ? 'srs-clause' : 'srs-page'}">${item.type === 'clause' ? 'æ¡æ–‡' : 'é¸æŠ'}</span></td>
                <td><div class="due-text" title="${item.text}">${item.text.substring(0, 50)}${item.text.length > 50 ? '...' : ''}</div><div class="due-source">${item.setName}</div></td>
                <td><button class="secondary-btn mini-btn" onclick="app.navigateToQuestion('${item.fullSet.id}')">ç§»å‹•</button></td>
            </tr>
        `).join('');
        this.dueListContainer.classList.remove('hidden');
    }

    generateDueReview(type, limit) {
        const dueItems = this.getDueQuestions().filter(i => i.type === type);
        if (dueItems.length === 0) return;

        // Shuffle and Slice
        const shuffled = dueItems.sort(() => 0.5 - Math.random());
        const selected = shuffled.slice(0, limit);

        this.isAutoGenerated = true;
        if (type === 'clause') {
            // Support multiple clauses by treating each as a individual "question" row in a page
            // This ensures each clause retains its original ID for SRS tracking.
            const questions = selected.map(item => {
                const q = JSON.parse(JSON.stringify(item.fullSet));
                // Strip prefix if it exists to get the base ID for batchCheckAnswers to use correctly
                q.id = item.id.startsWith('clause-summary-') ? item.id.replace('clause-summary-', '') : item.id;
                q.type = 'clause';
                q.origPage = item.setName;
                return q;
            });

            this.autoGeneratedSet = {
                id: "auto-due-review-clause",
                type: 'page', // Use page type to render questions individually
                title: `ã€å¾©ç¿’ã€‘ç©´åŸ‹ã‚å¼å•é¡Œ (${selected.length}é¡Œ)`,
                columns: ["æ¡æ–‡"],
                questions: questions
            };
        } else {
            this.autoGeneratedSet = {
                id: "auto-due-review",
                title: `ã€å¾©ç¿’ã€‘é¸æŠå¼ ç‰¹è¨“ (${selected.length}é¡Œ)`,
                columns: selected[0].fullSet.columns || ["é …ç›®", "æ­£è§£"],
                questions: selected.map(i => {
                    return {
                        ...JSON.parse(JSON.stringify(i.qObj)),
                        origPage: i.fullSet.title,
                        columns: i.fullSet.columns,
                        isMultiSelect: i.fullSet.isMultiSelect
                    };
                }),
                isMultiSelect: selected.some(i => i.fullSet.isMultiSelect)
            };
        }

        this.loadSet(this.autoGeneratedSet.id);
        if (this.sidebar) this.sidebar.classList.remove('open');
    }

    renderTableFromMarkdown(lines) {
        let tableHtml = '<div class="table-wrapper"><table>';
        lines.forEach((line, idx) => {
            const cells = line.split('|').map(c => c.trim()).filter((c, i, arr) => i > 0 && i < arr.length - 1);
            if (cells.length === 0) return;
            const tag = (idx === 0) ? 'th' : 'td';

            tableHtml += '<tr>';
            cells.forEach(cell => {
                let content = cell.replace(/_br_/g, '<br>');
                let style = '';

                // Parse {width} for headers
                if (idx === 0) {
                    const widthMatch = content.match(/\{(.*?)\}/);
                    if (widthMatch) {
                        style = ` style="width: ${widthMatch[1]}; min-width: ${widthMatch[1]};"`;
                        content = content.replace(widthMatch[0], '');
                    }
                }

                tableHtml += `<${tag}${style}>${content}</${tag}>`;
            });
            tableHtml += '</tr>';
        });
        tableHtml += '</table></div>';
        return tableHtml;
    }

    renderChart() {
        const ctx = document.getElementById('statsChart').getContext('2d');
        if (this.statsChart) this.statsChart.destroy();
        const allStats = Object.values(this.questionStats).filter(s => s.total > 0).map(s => {
            const recent = s.recent || [];
            const rTotal = recent.length;
            const rCorrect = recent.reduce((a, b) => a + b, 0);
            const accuracy = rTotal > 0 ? Math.round((rCorrect / rTotal) * 100) : 0;
            const errors = rTotal - rCorrect;
            return { ...s, accuracy, errors, rTotal, rCorrect };
        });
        let sortedStats, data, label, color;
        if (this.chartMode === 'accuracy') { sortedStats = allStats.sort((a, b) => a.accuracy - b.accuracy).slice(0, 10); data = sortedStats.map(s => s.accuracy); label = 'æ­£ç­”ç‡ (%)'; color = '#4cc9f0'; }
        else if (this.chartMode === 'frequency') { sortedStats = allStats.sort((a, b) => b.total - a.total).slice(0, 10); data = sortedStats.map(s => s.total); label = 'è§£ç­”å›æ•° (å›)'; color = '#f72585'; }
        else { sortedStats = allStats.sort((a, b) => b.errors - a.errors).slice(0, 10); data = sortedStats.map(s => s.errors); label = 'æœ€è¿‘ã®èª¤ç­”å›æ•° (å›/5å›ä¸­)'; color = '#ff9f1c'; }
        const labels = sortedStats.map(s => s.text.length > 8 ? s.text.substring(0, 7) + '...' : s.text);
        this.statsChart = new Chart(ctx, {
            type: 'bar', data: { labels: labels, datasets: [{ label: label, data: data, backgroundColor: color + 'dd', borderColor: color, borderWidth: 1, borderRadius: 8 }] },
            options: { responsive: true, maintainAspectRatio: false, indexAxis: 'y', plugins: { legend: { display: false }, tooltip: { callbacks: { title: (items) => sortedStats[items[0].dataIndex].text, label: (item) => `${label}: ${item.raw}` } } }, scales: { x: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: 'rgba(255,255,255,0.6)' } }, y: { grid: { display: false }, ticks: { color: 'rgba(255,255,255,0.8)', font: { size: 12 } } } } }
        });
    }

    generateSpecialQuiz(type) {
        const allQuestions = [];
        let maxCols = 2;
        let bestCols = ["é …ç›®", "é¸æŠè‚¢"];

        this.quizData.forEach(set => {
            if (!this.isItemSelectedForPool(set.id)) return;

            const isSrs = type.startsWith('srs');
            const targetType = isSrs ? type.split('-')[1] : null; // 'clause' or 'page'

            if (set.type === 'page' && set.questions && type !== 'clause-weak') {
                if (isSrs && targetType !== 'page') return;

                if (set.columns && set.columns.length > maxCols) {
                    maxCols = set.columns.length;
                    bestCols = [...set.columns];
                }
                set.questions.forEach(q => {
                    if (q.isInPool === false) return;
                    const stat = this.questionStats[q.id] || { correct: 0, total: 0, recent: [] };
                    const recent = stat.recent || [];
                    const accuracy = recent.length > 0 ? (recent.reduce((a, b) => a + b, 0) / recent.length) : -1;

                    allQuestions.push({
                        id: q.id,
                        type: 'page',
                        text: q.text,
                        answer: q.answer,
                        memo: q.memo || '',
                        origPage: set.title,
                        pageId: set.id,
                        columns: set.columns,
                        accuracy: accuracy,
                        total: stat.total,
                        nextReview: stat.nextReview,
                        isMultiSelect: set.isMultiSelect
                    });
                });
            } else if (set.type === 'clause' && set.text) {
                if (type !== 'clause-weak' && !isSrs && type !== 'rare' && type !== 'random') return;
                if (isSrs && targetType !== 'clause') return;

                const statKey = `clause-summary-${set.id}`;
                const stat = this.questionStats[statKey] || { correct: 0, total: 0, recent: [] };
                const recent = stat.recent || [];
                const accuracy = recent.length > 0 ? (recent.reduce((a, b) => a + b, 0) / recent.length) : -1;

                allQuestions.push({
                    id: set.id,
                    type: 'clause',
                    text: set.text,
                    dummies: set.dummies,
                    origPage: set.title,
                    pageId: set.id,
                    accuracy: accuracy,
                    total: stat.total,
                    nextReview: stat.nextReview,
                    isMultiSelect: false
                });
            }
        });

        if (allQuestions.length === 0) {
            alert('ç‰¹è¨“ã®å¯¾è±¡ã¨ãªã‚‹å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’å…¥ã‚Œã¦å¯¾è±¡ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
            return;
        }

        let filtered, title;
        if (type === 'weak') {
            title = "ç‰¹è¨“ï¼šè‹¦æ‰‹ãªå•é¡Œãƒ¯ãƒ¼ã‚¹ãƒˆ10";
            // Get all questions with errors, sort by accuracy
            const candidates = allQuestions.filter(q => q.total > 0).sort((a, b) => a.accuracy - b.accuracy);
            if (candidates.length === 0) {
                alert('ã¾ã é–“é•ãˆãŸè¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã¾ãšã¯æ™®é€šã«å­¦ç¿’ã—ã¦å›ç­”ã‚’è¨˜éŒ²ã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            // Pick from the top 20 worst questions and shuffle for variety
            filtered = candidates.slice(0, 20).sort(() => Math.random() - 0.5).slice(0, 10);
        } else if (type === 'clause-weak') {
            title = "ç‰¹è¨“ï¼šè‹¦æ‰‹ãªæ¡æ–‡ãƒ¯ãƒ¼ã‚¹ãƒˆ3";
            const candidates = allQuestions.filter(q => q.total > 0).sort((a, b) => a.accuracy - b.accuracy);
            if (candidates.length === 0) {
                alert('ã¾ã é–“é•ãˆãŸè¨˜éŒ²ã®ã‚ã‚‹æ¡æ–‡ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã¾ãšã¯å„ãƒšãƒ¼ã‚¸ã‹ã‚‰æ¡æ–‡æš—è¨˜ã«å–ã‚Šçµ„ã‚“ã§ãã ã•ã„ã€‚');
                return;
            }
            // Pick from the top 10 worst clauses and shuffle for variety
            filtered = candidates.slice(0, 10).sort(() => Math.random() - 0.5).slice(0, 3);
        } else if (type.startsWith('srs')) {
            const mode = type.split('-')[1];
            title = mode === 'clause' ? "ç‰¹è¨“ï¼šå¿˜å´æ›²ç·šï¼ˆæ¡æ–‡ç©´åŸ‹ã‚ï¼‰" : "ç‰¹è¨“ï¼šå¿˜å´æ›²ç·šï¼ˆé¸æŠå¼ï¼‰";
            const now = new Date();
            filtered = allQuestions.filter(q => {
                if (!q.nextReview) return true;
                return new Date(q.nextReview) <= now;
            });
            if (filtered.length === 0) {
                alert('ç¾åœ¨ã€å¾©ç¿’ãŒå¿…è¦ãªå•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ç´ æ™´ã‚‰ã—ã„ã§ã™ã­ï¼');
                return;
            }
            // Shuffle and limit
            const limit = mode === 'clause' ? 3 : 15;
            filtered = filtered.sort(() => Math.random() - 0.5).slice(0, limit);
        } else if (type === 'random') {
            title = "ç‰¹è¨“ï¼šå…¨å•é¡Œã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ 10å•";
            filtered = allQuestions.sort(() => Math.random() - 0.5).slice(0, 10);
        } else {
            title = "ç‰¹è¨“ï¼šæœªå­¦ç¿’ãƒ»ä½é »åº¦ãªå•é¡Œ10å•";
            filtered = allQuestions.sort((a, b) => {
                if (a.total !== b.total) return a.total - b.total;
                return a.accuracy - b.accuracy;
            }).slice(0, 10);
        }

        // Recalculate optimal columns - use UNION of all columns to ensure compatibility
        let finalBestCols = ["é …ç›®"];
        const colSet = new Set();
        filtered.forEach(q => {
            if (q.type === 'page' && q.columns) {
                // Skip the first column 'é …ç›®' which we already added
                for (let i = 1; i < q.columns.length; i++) {
                    colSet.add(q.columns[i]);
                }
            }
        });
        if (colSet.size > 0) {
            finalBestCols = ["é …ç›®", ...Array.from(colSet)];
        } else if (filtered.every(q => q.type === 'clause')) {
            finalBestCols = ["æ¡æ–‡å†…å®¹"];
        } else {
            finalBestCols = ["é …ç›®", "é¸æŠè‚¢"];
        }
        bestCols = finalBestCols;

        this.autoGeneratedSet = {
            id: 'temp-autogen',
            title: title,
            questions: filtered,
            columns: bestCols
        };
        this.isAutoGenerated = true;
        this.switchView('quiz');
        this.loadSet('temp-autogen');
    }

    renderTable() {
        this._currentActiveRowId = null; // Force refresh bank on re-render
        if (this.globalKeywordBank) {
            this.globalKeywordBank.innerHTML = '';
            this.globalKeywordBank.classList.add('hidden');
            this.globalKeywordBank.classList.remove('active-bank');
        }
        this.shuffledCache = {}; // Aggressive clear to prevent stale options
        if (!this.currentSetId && !this.isAutoGenerated) return;
        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === this.currentSetId);

        // Hide delete/clone buttons for folders or when no set is selected or in auto-generated mode
        const isFolder = !set || set.type === 'folder' || this.isAutoGenerated;
        if (this.deletePageBtn) this.deletePageBtn.classList.toggle('hidden', isFolder);
        if (this.clonePageBtn) this.clonePageBtn.classList.toggle('hidden', isFolder);

        if (!set || set.type === 'folder') {
            this.tableBody.innerHTML = '';
            this.tableHead.innerHTML = '';
            this.quizTitle.textContent = set ? set.title : 'å•é¡Œã‚’é¸æŠã—ã¦ãã ã•ã„';
            if (this.clauseEditor) this.clauseEditor.classList.add('hidden');
            if (this.clauseDisplay) this.clauseDisplay.classList.add('hidden');
            return;
        }

        const isClause = set.type === 'clause';
        if (this.clauseDisplay) {
            this.clauseDisplay.classList.toggle('hidden', !isClause);
            if (!isClause) this.clauseDisplay.innerHTML = '';
        }
        if (this.clauseEditor) {
            this.clauseEditor.classList.toggle('hidden', !isClause);
            this.clauseEditor.classList.toggle('hidden-quiz', !isClause || !this.isEditMode);
        }
        this.tableWrapper.classList.toggle('hidden', isClause);

        if (isClause) {
            this.renderClauseView(set);
            return;
        } else {
            if (this.columnControls) this.columnControls.classList.toggle('hidden', !this.isEditMode);
            if (this.tableControls) this.tableControls.classList.toggle('hidden', !this.isEditMode);
        }

        this.tableWrapper.innerHTML = '';

        if (this.isAutoGenerated) {
            // Group questions by their original column structure to avoid cross-page noise
            const groups = [];
            set.questions.forEach(q => {
                // Clause types in auto-gen are always their own block
                if (q.type === 'clause') {
                    groups.push({ type: 'clause', questions: [q], columns: ["æ¡æ–‡å†…å®¹"] });
                    return;
                }

                const colKey = q.columns ? q.columns.join('|') : 'default';
                let g = groups.find(it => it.type === 'page' && it.key === colKey);
                if (!g) {
                    g = { type: 'page', key: colKey, questions: [], columns: q.columns || ["é …ç›®", "é¸æŠè‚¢"] };
                    groups.push(g);
                }
                g.questions.push(q);
            });

            groups.forEach(g => {
                // Collect keywords if the columns are generic
                const genericNames = ["é¸æŠè‚¢", "æ­£è§£", "å›ç­”", "ç­”ãˆ"];
                const isGeneric = g.columns.some(col => genericNames.some(name => col.includes(name)));

                if (isGeneric) {
                    const keywords = new Set();
                    g.questions.forEach(q => {
                        if (Array.isArray(q.answer)) q.answer.forEach(a => keywords.add(a));
                        else if (q.answer) keywords.add(q.answer);
                        if (q.dummies) q.dummies.forEach(d => keywords.add(d));
                    });
                    const allKws = Array.from(keywords).sort();
                    g.questions.forEach(q => {
                        q._autoKeywords = allKws;
                        const req = {};
                        if (Array.isArray(q.answer)) q.answer.forEach(a => req[a] = (req[a] || 0) + 1);
                        else if (q.answer) req[q.answer] = (req[q.answer] || 0) + 1;
                        q._autoRequired = req;
                    });
                }

                const table = document.createElement('table');
                table.className = 'quiz-table auto-gen-table';
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');
                table.appendChild(thead);
                table.appendChild(tbody);
                this.tableWrapper.appendChild(table);
                this.renderTableContent(g.columns, g.questions, thead, tbody, true);
            });
            this.quizTitle.textContent = set.title;
        } else {
            const table = document.createElement('table');
            table.id = 'quiz-table';
            const thead = document.createElement('thead'); thead.id = 'table-head';
            const tbody = document.createElement('tbody'); tbody.id = 'table-body';
            table.appendChild(thead);
            table.appendChild(tbody);
            this.tableWrapper.appendChild(table);
            this.tableHead = thead;
            this.tableBody = tbody;
            this.renderTableContent(set.columns, set.questions, thead, tbody, false);
            this.quizTitle.textContent = set.title;
        }

        // Initial activation of global bank
        setTimeout(() => this.activateFirstVisibleBank(), 200);

        // Setup observer for sticky keyword banks as you scroll
        setTimeout(() => this.setupQuestionObserver(), 300);
    }

    renderTableContent(columns, questions, thead, tbody, isAuto) {
        const headTr = document.createElement('tr');
        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === this.currentSetId);

        // Header Rendering
        if (isAuto) {
            columns.forEach(col => {
                const th = document.createElement('th');
                th.textContent = col.replace(/\{.*?\}/, '');
                const widthMatch = col.match(/\{(.*?)\}/);
                if (widthMatch) { th.style.width = widthMatch[1]; th.style.minWidth = widthMatch[1]; }
                headTr.appendChild(th);
            });
        } else {
            if (this.isEditMode) {
                const thPool = document.createElement('th');
                thPool.innerHTML = 'ç‰¹è¨“'; thPool.className = 'pool-cell';
                headTr.appendChild(thPool);
            }
            columns.forEach((col, index) => {
                const th = document.createElement('th');
                let displayLabel = col;
                const widthMatch = col.match(/\{(.*?)\}/);
                if (widthMatch) { th.style.width = widthMatch[1]; th.style.minWidth = widthMatch[1]; displayLabel = col.replace(widthMatch[0], ''); }
                const span = document.createElement('span');
                span.className = 'col-label-edit'; span.textContent = displayLabel;
                if (this.isEditMode) {
                    span.contentEditable = true;
                    span.onblur = () => {
                        const widthMatch = col.match(/\{.*?\}/);
                        const widthSpec = widthMatch ? widthMatch[0] : '';
                        let newVal = span.textContent.trim();
                        if (widthSpec && !newVal.includes('{')) newVal += widthSpec;
                        if (col !== newVal) {
                            const oldDisplay = col.replace(/\{.*?\}/, '').trim();
                            const newDisplay = newVal.replace(/\{.*?\}/, '').trim();
                            columns[index] = newVal;
                            questions.forEach(q => {
                                if (Array.isArray(q.answer)) q.answer = q.answer.map(a => a === oldDisplay ? newDisplay : a);
                                else if (q.answer === oldDisplay) q.answer = newDisplay;
                            });
                            this.saveData(); this.renderTable();
                        }
                    };
                }
                th.appendChild(span);
                if (this.isEditMode && index > 0) {
                    const delBtn = document.createElement('span'); delBtn.className = 'delete-col-btn'; delBtn.innerHTML = 'Ã—';
                    delBtn.onclick = (e) => { e.stopPropagation(); this.deleteColumn(index); };
                    th.appendChild(delBtn);
                }
                headTr.appendChild(th);
            });
        }
        thead.appendChild(headTr);

        // Rows Rendering
        questions.forEach((q) => {
            const tr = document.createElement('tr'); tr.id = `row-${q.id}`;
            const isQMulti = isAuto ? q.isMultiSelect : set.isMultiSelect;

            if (this.isChecked) {
                const userAnswer = this.userAnswers[q.id];
                if (userAnswer && (!Array.isArray(userAnswer) || userAnswer.length > 0)) {
                    let isAllCorrect = false;
                    if (isQMulti) {
                        const correctSet = new Set(q.answer); const userSet = new Set(userAnswer);
                        isAllCorrect = (correctSet.size === userSet.size && [...correctSet].every(item => userSet.has(item)));
                    } else { isAllCorrect = userAnswer === q.answer; }
                    tr.classList.add(isAllCorrect ? 'row-correct' : 'row-wrong');
                }
            }

            // Pool inclusion checkbox cell (REQUIRED FOR ALIGNMENT in edit mode)
            if (!isAuto && this.isEditMode) {
                const tdPool = document.createElement('td');
                tdPool.className = 'pool-cell';
                const poolCheck = document.createElement('input');
                poolCheck.type = 'checkbox';
                poolCheck.checked = q.isInPool !== false;
                poolCheck.onchange = (e) => {
                    q.isInPool = e.target.checked;
                    this.saveData();
                };
                tdPool.appendChild(poolCheck);
                tr.appendChild(tdPool);
            }

            const tdQ = document.createElement('td'); tdQ.className = 'question-cell';

            // Treat any question with [[...]] or ((...)) (including full-width) as a clause/blank type
            if (q.type === 'clause' || /\[\[|ï¼»ï¼»|\(\(|ï¼ˆï¼ˆ/.test(q.text)) {
                const wrapper = document.createElement('div'); wrapper.className = 'table-clause-wrapper';
                const badge = document.createElement('span'); badge.className = 'clause-badge'; badge.textContent = q.origPage || "æ¡æ–‡";
                wrapper.appendChild(badge);

                const cText = document.createElement('div'); cText.className = 'clause-text-mini';
                let htmlContent = q.text;
                const lines = q.text.split('\n');
                const hasTable = lines.some(l => l.trim().startsWith('|'));
                if (hasTable) {
                    let processedHtml = ''; let tableLines = [];
                    lines.forEach(line => {
                        if (line.trim().startsWith('|')) tableLines.push(line);
                        else {
                            if (tableLines.length > 0) { processedHtml += this.renderTableFromMarkdown(tableLines); tableLines = []; }
                            processedHtml += line + '<br>';
                        }
                    });
                    if (tableLines.length > 0) processedHtml += this.renderTableFromMarkdown(tableLines);
                    htmlContent = processedHtml;
                } else { htmlContent = q.text.replace(/\n/g, '<br>'); }

                const rowKeywords = []; let blankIdx = 0;
                // Combined drag/input support (including full-width)
                const finalHtml = htmlContent.replace(/\[\[(.*?)\]\]|ï¼»ï¼»(.*?)ï¼½ï¼½|\(\((.*?)\)\)|ï¼ˆï¼ˆ(.*?)ï¼‰ï¼‰/g, (match, p1, p2, p3, p4) => {
                    const keyword = p1 || p2 || p3 || p4;
                    const type = (p1 || p2) ? 'drag' : 'input';
                    rowKeywords.push({ text: keyword, type: type });
                    return `<span id="placeholder-${q.id}-${blankIdx++}"></span>`;
                });
                cText.innerHTML = finalHtml;

                for (let i = 0; i < blankIdx; i++) {
                    const placeholder = cText.querySelector(`#placeholder-${q.id}-${i}`);
                    if (!placeholder) continue;
                    const kwInfo = rowKeywords[i];
                    const currentBlankIdx = i;

                    if (kwInfo.type === 'drag') {
                        const blank = document.createElement('div'); blank.className = 'clause-blank';
                        const savedAnswer = this.userAnswers[`${q.id}-${currentBlankIdx}`];
                        if (savedAnswer) { blank.textContent = savedAnswer; blank.classList.add('filled'); }
                        else { blank.innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;'; }

                        if (!this.isChecked) {
                            blank.ondragover = (e) => { e.preventDefault(); blank.classList.add('drag-over'); };
                            blank.ondragleave = () => blank.classList.remove('drag-over');
                            blank.ondrop = (e) => {
                                e.preventDefault(); blank.classList.remove('drag-over');
                                const text = e.dataTransfer.getData('text/plain');
                                if (text) {
                                    this.userAnswers[`${q.id}-${currentBlankIdx}`] = text;
                                    // Auto-fill other blanks with same correct answer
                                    rowKeywords.forEach((otherKw, j) => {
                                        if (otherKw.text === kwInfo.text) this.userAnswers[`${q.id}-${j}`] = text;
                                    });
                                    this.renderTable();
                                    const trTarget = blank.closest('tr');
                                    if (trTarget) this.updateGlobalKeywordBank(trTarget);
                                }
                            };
                            blank.onclick = () => {
                                if (this.selectedKeyword) {
                                    // Click-to-Fill logic
                                    const val = this.selectedKeyword;
                                    this.userAnswers[`${q.id}-${currentBlankIdx}`] = val;
                                    // Auto-fill other blanks with same correct answer
                                    rowKeywords.forEach((otherKw, j) => {
                                        if (otherKw.text === kwInfo.text) this.userAnswers[`${q.id}-${j}`] = val;
                                    });
                                    this.selectedKeyword = null;
                                    this.renderTable();
                                } else if (this.userAnswers[`${q.id}-${currentBlankIdx}`]) {
                                    const val = this.userAnswers[`${q.id}-${currentBlankIdx}`];
                                    delete this.userAnswers[`${q.id}-${currentBlankIdx}`];
                                    // Sync removal
                                    rowKeywords.forEach((otherKw, j) => {
                                        if (otherKw.text === kwInfo.text && this.userAnswers[`${q.id}-${j}`] === val) {
                                            delete this.userAnswers[`${q.id}-${j}`];
                                        }
                                    });
                                    this.renderTable();
                                    const trTarget = blank.closest('tr');
                                    if (trTarget) this.updateGlobalKeywordBank(trTarget);
                                }
                            };
                        } else {
                            const isCorrect = savedAnswer === kwInfo.text;
                            blank.classList.add(isCorrect ? 'correct' : 'wrong');
                            if (!isCorrect) {
                                const reveal = document.createElement('span');
                                reveal.className = 'reveal-correct'; reveal.textContent = ` (${kwInfo.text})`;
                                blank.appendChild(reveal);
                            }
                        }
                        const peek = document.createElement('span');
                        peek.className = 'peek-answer';
                        peek.textContent = `(${kwInfo.text})`;
                        placeholder.replaceWith(blank, peek);
                    } else {
                        // Input type
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.className = 'clause-input-blank mini';
                        const savedAnswer = this.userAnswers[`${q.id}-${currentBlankIdx}`] || '';
                        input.value = savedAnswer;

                        const peek = document.createElement('span');
                        peek.className = 'peek-answer';
                        peek.textContent = `(${kwInfo.text})`;

                        if (!this.isChecked) {
                            input.oninput = () => {
                                this.userAnswers[`${q.id}-${currentBlankIdx}`] = input.value;
                            };
                        } else {
                            input.disabled = true;
                            const isCorrect = this.normalizeInput(savedAnswer) === this.normalizeInput(kwInfo.text);
                            input.classList.add(isCorrect ? 'correct' : 'wrong');
                            if (!isCorrect) {
                                const tip = document.createElement('span');
                                tip.className = 'reveal-correct';
                                tip.textContent = ` (${kwInfo.text})`;
                                placeholder.parentNode.insertBefore(tip, placeholder.nextSibling);
                            }
                        }
                        placeholder.replaceWith(input, peek);
                    }
                }
                wrapper.appendChild(cText);
                tdQ.appendChild(wrapper);

                if (!this.isChecked) {
                    const dragKeywords = rowKeywords.filter(kw => kw.type === 'drag').map(kw => kw.text);
                    const allOptions = [...new Set([...dragKeywords, ...(q.dummies || [])])];
                    if (allOptions.length > 0) {
                        tr.dataset.keywords = JSON.stringify(allOptions);
                        tr.dataset.requiredCounts = JSON.stringify(dragKeywords.reduce((acc, text) => { acc[text] = (acc[text] || 0) + 1; return acc; }, {}));
                        tr.dataset.qid = q.id;
                    }
                }
                tdQ.colSpan = columns.length + (!isAuto && this.isEditMode ? 1 : 0);
            } else {
                // Standard row
                if (!isAuto && this.isEditMode) {
                    const delBtn = document.createElement('span'); delBtn.className = 'delete-row-btn'; delBtn.innerHTML = 'Ã—';
                    delBtn.onclick = () => this.deleteRow(q.id);
                    tdQ.appendChild(delBtn);
                }
                if (isAuto && q.origPage) { const tag = document.createElement('div'); tag.className = 'page-tag'; tag.innerHTML = `<span class="source-label">å‡ºå…¸:</span> ${q.origPage}`; tdQ.appendChild(tag); }

                const spanText = document.createElement('span'); spanText.textContent = q.text;
                if (!isAuto && this.isEditMode) { spanText.contentEditable = true; spanText.onblur = () => { q.text = spanText.textContent.trim(); this.saveData(); }; }
                tdQ.appendChild(spanText);

                if (!isAuto && this.isEditMode) {
                    const memoEl = document.createElement('div'); memoEl.className = 'memo-input'; memoEl.placeholder = 'ãƒ¡ãƒ¢...'; memoEl.contentEditable = true;
                    memoEl.textContent = q.memo || ''; memoEl.onblur = () => { q.memo = memoEl.textContent.trim(); this.saveData(); };
                    tdQ.appendChild(memoEl);
                } else if (this.isChecked && q.memo) {
                    const memoEl = document.createElement('div'); memoEl.className = 'memo-display';
                    memoEl.innerHTML = `<strong>è§£èª¬:</strong> ${q.memo.replace(/\n/g, '<br>')}`;
                    tdQ.appendChild(memoEl);
                }
            }

            const statKey = q.type === 'clause' ? `clause-summary-${q.id}` : q.id;
            if (this.questionStats[statKey]) {
                const historyBtn = document.createElement('span'); historyBtn.className = 'history-icon-btn'; historyBtn.innerHTML = ' ğŸ“ˆ';
                historyBtn.onclick = (e) => { e.stopPropagation(); this.showSRSDetail(statKey); };
                tdQ.appendChild(historyBtn);
            }
            tr.appendChild(tdQ);

            if (q.type !== 'clause') {
                if (isAuto && q._autoKeywords && !this.isChecked) {
                    tr.dataset.keywords = JSON.stringify(q._autoKeywords);
                    tr.dataset.requiredCounts = JSON.stringify(q._autoRequired);
                    tr.dataset.qid = q.id;
                }
                for (let i = 1; i < columns.length; i++) {
                    const colLabelRaw = columns[i];
                    const colLabel = colLabelRaw.replace(/\{.*?\}/, '').trim();
                    const td = document.createElement('td'); td.className = 'choice-cell';
                    if (isQMulti) td.classList.add('multi-select');

                    const genericNames = ["é¸æŠè‚¢", "æ­£è§£", "å›ç­”", "ç­”ãˆ"];
                    const isGenericCol = genericNames.some(name => colLabel.includes(name));

                    if (isAuto && q._autoKeywords && isGenericCol) {
                        const userAnswer = this.userAnswers[q.id];
                        td.textContent = (isQMulti ? (userAnswer || []).join(', ') : userAnswer) || colLabel;
                        if (userAnswer && (!Array.isArray(userAnswer) || userAnswer.length > 0)) td.classList.add('filled');
                    } else {
                        td.textContent = colLabel;
                    }

                    if (this.isEditMode && !isAuto) {
                        const isCorrect = isQMulti ? (Array.isArray(q.answer) && q.answer.includes(colLabel)) : (q.answer === colLabel);
                        if (isCorrect) td.classList.add(isQMulti ? 'multi-selected' : 'correct');
                    } else {
                        const userAnswer = this.userAnswers[q.id];
                        const isSelected = isQMulti ? (Array.isArray(userAnswer) && userAnswer.includes(colLabel)) : (userAnswer === colLabel);

                        if (this.isChecked) {
                            const isCorrectAnswer = isQMulti ? (Array.isArray(q.answer) && q.answer.includes(colLabel)) : (q.answer === colLabel);
                            if (isCorrectAnswer) td.classList.add('correct');
                            else if (isSelected) td.classList.add('wrong');
                        } else if (isSelected) td.classList.add('selected');
                    }

                    td.onclick = () => {
                        if (!this.isChecked && !this.isEditMode) {
                            if (isAuto && q._autoKeywords && isGenericCol) {
                                if (isQMulti) this.userAnswers[q.id] = [];
                                else delete this.userAnswers[q.id];
                            } else {
                                if (isQMulti) {
                                    if (!Array.isArray(this.userAnswers[q.id])) this.userAnswers[q.id] = [];
                                    if (this.userAnswers[q.id].includes(colLabel)) this.userAnswers[q.id] = this.userAnswers[q.id].filter(a => a !== colLabel);
                                    else this.userAnswers[q.id].push(colLabel);
                                } else { this.userAnswers[q.id] = colLabel; }
                            }
                            this.renderTable();
                            this.updateGlobalKeywordBank(tr);
                        } else if (this.isEditMode && !isAuto) {
                            if (isQMulti) {
                                if (!Array.isArray(q.answer)) q.answer = [];
                                if (q.answer.includes(colLabel)) q.answer = q.answer.filter(a => a !== colLabel);
                                else q.answer.push(colLabel);
                            } else { q.answer = colLabel; }
                            this.saveData(); this.renderTable();
                        }
                    };

                    if (isAuto && q._autoKeywords && isGenericCol && !this.isChecked) {
                        td.ondragover = (e) => { e.preventDefault(); td.classList.add('drag-over'); };
                        td.ondragleave = () => td.classList.remove('drag-over');
                        td.ondrop = (e) => {
                            e.preventDefault(); td.classList.remove('drag-over');
                            const text = e.dataTransfer.getData('text/plain');
                            if (text) {
                                if (isQMulti) {
                                    if (!Array.isArray(this.userAnswers[q.id])) this.userAnswers[q.id] = [];
                                    if (!this.userAnswers[q.id].includes(text)) this.userAnswers[q.id].push(text);
                                } else { this.userAnswers[q.id] = text; }
                                this.renderTable();
                                this.updateGlobalKeywordBank(tr);
                            }
                        };
                    }
                    tr.appendChild(td);
                }
            }
            tbody.appendChild(tr);
        });
    }


    deleteRow(id) {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (set.questions.length <= 1) { alert('æœ€ä½1è¡Œã¯å¿…è¦ã§ã™ã€‚'); return; }
        if (confirm('ã“ã®è¡Œã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
            set.questions = set.questions.filter(q => q.id !== id);
            this.saveData(); this.renderTable();
        }
    }

    moveRow(id, direction) {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        const index = set.questions.findIndex(q => q.id === id);
        if (index === -1) return;

        const newIndex = index + direction;
        if (newIndex < 0 || newIndex >= set.questions.length) return;

        // Swap
        const temp = set.questions[index];
        set.questions[index] = set.questions[newIndex];
        set.questions[newIndex] = temp;

        this.saveData();
        this.renderTable();
    }

    deleteColumn(index) {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (set.columns.length <= 2) { alert('æœ€ä½1ã¤ã®é¸æŠè‚¢ã¯å¿…è¦ã§ã™ã€‚'); return; }
        const colName = set.columns[index];
        if (confirm(`åˆ—ã€Œ${colName}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
            set.columns.splice(index, 1);
            set.questions.forEach(q => {
                if (Array.isArray(q.answer)) q.answer = q.answer.filter(a => a !== colName);
                else if (q.answer === colName) q.answer = set.columns[1];
            });
            this.saveData(); this.renderTable();
        }
    }

    renderTOC() {
        // Build a flat list in order of display (DFS)
        const getFlatDisplayList = (parentId = null, depth = 0) => {
            let result = [];
            const items = this.quizData.filter(item => item.parentId === parentId);
            items.forEach(item => {
                const globalIndex = this.quizData.findIndex(d => d.id === item.id);
                result.push({ ...item, depth, globalIndex });
                if (item.type === 'folder' && !item.isCollapsed) {
                    result = result.concat(getFlatDisplayList(item.id, depth + 1));
                }
            });
            return result;
        };

        const list = getFlatDisplayList(null, 0);

        this.tocList.innerHTML = list.map(s => {
            const isFolder = s.type === 'folder';
            const isActive = s.id === this.currentSetId && !this.isAutoGenerated && !isFolder;
            const indent = s.depth * 15;

            return `
            <li class="${isActive ? 'active' : ''} ${isFolder ? 'type-folder' : 'type-page'}" 
                style="padding-left: ${indent}px"
                draggable="${this.isEditMode}" 
                ondragstart="app.handleDragStart(event, '${s.id}')" 
                ondragover="app.handleDragOver(event, '${s.id}')" 
                ondrop="app.handleDrop(event, '${s.id}')" 
                ondragend="app.handleDragEnd(event)">
                <div class="item-container ${isFolder ? 'folder-item' : ''}">
                    ${isFolder ? `
                        <span class="folder-toggle" onclick="event.stopPropagation(); app.toggleFolder('${s.id}')">
                            ${s.isCollapsed ? 'â–¶' : 'â–¼'}
                        </span>
                        <span class="folder-icon">${s.isCollapsed ? 'ğŸ“' : 'ğŸ“‚'}</span>
                    ` : ''}
                    <input type="checkbox" class="toc-pool-checkbox" 
                           ${s.isInPool ? 'checked' : ''} 
                           onclick="event.stopPropagation(); app.toggleItemPool('${s.id}')" 
                           title="ç‰¹è¨“å¯¾è±¡ã«å«ã‚ã‚‹">
                    <a href="#${s.id}" draggable="false" onclick="if('${isFolder}' === 'true') { event.preventDefault(); app.toggleFolder('${s.id}'); }">
                        ${s.title}
                    </a>
                    <div class="reorder-btns">
                        <button class="reorder-btn" onclick="event.stopPropagation(); app.movePageById('${s.id}', -1)">â–²</button>
                        <button class="reorder-btn" onclick="event.stopPropagation(); app.movePageById('${s.id}', 1)">â–¼</button>
                        ${isFolder ? `
                            <button class="reorder-btn" title="å­ãƒ•ã‚©ãƒ«ãƒ€ã‚’è¿½åŠ " onclick="event.stopPropagation(); app.addNewFolder('${s.id}')">ï¼‹ğŸ“</button>
                            <button class="reorder-btn" title="é€šå¸¸ãƒšãƒ¼ã‚¸ã‚’è¿½åŠ " onclick="event.stopPropagation(); app.addNewPage('${s.id}')">ï¼‹ğŸ“„</button>
                            <button class="reorder-btn" title="æ¡æ–‡ç©´åŸ‹ã‚ã‚’è¿½åŠ " onclick="event.stopPropagation(); app.addNewClausePage('${s.id}')">ï¼‹ğŸ”¤</button>
                            <button class="reorder-btn delete-folder-btn" onclick="event.stopPropagation(); app.deleteFolder('${s.id}')">Ã—</button>
                        ` : ''}
                    </div>
                </div>
            </li>`;
        }).join('');
    }

    handleDragStart(e, id) {
        if (!this.isEditMode) return;
        this.draggedItemId = id;
        e.dataTransfer.setData('text/plain', id);
        e.currentTarget.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
    }

    handleDragOver(e, id) {
        if (!this.isEditMode) return;
        e.preventDefault();
        const li = e.currentTarget;
        if (id === this.draggedItemId) return;

        const targetItem = this.quizData.find(i => i.id === id);
        if (!targetItem) return;

        // Clean up previous classes
        li.classList.remove('drag-over-top', 'drag-over-bottom', 'drag-over-folder');

        const rect = li.getBoundingClientRect();
        const relativeY = e.clientY - rect.top;
        const height = rect.height;

        if (targetItem.type === 'folder') {
            if (relativeY < height * 0.25) {
                li.classList.add('drag-over-top');
                this.dropPosition = 'above';
            } else if (relativeY > height * 0.75) {
                li.classList.add('drag-over-bottom');
                this.dropPosition = 'below';
            } else {
                li.classList.add('drag-over-folder');
                this.dropPosition = 'inside';
            }
        } else {
            if (relativeY < height / 2) {
                li.classList.add('drag-over-top');
                this.dropPosition = 'above';
            } else {
                li.classList.add('drag-over-bottom');
                this.dropPosition = 'below';
            }
        }
    }

    isDescendant(targetId, potentialParentId) {
        let currentParentId = potentialParentId;
        while (currentParentId) {
            if (currentParentId === targetId) return true;
            const parent = this.quizData.find(i => i.id === currentParentId);
            currentParentId = parent ? parent.parentId : null;
        }
        return false;
    }

    handleDrop(e, id) {
        if (!this.isEditMode) return;
        e.preventDefault();
        const targetItem = this.quizData.find(i => i.id === id);
        const draggedItem = this.quizData.find(i => i.id === this.draggedItemId);

        if (!draggedItem || !targetItem || draggedItem.id === id) return;

        if (draggedItem.type === 'folder' && this.isDescendant(draggedItem.id, id)) {
            alert('ãƒ•ã‚©ãƒ«ãƒ€ã‚’è‡ªåˆ†è‡ªèº«ã®å­è¦ç´ ã«ç§»å‹•ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚');
            return;
        }

        const data = [...this.quizData];
        const itemIdx = data.findIndex(i => i.id === this.draggedItemId);
        if (itemIdx === -1) return;
        const item = data.splice(itemIdx, 1)[0];

        if (this.dropPosition === 'inside' && targetItem.type === 'folder') {
            item.parentId = targetItem.id;
            targetItem.isCollapsed = false;
            data.push(item);
        } else {
            item.parentId = targetItem.parentId;
            let targetIdx = data.findIndex(d => d.id === id);
            if (this.dropPosition === 'below') targetIdx++;
            data.splice(targetIdx, 0, item);
        }

        this.quizData = data;
        this.saveData();
        this.renderTOC();
    }

    handleDragEnd(e) {
        this.draggedItemId = null;
        this.renderTOC();
    }

    movePageById(id, direction) {
        const index = this.quizData.findIndex(i => i.id === id);
        if (index !== -1) this.movePage(index, direction);
    }

    toggleFolder(id) {
        const folder = this.quizData.find(s => s.id === id);
        if (folder && folder.type === 'folder') {
            folder.isCollapsed = !folder.isCollapsed;
            this.saveData();
            this.renderTOC();
        }
    }

    toggleItemPool(id) {
        const item = this.quizData.find(s => s.id === id);
        if (!item) return;

        const newState = !item.isInPool;

        // Recursive function to apply state to descendants
        const applyRecursive = (parentId, state) => {
            this.quizData.forEach(child => {
                if (child.parentId === parentId) {
                    child.isInPool = state;
                    if (child.type === 'folder') {
                        applyRecursive(child.id, state);
                    }
                }
            });
        };

        item.isInPool = newState;
        if (item.type === 'folder') {
            applyRecursive(item.id, newState);
        }

        this.saveData();
        this.renderTOC();
    }

    clearAllPoolSelections() {
        if (!confirm('ç‰¹è¨“å¯¾è±¡ã®ãƒã‚§ãƒƒã‚¯ã‚’ã™ã¹ã¦å¤–ã—ã¾ã™ã‹ï¼Ÿ')) return;
        this.quizData.forEach(item => {
            item.isInPool = false;
        });
        this.saveData();
        this.renderTOC();
    }

    selectAllPoolSelections() {
        if (!confirm('ã™ã¹ã¦ã®å•é¡Œã‚’ç‰¹è¨“å¯¾è±¡ã«å«ã‚ã¾ã™ã‹ï¼Ÿ')) return;
        this.quizData.forEach(item => {
            item.isInPool = true;
        });
        this.saveData();
        this.renderTOC();
    }

    isItemSelectedForPool(itemId) {
        const item = this.quizData.find(i => i.id === itemId);
        return item ? !!item.isInPool : false;
    }

    deleteFolder(id) {
        if (!this.isEditMode) return;
        const folder = this.quizData.find(s => s.id === id);
        if (!folder) return;

        const children = this.quizData.filter(item => item.parentId === id);
        let msg = `ãƒ•ã‚©ãƒ«ãƒ€ã€Œ${folder.title}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`;
        if (children.length > 0) {
            msg += `\n\næ³¨æ„ï¼šä¸­èº«ã®å•é¡Œï¼ˆ${children.length}ä»¶ï¼‰ã¯å‰Šé™¤ã•ã‚Œã¾ã›ã‚“ãŒã€ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰å‡ºã•ã‚Œã¾ã™ã€‚`;
        }

        if (confirm(msg)) {
            // Unparent children
            children.forEach(child => child.parentId = null);
            // Remove folder
            this.quizData = this.quizData.filter(s => s.id !== id);
            this.saveData();
            this.renderTOC();
        }
    }

    addNewFolder(parentId = null) {
        const title = prompt('ãƒ•ã‚©ãƒ«ãƒ€å:');
        if (!title) return;
        const id = 'f-' + Date.now();
        this.quizData.push({
            id, title, type: 'folder', parentId: parentId, isCollapsed: false
        });
        if (parentId) {
            const parent = this.quizData.find(p => p.id === parentId);
            if (parent) parent.isCollapsed = false;
        }
        this.saveData();
        this.renderTOC();
    }

    movePage(index, direction) {
        const itemsAtSameLevel = this.quizData.filter(item => item.parentId === this.quizData[index].parentId);
        const localIndex = itemsAtSameLevel.findIndex(item => item.id === this.quizData[index].id);
        const newLocalIndex = localIndex + direction;

        if (newLocalIndex < 0 || newLocalIndex >= itemsAtSameLevel.length) return;

        const targetGlobalIndex = this.quizData.findIndex(item => item.id === itemsAtSameLevel[newLocalIndex].id);

        const temp = this.quizData[index];
        this.quizData[index] = this.quizData[targetGlobalIndex];
        this.quizData[targetGlobalIndex] = temp;

        this.saveData();
        this.renderTOC();
    }

    updateActiveTOC(id) {
        this.tocList.querySelectorAll('li').forEach(li => {
            const a = li.querySelector('a');
            const isActive = a && a.getAttribute('href') === `#${id}`;
            li.classList.toggle('active', isActive);
        });
    }

    addNewPage(parentId = null) {
        const title = prompt('ã‚¿ã‚¤ãƒˆãƒ«:'); if (!title) return;
        const isMulti = confirm('è¤‡æ•°é¸æŠï¼ˆãƒ©ãƒ³ã‚­ãƒ³ã‚°å½¢å¼ï¼‰ã«ã—ã¾ã™ã‹ï¼Ÿ\nOK: è¤‡æ•°é¸æŠ, ã‚­ãƒ£ãƒ³ã‚»ãƒ«: å˜ä¸€é¸æŠ');
        const id = 'p-' + Date.now();
        const cols = isMulti ? [
            "é †ä½", "ã€ç”Ÿè¨ˆç¶­æŒã€‘", "ã€ç”Ÿè¨ˆåŒä¸€ã€‘", "é…å¶è€…", "å­", "çˆ¶æ¯", "å­«", "ç¥–çˆ¶æ¯", "å…„å¼Ÿå§‰å¦¹", "3è¦ªç­‰ä»¥å†…", "å¯¾è±¡ãªã—"
        ] : ["é …ç›®", "é¸æŠ1", "é¸æŠ2"];

        const questions = [];
        if (isMulti) {
            for (let i = 1; i <= 6; i++) {
                questions.push({ id: 'q-' + Date.now() + i, text: `ç¬¬${i}é †ä½`, answer: [] });
            }
        } else {
            questions.push({ id: 'q-' + Date.now(), text: "æ–°å•é¡Œ", answer: cols[1] });
        }

        const newPage = {
            id, title, type: 'page', parentId: parentId, isMultiSelect: isMulti,
            columns: cols,
            questions: questions
        };

        // If current viewing is a folder, maybe add to it? For now, just add to root
        this.quizData.push(newPage);

        this.isAutoGenerated = false;
        this.saveData();
        this.renderTOC();
        this.loadSet(id);

        // Scroll to the new page in the sidebar
        setTimeout(() => {
            const newElem = this.tocList.querySelector(`a[href="#${id}"]`);
            if (newElem) newElem.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 100);
    }

    addNewClausePage(parentId = null) {
        const title = prompt('æ¡æ–‡ç©´åŸ‹ã‚å•é¡Œã®ã‚¿ã‚¤ãƒˆãƒ«:'); if (!title) return;
        const id = 'p-' + Date.now();
        const newPage = {
            id, title, type: 'clause', parentId: parentId,
            text: 'ã“ã“ã«æ¡æ–‡ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚[[ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰]]ã®ã‚ˆã†ã«å›²ã‚€ã¨ãã“ãŒç©´åŸ‹ã‚ã«ãªã‚Šã¾ã™ã€‚',
            dummies: ''
        };
        this.quizData.push(newPage);
        this.saveData();
        this.renderTOC();
        this.loadSet(id);

        setTimeout(() => {
            const newElem = this.tocList.querySelector(`a[href="#${id}"]`);
            if (newElem) newElem.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 100);
    }

    addNewRow() {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        set.questions.push({
            id: 'q-' + Date.now(),
            text: "æ–°å•é¡Œ...",
            memo: "",
            answer: set.isMultiSelect ? [] : set.columns[1]
        });
        this.saveData();
        this.renderTable();
    }
    addNewColumn() { if (this.isAutoGenerated) return; const set = this.quizData.find(s => s.id === this.currentSetId); const name = prompt('åˆ—å:'); if (!name) return; set.columns.push(name); this.saveData(); this.renderTable(); }

    deleteCurrentPage() {
        if (this.quizData.length <= 1 || this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (!set || set.type === 'folder') {
            alert('ãƒ•ã‚©ãƒ«ãƒ€ã‚’å‰Šé™¤ã™ã‚‹å ´åˆã¯ã€ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®ã€ŒÃ—ã€ãƒœã‚¿ãƒ³ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚');
            return;
        }

        if (confirm(`ã“ã®ãƒšãƒ¼ã‚¸ï¼ˆ${set.title}ï¼‰ã®å…¨å•é¡Œãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚`)) {
            // Safety: if this page had children (unlikely but possible), unparent them
            const children = this.quizData.filter(item => item.parentId === this.currentSetId);
            children.forEach(c => c.parentId = null);

            this.quizData = this.quizData.filter(s => s.id !== this.currentSetId);

            // Find a valid next item (prefer a page)
            let nextItem = this.quizData.find(i => i.type === 'page' || i.type === 'clause');
            if (!nextItem) nextItem = this.quizData[0];

            this.currentSetId = nextItem ? nextItem.id : null;
            this.saveData();
            this.migrateData(); // Rescue orphans if any were created
            this.renderTOC();
            if (this.currentSetId) this.loadSet(this.currentSetId);
            else this.renderTable(); // Show empty state
        }
    }

    cloneCurrentPage() {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (!set) return;

        const newId = 'p-' + Date.now();
        const clonedSet = JSON.parse(JSON.stringify(set));
        clonedSet.id = newId;
        clonedSet.title = clonedSet.title + 'ï¼ˆã‚³ãƒ”ãƒ¼ï¼‰';

        // Re-generate question IDs to avoid conflicts and start fresh stats
        clonedSet.questions.forEach((q, i) => {
            q.id = 'q-' + Date.now() + '-' + i + '-' + Math.random().toString(36).substr(2, 5);
        });

        this.quizData.push(clonedSet);
        this.saveData();
        this.isAutoGenerated = false;
        this.renderTOC();
        this.loadSet(newId);
    }

    clearData() {
        const input = prompt('ã™ã¹ã¦ã®å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã¨å±¥æ­´ã‚’å®Œå…¨ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nå‰Šé™¤ã™ã‚‹å ´åˆã¯ã€ç¢ºèªã®ãŸã‚ã€ŒRESETã€ã¨å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚\næ³¨ï¼šäº‹å‰ã«ã€Œãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¿å­˜ã€ã‚’è¡Œã†ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚');
        if (input === 'RESET') { localStorage.clear(); window.location.reload(); } else if (input !== null) { alert('å…¥åŠ›ãŒæ­£ã—ããªã„ãŸã‚ã€å‰Šé™¤ã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚'); }
    }

    // --- Data Management (Export/Import) ---

    getTimestamp() {
        const now = new Date();
        const pad = (n) => n.toString().padStart(2, '0');
        return `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    }

    async exportToJSON() {
        const fullData = {
            quizData: this.quizData,
            history: this.history,
            questionStats: this.questionStats,
            exportedAt: new Date().toISOString()
        };
        const fileName = `sharo_study_backup_${this.getTimestamp()}.json`;
        const jsonContent = JSON.stringify(fullData, null, 2);

        // Try File System Access API for folder selection
        if (window.showSaveFilePicker) {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{ description: 'JSON File', accept: { 'application/json': ['.json'] } }]
                });
                const writable = await handle.createWritable();
                await writable.write(jsonContent);
                await writable.close();
                this.updateDataStatus("JSONã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚");
                return;
            } catch (err) {
                if (err.name === 'AbortError') return;
                console.error("showSaveFilePicker failed:", err);
            }
        }

        // Fallback for older browsers
        const blob = new Blob([jsonContent], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
        this.updateDataStatus("JSONå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸï¼ˆãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€ã«ä¿å­˜ï¼‰ã€‚");
    }

    async exportToCSV() {
        // CSV is focused on quiz questions only (for spreadsheet editing)
        let csv = '\uFEFF'; // UTF-8 BOM
        csv += 'ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ«,ID,å•é¡Œæ–‡,æ­£è§£(ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š),è§£èª¬,é¸æŠè‚¢1,é¸æŠè‚¢2,é¸æŠè‚¢3,é¸æŠè‚¢4,é¸æŠè‚¢5,é¸æŠè‚¢6,é¸æŠè‚¢7,é¸æŠè‚¢8,é¸æŠè‚¢9,é¸æŠè‚¢10\n';

        this.quizData.forEach(page => {
            if (page.type !== 'page' || !page.questions) return;
            page.questions.forEach(q => {
                const row = [
                    page.title,
                    q.id,
                    q.text,
                    Array.isArray(q.answer) ? q.answer.join('|') : q.answer,
                    q.memo || '',
                    ...(page.columns.slice(1)) // choice choices
                ].map(val => `"${(val || "").toString().replace(/"/g, '""')}"`).join(',');
                csv += row + '\n';
            });
        });

        const fileName = `sharo_questions_${this.getTimestamp()}.csv`;

        if (window.showSaveFilePicker) {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{ description: 'CSV File', accept: { 'text/csv': ['.csv'] } }]
                });
                const writable = await handle.createWritable();
                await writable.write(csv);
                await writable.close();
                this.updateDataStatus("CSVã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚");
                return;
            } catch (err) {
                if (err.name === 'AbortError') return;
                console.error("showSaveFilePicker failed:", err);
            }
        }

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
        this.updateDataStatus("CSVå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸï¼ˆãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€ã«ä¿å­˜ï¼‰ã€‚");
    }

    handleFileImport(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            const content = event.target.result;
            if (file.name.endsWith('.json')) {
                this.importFromJSON(content);
            } else if (file.name.endsWith('.csv')) {
                this.importFromCSV(content);
            }
        };
        reader.readAsText(file);
    }

    importFromJSON(jsonString) {
        try {
            const data = JSON.parse(jsonString);
            if (!data.quizData) throw new Error('Invalid backup format');

            if (confirm('ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã™ã¹ã¦ä¸Šæ›¸ãã—ã¦å¾©æ—§ã—ã¾ã™ã‹ï¼Ÿ\nï¼ˆç¾åœ¨ã®å•é¡Œãƒ»å±¥æ­´ãƒ»çµ±è¨ˆãŒã™ã¹ã¦æ¶ˆãˆã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã«ç½®ãæ›ã‚ã‚Šã¾ã™ï¼‰')) {
                this.quizData = data.quizData;
                this.history = data.history || [];
                this.questionStats = data.questionStats || {};

                this.saveData();
                this.saveHistory();
                this.saveQuestionStats();

                alert('ãƒ‡ãƒ¼ã‚¿ã‚’æ­£å¸¸ã«å¾©å…ƒã—ã¾ã—ãŸã€‚');
                window.location.reload();
            }
        } catch (err) {
            console.error(err);
            alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æœ‰åŠ¹ãªJSONãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
        }
    }

    importFromCSV(csvString) {
        try {
            const lines = csvString.split(/\r?\n/);
            if (lines.length < 2) return;

            // Simple CSV parser (not handling all escapes, but works for standard export)
            const parseCSVLine = (line) => {
                const parts = [];
                let current = '';
                let inQuotes = false;
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"' && line[i + 1] === '"') { current += '"'; i++; }
                    else if (char === '"') inQuotes = !inQuotes;
                    else if (char === ',' && !inQuotes) { parts.push(current); current = ''; }
                    else current += char;
                }
                parts.push(current);
                return parts;
            };

            const header = parseCSVLine(lines[0]);
            const newPages = new Map();

            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                const row = parseCSVLine(lines[i]);
                const pageTitle = row[0];
                const id = row[1] || ('q-' + Math.random().toString(36).substr(2, 9));
                const text = row[2];
                const answerRaw = row[3];
                const choices = row.slice(4).filter(c => c !== undefined && c !== "");

                if (!pageTitle || !text) continue;

                if (!newPages.has(pageTitle)) {
                    newPages.set(pageTitle, {
                        id: 'p-' + Date.now() + Math.random().toString(36).substr(2, 5),
                        title: pageTitle,
                        type: 'page',
                        parentId: null,
                        isCollapsed: false,
                        columns: ["é …ç›®", ...choices],
                        questions: [],
                        isMultiSelect: answerRaw.includes('|')
                    });
                }

                const page = newPages.get(pageTitle);
                page.questions.push({
                    id: id,
                    text: text,
                    answer: page.isMultiSelect ? answerRaw.split('|') : answerRaw,
                    isInPool: true
                });
            }

            if (confirm(`CSVã‹ã‚‰ ${newPages.size} ãƒšãƒ¼ã‚¸ã®å•é¡Œã‚’å–ã‚Šè¾¼ã¿ã¾ã™ã‹ï¼Ÿ\næ—¢å­˜ã®ãƒšãƒ¼ã‚¸ã¯ç¶­æŒã•ã‚Œã€æœ«å°¾ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚`)) {
                this.quizData.push(...Array.from(newPages.values()));
                this.saveData();
                alert('CSVã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’æ­£å¸¸ã«å–ã‚Šè¾¼ã¿ã¾ã—ãŸã€‚');
                this.renderTOC();
                this.loadSet(this.currentSetId);
            }
        } catch (err) {
            console.error(err);
            alert('CSVã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
        }
    }

    updateDataStatus(msg) {
        if (this.dataStatusMsg) {
            this.dataStatusMsg.textContent = `${msg} (${new Date().toLocaleTimeString()})`;
            this.dataStatusMsg.style.color = 'var(--success)';
            setTimeout(() => {
                this.dataStatusMsg.style.color = 'var(--text-secondary)';
            }, 5000);
        }
        // Save export timestamp for reminder
        if (msg.includes("ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ")) {
            localStorage.setItem('sharo_last_export_at', new Date().toISOString());
            this.checkBackupFrequency();
        }
    }

    // --- Automatic Recovery and Protection ---

    checkAndOfferRecovery(manual = false) {
        const backupStr = localStorage.getItem('sharo_auto_backup');
        if (!backupStr) {
            if (manual) alert('å†…éƒ¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
            return;
        }

        try {
            const backup = JSON.parse(backupStr);
            const isMainEmpty = (this.quizData.length <= DEFAULT_QUIZ_DATA.length && this.history.length === 0);

            if (manual || isMainEmpty) {
                const date = new Date(backup.savedAt).toLocaleString();
                const msg = manual
                    ? `å†…éƒ¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼ˆä¿å­˜æ—¥æ™‚: ${date}ï¼‰ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ\nç¾åœ¨ç·¨é›†ä¸­ã®å†…å®¹ã¯ä¸Šæ›¸ãã•ã‚Œã¾ã™ã€‚`
                    : `ã€ãƒ‡ãƒ¼ã‚¿å¾©æ—§ã®æ¡ˆå†…ã€‘\nãƒ¡ã‚¤ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒåˆæœŸçŠ¶æ…‹ã®ã‚ˆã†ã§ã™ãŒã€å†…éƒ¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼ˆä¿å­˜æ—¥æ™‚: ${date}ï¼‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚\nä»¥å‰ã®çŠ¶æ…‹ã‚’å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ`;

                if (confirm(msg)) {
                    this.quizData = backup.quizData;
                    this.history = backup.history || [];
                    this.questionStats = backup.questionStats || {};
                    this.saveData();
                    this.saveHistory();
                    this.saveQuestionStats();
                    alert('ãƒ‡ãƒ¼ã‚¿ã‚’æ­£å¸¸ã«å¾©å…ƒã—ã¾ã—ãŸã€‚');
                    window.location.reload();
                }
            }
        } catch (e) {
            console.error("Backup parse error", e);
        }
    }

    checkBackupFrequency() {
        const lastExport = localStorage.getItem('sharo_last_export_at');
        if (!lastExport) return;

        const hoursSince = (Date.now() - new Date(lastExport).getTime()) / (1000 * 60 * 60);
        if (hoursSince > 24) {
            const reminderArea = document.getElementById('backup-reminder');
            if (reminderArea) {
                reminderArea.style.display = 'block';
                reminderArea.innerHTML = `âš ï¸ æœ€çµ‚ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‹ã‚‰24æ™‚é–“ä»¥ä¸ŠçµŒéã—ã¦ã„ã¾ã™ã€‚å¤§åˆ‡ãªãƒ‡ãƒ¼ã‚¿ã‚’å®ˆã‚‹ãŸã‚ã€<span style="color:var(--accent); cursor:pointer; text-decoration:underline;" onclick="app.exportToJSON()">JSONãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ä¿å­˜</span>ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚`;
            }
        } else {
            const reminderArea = document.getElementById('backup-reminder');
            if (reminderArea) reminderArea.style.display = 'none';
        }
    }

    setupQuestionObserver() {
        if (this.questionObserver) this.questionObserver.disconnect();

        const options = {
            root: null,
            rootMargin: '-5% 0px -20% 0px',
            threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
        };

        this.questionObserver = new IntersectionObserver(() => {
            this.activateFirstVisibleBank();
        }, options);

        const targets = document.querySelectorAll('#quiz-table tr, .auto-gen-table tr');
        targets.forEach(t => {
            if (t.dataset.keywords) {
                this.questionObserver.observe(t);
            }
        });

        // Fallback: also update on scroll for smoother experience
        if (this._scrollHandler) window.removeEventListener('scroll', this._scrollHandler);
        this._scrollHandler = () => this.activateFirstVisibleBank();
        window.addEventListener('scroll', this._scrollHandler, { passive: true });

        this.activateFirstVisibleBank();
        setTimeout(() => this.activateFirstVisibleBank(), 300);
    }

    activateFirstVisibleBank() {
        if (this.isEditMode || this.isChecked) {
            if (this.globalKeywordBank) {
                this.globalKeywordBank.classList.add('hidden');
                this.globalKeywordBank.classList.remove('active-bank');
            }
            this._currentActiveRowId = null;
            return;
        }

        const targets = Array.from(document.querySelectorAll('#quiz-table tr, .auto-gen-table tr')).filter(r => r.dataset.keywords);

        const isSingleClause = !this.clauseDisplay.classList.contains('hidden');
        const isHome = this.homeDashboard && !this.homeDashboard.classList.contains('hidden');

        if (targets.length === 0) {
            if (!isSingleClause || isHome) {
                if (this.globalKeywordBank) {
                    this.globalKeywordBank.classList.add('hidden');
                    this.globalKeywordBank.classList.remove('active-bank');
                }
                this._currentActiveRowId = null;
            }
            return;
        }

        // ç”»é¢ä¸Šéƒ¨ã‹ã‚‰40%ã®ä½ç½®ã‚’ã€Œåˆ‡ã‚Šæ›¿ãˆã®é–¾å€¤ã€ã¨ã™ã‚‹
        const focusThreshold = window.innerHeight * 0.4;
        let bestRow = null;

        // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå†…ã«ã‚ã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’å–å¾—
        const visibleTargets = targets.filter(tr => {
            const rect = tr.getBoundingClientRect();
            return rect.top < window.innerHeight && rect.bottom > 0;
        });

        if (visibleTargets.length > 0) {
            // ã€Œç¾åœ¨ã®è¡Œã€ã®åº•è¾ºãŒé–¾å€¤ã‚ˆã‚Šä¸‹ã«ã‚ã‚‹é™ã‚Šã€ãã®è¡Œã‚’å„ªå…ˆã™ã‚‹ï¼ˆä¸Šã‹ã‚‰é †ã«æ¢ã™ï¼‰
            bestRow = visibleTargets.find(tr => {
                const rect = tr.getBoundingClientRect();
                return rect.bottom > focusThreshold;
            });

            // ã™ã¹ã¦ãŒé–¾å€¤ã‚ˆã‚Šä¸Šã«è¡Œã£ãŸå ´åˆã¯ã€ä¸€ç•ªä¸‹ã®å¯è¦–è¡Œã‚’é¸æŠ
            if (!bestRow) bestRow = visibleTargets[visibleTargets.length - 1];
        }

        // é¸æŠã•ã‚ŒãŸè¡ŒãŒã‚ã£ã¦ã‚‚ã€ç”»é¢å¤–ï¼ˆæ¥µç«¯ã«ä¸‹ãªã©ï¼‰ã™ãã‚‹å ´åˆã¯éè¡¨ç¤º
        if (bestRow) {
            const rect = bestRow.getBoundingClientRect();
            if (rect.top > window.innerHeight * 0.9) bestRow = null;
        }

        if (bestRow) {
            if (this._currentActiveRowId !== bestRow.id) {
                this._currentActiveRowId = bestRow.id;
                this.updateGlobalKeywordBank(bestRow);
            }
        } else {
            if (this._currentActiveRowId !== null) {
                this._currentActiveRowId = null;
                if (this.globalKeywordBank) {
                    this.globalKeywordBank.classList.add('hidden');
                    this.globalKeywordBank.classList.remove('active-bank');
                }
            }
        }
    }

    updateGlobalKeywordBank(row) {
        if (!this.globalKeywordBank) return;

        // Hide bank if we are in "isChecked" mode or Edit mode
        if (this.isChecked || this.isEditMode || !row || !row.dataset.keywords) {
            this.globalKeywordBank.classList.add('hidden');
            this.globalKeywordBank.classList.remove('active-bank');
            this._currentActiveRowId = null;
            return;
        }

        const qid = row.dataset.qid;
        const allOptions = JSON.parse(row.dataset.keywords);
        const requiredCounts = JSON.parse(row.dataset.requiredCounts);

        const cacheKey = `bank-${qid}`;
        if (!this.shuffledCache[cacheKey]) this.shuffledCache[cacheKey] = allOptions.sort(() => Math.random() - 0.5);

        const usedCounts = {};
        Object.keys(this.userAnswers).forEach(key => {
            if (key.startsWith(`${qid}-`)) {
                const ans = this.userAnswers[key];
                usedCounts[ans] = (usedCounts[ans] || 0) + 1;
            }
        });
        const topAns = this.userAnswers[qid];
        if (topAns) {
            if (Array.isArray(topAns)) topAns.forEach(a => usedCounts[a] = (usedCounts[a] || 0) + 1);
            else usedCounts[topAns] = (usedCounts[topAns] || 0) + 1;
        }

        this.globalKeywordBank.innerHTML = '';
        this.globalKeywordBank.classList.remove('hidden');
        this.globalKeywordBank.classList.add('active-bank');
        this.globalKeywordBank.classList.toggle('minimized', this.isBankMinimized);

        // Add Header for minimization
        const bankHeader = document.createElement('div');
        bankHeader.className = 'keyword-bank-header';

        const titleSpan = document.createElement('span');
        titleSpan.className = 'bank-title';
        titleSpan.textContent = this.isBankMinimized ? 'é¸æŠè‚¢ãƒãƒ³ã‚¯ (æœ€å°åŒ–ä¸­)' : 'é¸æŠè‚¢ãƒãƒ³ã‚¯';

        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'bank-toggle-btn';
        toggleBtn.textContent = this.isBankMinimized ? 'â–² å±•é–‹ã™ã‚‹' : 'â–¼ æœ€å°åŒ–ã™ã‚‹';
        toggleBtn.onclick = (e) => {
            e.stopPropagation();
            this.isBankMinimized = !this.isBankMinimized;
            this.updateGlobalKeywordBank(row);
        };

        bankHeader.appendChild(titleSpan);
        bankHeader.appendChild(toggleBtn);
        this.globalKeywordBank.appendChild(bankHeader);

        if (this.isBankMinimized) return;

        this.shuffledCache[cacheKey].forEach(word => {
            const req = requiredCounts[word] || 0;
            const used = usedCounts[word] || 0;
            const isUsed = req > 0 ? (used >= req) : (used > 0);

            const card = document.createElement('div'); card.className = `keyword-card ${isUsed ? 'used' : ''}`;
            if (req > 1 && !isUsed) {
                card.innerHTML = `${word} <span class="keyword-count-badge">${req - used}</span>`;
            } else {
                card.textContent = word;
            }
            if (this.selectedKeyword === word) card.classList.add('selected');

            card.draggable = !isUsed;
            card.onclick = (e) => {
                if (isUsed) return;
                if (this.selectedKeyword === word) {
                    this.selectedKeyword = null;
                } else {
                    this.selectedKeyword = word;
                }
                this.updateGlobalKeywordBank(row);
            };
            card.ondragstart = (e) => {
                if (isUsed) return;
                e.dataTransfer.setData('text/plain', word);
                card.classList.add('dragging');
                // Store active qid globally for drop handling if needed
                this.activeDragQid = qid;
            };
            card.ondragend = () => card.classList.remove('dragging');
            this.globalKeywordBank.appendChild(card);
        });
    }

    // --- GitHub Sync Methods ---

    loadGitHubConfig() {
        const config = JSON.parse(localStorage.getItem('sharoGitHubConfig') || '{}');
        if (this.ghTokenInput) this.ghTokenInput.value = config.token || '';
        if (this.ghRepoInput) this.ghRepoInput.value = config.repo || '';
        if (this.ghPathInput) this.ghPathInput.value = config.path || 'data/sharo_study_sync.json';
        this.updateGitHubStatus();
    }

    saveGitHubConfig() {
        const config = {
            token: this.ghTokenInput.value.trim(),
            repo: this.ghRepoInput.value.trim(),
            path: this.ghPathInput.value.trim()
        };
        localStorage.setItem('sharoGitHubConfig', JSON.stringify(config));
        alert('GitHubã®è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚');
        this.updateGitHubStatus();
    }

    updateGitHubStatus(msg = null) {
        if (!this.ghSyncStatus) return;
        const config = JSON.parse(localStorage.getItem('sharoGitHubConfig') || '{}');
        if (!config.token || !config.repo) {
            this.ghSyncStatus.textContent = 'æœªé€£æº';
            this.ghSyncStatus.className = 'github-connect-status';
            return;
        }
        this.ghSyncStatus.textContent = msg || 'é€£æºæ¸ˆã¿ï¼ˆåŒæœŸãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ï¼‰';
        this.ghSyncStatus.className = 'github-connect-status synced';
    }

    async syncWithGitHub() {
        const config = JSON.parse(localStorage.getItem('sharoGitHubConfig') || '{}');
        if (!config.token || !config.repo) {
            alert('GitHubã®è¨­å®šï¼ˆãƒˆãƒ¼ã‚¯ãƒ³ã¨ãƒªãƒã‚¸ãƒˆãƒªï¼‰ã‚’å…ˆã«ä¿å­˜ã—ã¦ãã ã•ã„ã€‚');
            return;
        }

        if (this.ghSyncNowBtn) {
            this.ghSyncNowBtn.disabled = true;
            this.ghSyncNowBtn.textContent = 'åŒæœŸä¸­...';
        }
        if (this.sidebarGhSyncBtn) {
            this.sidebarGhSyncBtn.disabled = true;
            this.sidebarGhSyncBtn.textContent = 'åŒæœŸä¸­...';
        }
        this.updateGitHubStatus('åŒæœŸä¸­...');
        console.log('Starting GitHub Sync...');

        try {
            // 1. Fetch remote data
            const remote = await this.fetchFromGitHub(config);
            let localData = {
                quizData: this.quizData,
                questionStats: this.questionStats,
                history: this.history,
                lastModified: parseInt(localStorage.getItem('sharoLastModified') || '0')
            };

            if (remote) {
                // 2. Conflict handling: simple timestamp check
                if (remote.lastModified > localData.lastModified) {
                    if (confirm(`GitHubä¸Šã«æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸï¼ˆ${new Date(remote.lastModified).toLocaleString()}ï¼‰ã€‚ä¸Šæ›¸ãã—ã¾ã™ã‹ï¼Ÿ`)) {
                        this.quizData = remote.quizData;
                        this.questionStats = remote.questionStats;
                        this.history = remote.history;
                        this.saveData();
                        this.saveQuestionStats();
                        this.saveHistory();
                        localStorage.setItem('sharoLastModified', remote.lastModified);
                        alert('ãƒªãƒ¢ãƒ¼ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚');
                        location.reload(); // Reload to refresh everything
                        return;
                    }
                }
            }

            // 3. Push local data (if remote is older or user chose to push)
            localData.lastModified = Date.now();
            await this.pushToGitHub(config, localData);
            localStorage.setItem('sharoLastModified', localData.lastModified);

            this.updateGitHubStatus(`åŒæœŸå®Œäº† (${new Date().toLocaleTimeString()})`);
            alert('GitHubã¸ã®åŒæœŸãŒå®Œäº†ã—ã¾ã—ãŸã€‚');
        } catch (error) {
            console.error('GitHub Sync Error Details:', {
                message: error.message,
                stack: error.stack,
                config_path: config.path,
                config_repo: config.repo
            });
            alert('åŒæœŸã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message + '\n\nâ€»1MBã‚’è¶…ãˆã‚‹å·¨å¤§ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚„GitHubã®æ¨©é™ã€ãƒªãƒã‚¸ãƒˆãƒªåã®è¨­å®šãŒæ­£ã—ã„ã‹ã”ç¢ºèªãã ã•ã„ã€‚');
            this.updateGitHubStatus('åŒæœŸå¤±æ•—');
        } finally {
            if (this.ghSyncNowBtn) {
                this.ghSyncNowBtn.disabled = false;
                this.ghSyncNowBtn.textContent = 'ä»Šã™ãåŒæœŸï¼ˆã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼†ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼‰';
            }
            if (this.sidebarGhSyncBtn) {
                this.sidebarGhSyncBtn.disabled = false;
                this.sidebarGhSyncBtn.textContent = 'ä»Šã™ãåŒæœŸ';
            }
        }
    }

    async fetchFromGitHub(config) {
        const url = `https://api.github.com/repos/${config.repo}/contents/${config.path}`;
        const headers = {
            'Authorization': config.token.startsWith('ghp_') ? `token ${config.token}` : `Bearer ${config.token}`
        };

        // 1. Get SHA via HEAD request (bypasses 1MB body limit)
        const headResponse = await fetch(url, { method: 'HEAD', headers });
        if (headResponse.status === 404) return null;
        if (!headResponse.ok) throw new Error(`Metadata check failed: ${headResponse.status}`);

        // GitHub ETag for blobs/contents is the SHA
        const etag = headResponse.headers.get('ETag');
        this._ghFileSha = etag ? etag.replace(/"/g, '') : null;

        // 2. Fetch content via Raw media type (handles up to 100MB)
        const rawResponse = await fetch(url, {
            headers: { ...headers, 'Accept': 'application/vnd.github.v3.raw' }
        });

        if (!rawResponse.ok) {
            throw new Error(`Content fetch failed: ${rawResponse.status}`);
        }

        const content = await rawResponse.text();
        if (!content) return null;

        try {
            return JSON.parse(content);
        } catch (e) {
            console.error('JSON Parse Error. Raw content start:', content.substring(0, 100));
            throw new Error('ãƒªãƒ¢ãƒ¼ãƒˆã®JSONãƒ•ã‚¡ã‚¤ãƒ«ãŒå£Šã‚Œã¦ã„ã‚‹ã‹ã€ç©ºã§ã™ã€‚');
        }
    }

    async pushToGitHub(config, data) {
        this.pruneData();
        const url = `https://api.github.com/repos/${config.repo}/contents/${config.path}`;
        const content = this.utf8_to_b64_encode(JSON.stringify(data));

        // Need current SHA to update existing file
        if (!this._ghFileSha) {
            const headResponse = await fetch(url, {
                method: 'HEAD',
                headers: { 'Authorization': config.token.startsWith('ghp_') ? `token ${config.token}` : `Bearer ${config.token}` }
            });
            if (headResponse.ok) {
                const etag = headResponse.headers.get('ETag');
                this._ghFileSha = etag ? etag.replace(/"/g, '') : null;
            }
        }

        const body = {
            message: 'Sync sharo study data',
            content: content,
            sha: this._ghFileSha
        };

        const response = await fetch(url, {
            method: 'PUT',
            headers: {
                'Authorization': config.token.startsWith('ghp_') ? `token ${config.token}` : `Bearer ${config.token}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            const err = await response.json();
            throw new Error(err.message || 'Push failed');
        }

        const resData = await response.json();
        this._ghFileSha = resData.content.sha;
    }

    // Helper for Unicode-safe Base64
    utf8_to_b64_encode(str) {
        return btoa(unescape(encodeURIComponent(str)));
    }

    utf8_to_b64_decode(str) {
        // GitHub API base64 can contain newlines
        const cleanStr = str.replace(/\n/g, '');
        return decodeURIComponent(escape(atob(cleanStr)));
    }
}
let app;
document.addEventListener('DOMContentLoaded', () => {
    app = new QuizApp();
    window.app = app; // Correctly expose app to global for onclick handlers
});
