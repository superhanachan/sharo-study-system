const DEFAULT_QUIZ_DATA = [
    {
        id: "pension-1",
        title: "å›½æ°‘å¹´é‡‘æ³• è³‡æ ¼å–ªå¤±ã®æ™‚æœŸ (æ³•9æ¡) å¼·åˆ¶è¢«ä¿é™ºè€…",
        columns: ["é …ç›®", "å½“æ—¥å–ªå¤±", "ç¿Œæ—¥å–ªå¤±"],
        questions: [
            { id: "q-1", text: "ã‚¤ï¼‰æ­»äº¡ã—ãŸã¨ã", answer: "ç¿Œæ—¥å–ªå¤±" },
            { id: "q-2", text: "ãƒ‹ï¼‰åšç”Ÿå¹´é‡‘ä¿é™ºæ³•ã«åŸºã¥ãè€é½¢çµ¦ä»˜ç­‰ã‚’å—ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹è€…ãã®ä»–ã“ã®æ³•å¾‹ã®é©ç”¨ã‚’é™¤å¤–ã™ã¹ãç‰¹åˆ¥ã®ç†ç”±ãŒã‚ã‚‹è€…ã¨ã—ã¦åšç”ŸåŠ´åƒçœä»¤ã§å®šã‚ã‚‹è€…ã¨ãªã£ãŸã¨ãï¼ˆç¬¬2å·è¢«ä¿é™ºè€…åˆã¯ç¬¬3å·è¢«ä¿é™ºè€…ã«è©²å½“ã™ã‚‹ã¨ãã‚’é™¤ãï¼‰", answer: "å½“æ—¥å–ªå¤±" },
            { id: "q-3", text: "ãƒï¼‰60æ­³ã«é”ã—ãŸã¨ãï¼ˆç¬¬2å·è¢«ä¿é™ºè€…ã«è©²å½“ã™ã‚‹ã¨ãã‚’é™¤ãï¼‰", answer: "å½“æ—¥å–ªå¤±" }
        ]
    },
    {
        id: "survivor-rank-1",
        title: "ã€ç‰¹è¨“ã€‘éºæ—ã®é †ä½åˆ¤å®šï¼ˆã‚¹ãƒªãƒ ç‰ˆï¼‰",
        isMultiSelect: true,
        columns: [
            "é †ä½", "ã€ç”Ÿè¨ˆç¶­æŒã€‘", "ã€ç”Ÿè¨ˆåŒä¸€ã€‘", "é…å¶è€…", "å­", "çˆ¶æ¯", "å­«", "ç¥–çˆ¶æ¯", "å…„å¼Ÿå§‰å¦¹", "3è¦ªç­‰ä»¥å†…", "å¯¾è±¡ãªã—"
        ],
        questions: [
            { id: "q-surv-1", text: "ç¬¬1é †ä½", answer: ["é…å¶è€…", "å­", "ã€ç”Ÿè¨ˆç¶­æŒã€‘"] },
            { id: "q-surv-2", text: "ç¬¬2é †ä½", answer: ["çˆ¶æ¯", "ã€ç”Ÿè¨ˆç¶­æŒã€‘"] },
            { id: "q-surv-3", text: "ç¬¬3é †ä½", answer: ["å­«", "ã€ç”Ÿè¨ˆç¶­æŒã€‘"] },
            { id: "q-surv-4", text: "ç¬¬4é †ä½", answer: ["ç¥–çˆ¶æ¯", "ã€ç”Ÿè¨ˆç¶­æŒã€‘"] },
            { id: "q-surv-5", text: "ç¬¬5é †ä½", answer: ["å¯¾è±¡ãªã—"] },
            { id: "q-surv-6", text: "ç¬¬6é †ä½", answer: ["å¯¾è±¡ãªã—"] }
        ]
    },
    {
        id: "clause-sample-1",
        title: "é›‡ç”¨ä¿é™ºæ³• ç¬¬1æ¡ï¼ˆç›®çš„ï¼‰",
        type: "clause",
        text: "é›‡ç”¨ä¿é™ºã¯ã€åŠ´åƒè€…ãŒ[[å¤±æ¥­]]ã—ãŸå ´åˆåŠã³åŠ´åƒè€…ã«ã¤ã„ã¦[[é›‡ç”¨ã®ç¶™ç¶š]]ãŒå›°é›£ã¨ãªã‚‹äº‹ç”±ãŒç”Ÿã˜ãŸå ´åˆã«å¿…è¦ãªçµ¦ä»˜ã‚’è¡Œã†ã»ã‹ã€åŠ´åƒè€…ãŒè‡ªã‚‰è·æ¥­ã«é–¢ã™ã‚‹[[æ•™è‚²è¨“ç·´]]ã‚’å—ã‘ãŸå ´åˆä¸¦ã³ã«åŠ´åƒè€…ãŒ[[å­ã‚’é¤Šè‚²]]ã™ã‚‹ãŸã‚ã®ä¼‘æ¥­åŠã³[[æ‰€å®šåŠ´åƒæ™‚é–“]]ã‚’çŸ­ç¸®ã™ã‚‹ã“ã¨ã«ã‚ˆã‚‹å°±æ¥­ã‚’ã—ãŸå ´åˆã«å¿…è¦ãªçµ¦ä»˜ã‚’è¡Œã†ã“ã¨ã«ã‚ˆã‚Šã€åŠ´åƒè€…ã®[[ç”Ÿæ´»åŠã³é›‡ç”¨]]ã®å®‰å®šã‚’å›³ã‚‹ã¨ã¨ã‚‚ã«ã€[[æ±‚è·æ´»å‹•]]ã‚’å®¹æ˜“ã«ã™ã‚‹ç­‰ãã®å°±è·ã‚’ä¿ƒé€²ã—ã€ã‚ã‚ã›ã¦ã€åŠ´åƒè€…ã®[[è·æ¥­ã®å®‰å®š]]ã«è³‡ã™ã‚‹ãŸã‚ã€[[å¤±æ¥­ã®äºˆé˜²]]ã€é›‡ç”¨çŠ¶æ…‹ã®æ˜¯æ­£åŠã³[[é›‡ç”¨æ©Ÿä¼šã®å¢—å¤§]]ã€åŠ´åƒè€…ã®[[èƒ½åŠ›ã®é–‹ç™º]]åŠã³å‘ä¸Šãã®ä»–åŠ´åƒè€…ã®[[ç¦ç¥‰ã®å¢—é€²]]ã‚’å›³ã‚‹ã“ã¨ã‚’ç›®çš„ã¨ã™ã‚‹ã€‚",
        dummies: ["è€é½¢åŸºç¤å¹´é‡‘", "åšç”ŸåŠ´åƒå¤§è‡£", "60æ—¥ä»¥å†…"],
        questions: []
    }
];

// Spaced Repetition System (SRS) intervals in days
// Level 0: New, Level 1: 1 day, Level 2: 2 days, Level 3: 4 days, etc.
const SRS_INTERVALS = [0, 1, 2, 4, 7, 14, 30, 60, 120, 180, 365];


class QuizApp {
    constructor() {
        this.quizData = this.loadData();
        this.history = this.loadHistory();
        this.questionStats = this.loadQuestionStats();
        this.currentSetId = this.quizData[0].id;
        this.isEditMode = false;
        this.isAutoGenerated = false;

        this.userAnswers = {};
        this.isChecked = false;
        this.sortColumnIndex = -1;
        this.sortDirection = 1;

        this.chartMode = 'accuracy';
        this.statsChart = null;

        this.migrateData();
        this.cacheDOM();
        this.bindEvents();
        if (this.closeModalBtn) {
            this.closeModalBtn.addEventListener('click', () => this.srsModal.classList.add('hidden'));
        }
        window.addEventListener('click', (e) => {
            if (e.target === this.srsModal) this.srsModal.classList.add('hidden');
        });

        // Initial call
        this.init();

    }

    migrateData() {
        let modified = false;

        // 1. Inject/Update Survivor Sample (Check for "ã‚¹ãƒªãƒ ç‰ˆ" or column count change)
        const currentRank = this.quizData.find(s => s.id === "survivor-rank-1");
        const defaultRank = DEFAULT_QUIZ_DATA.find(s => s.id === "survivor-rank-1");

        if (!currentRank || (currentRank.columns && currentRank.columns[1] !== "ã€ç”Ÿè¨ˆç¶­æŒã€‘")) {
            if (currentRank) {
                this.quizData = this.quizData.filter(s => s.id !== "survivor-rank-1");
            }
            this.quizData.push(JSON.parse(JSON.stringify(defaultRank)));
            modified = true;
        }

        // SAFETY: Circular reference and orphaned item rescue
        const reachableIds = new Set();
        const walk = (parentId) => {
            this.quizData.filter(item => item.parentId === parentId).forEach(item => {
                if (reachableIds.has(item.id)) return; // Prevent infinite loop
                reachableIds.add(item.id);
                walk(item.id);
            });
        };
        walk(null); // Start from root

        this.quizData.forEach(set => {
            if (!set.type) set.type = 'page';
            if (set.parentId === undefined) set.parentId = null;
            if (set.isCollapsed === undefined) set.isCollapsed = false;
            if (set.isInPool === undefined) set.isInPool = true;

            if (!reachableIds.has(set.id)) {
                // Rescue item by moving to root
                set.parentId = null;
                reachableIds.add(set.id); // Mark as now reachable to prevent redundant rescue
                modified = true;
            }

            if (set.type === 'page') {
                if (!set.questions) return;
                set.questions.forEach(q => {
                    if (!q.id) { q.id = 'q-' + Math.random().toString(36).substr(2, 9) + Date.now(); modified = true; }
                    if (set.isMultiSelect && typeof q.answer === 'string') {
                        q.answer = [q.answer];
                        modified = true;
                    }
                    if (q.isInPool === undefined) {
                        q.isInPool = true;
                        modified = true;
                    }
                });
            }
        });

        // 2. Safe cleanup of questionStats
        // BUG FIX: Only cleanup stats if quizData is successfully loaded and has content.
        // If quizData is somehow empty or fallback-only but stats exist, we MUST NOT wipe them.
        if (this.quizData && this.quizData.length > 0) {
            const cleanedStats = {};
            const allIds = new Set();
            this.quizData.forEach(set => {
                if (set.type === 'page' && set.questions) {
                    set.questions.forEach(q => allIds.add(q.id));
                } else if (set.type === 'clause' && set.text) {
                    // Include summary ID and individual IDs for each blank
                    allIds.add(`clause-summary-${set.id}`);
                    const blankCount = set.text.split('[[').length - 1;
                    for (let i = 0; i < blankCount; i++) {
                        allIds.add(`clause-${set.id}-${i}`);
                    }
                }
            });

            let hasWiped = false;
            Object.keys(this.questionStats).forEach(key => {
                if (allIds.has(key)) {
                    cleanedStats[key] = this.questionStats[key];
                    // Initialize recent history for older data
                    if (!cleanedStats[key].recent) {
                        const t = cleanedStats[key].total || 0;
                        const c = cleanedStats[key].correct || 0;
                        const count = Math.min(t, 5);
                        const r = [];
                        const recentCorrect = t > 0 ? Math.round((c / t) * count) : 0;
                        for (let i = 0; i < count; i++) r.push(i < recentCorrect ? 1 : 0);
                        cleanedStats[key].recent = r;
                    }
                    // Initialize SRS fields
                    if (cleanedStats[key].srsLevel === undefined) cleanedStats[key].srsLevel = 0;
                    if (cleanedStats[key].nextReview === undefined) cleanedStats[key].nextReview = null;

                } else {
                    // Log or backup orphaned stats if needed, but for now, just track if we're deleting
                    hasWiped = true;
                }
            });

            // SAFETY: If we are about to wipe more than 50% of stats, something might be wrong.
            // In a real data loss scenario, quizData might be default (2 items) while stats are 100+.
            if (hasWiped && Object.keys(this.questionStats).length > 10 && Object.keys(cleanedStats).length < (Object.keys(this.questionStats).length / 2)) {
                console.warn("Migration safety triggered: Excessive stat cleanup prevented.");
            } else {
                this.questionStats = cleanedStats;
            }
        }

        this.isChecked = false;
        this.shuffledCache = {};

        if (modified) this.saveData();
        this.saveQuestionStats();
    }

    cacheDOM() {
        this.tabQuiz = document.getElementById('tab-quiz');
        this.tabStats = document.getElementById('tab-stats');
        this.quizView = document.getElementById('quiz-view');
        this.statsView = document.getElementById('stats-view');
        this.tocList = document.getElementById('toc-list');
        this.quizTitle = document.getElementById('quiz-title');
        this.tableHead = document.getElementById('table-head');
        this.tableBody = document.getElementById('table-body');
        this.scoreDisplay = document.getElementById('score');
        this.editModeToggle = document.getElementById('edit-mode-toggle');
        this.addFolderBtn = document.getElementById('add-folder-btn');
        this.addPageBtn = document.getElementById('add-page-btn');
        this.addClauseBtn = document.getElementById('add-clause-btn');
        this.addRowBtn = document.getElementById('add-row-btn');
        this.addColumnBtn = document.getElementById('add-column-btn');
        this.clearDataBtn = document.getElementById('clear-data-btn');
        this.deletePageBtn = document.getElementById('delete-page-btn');
        this.clonePageBtn = document.getElementById('clone-page-btn');
        this.checkAnswersBtn = document.getElementById('check-answers-btn');
        this.resetQuizBtn = document.getElementById('reset-quiz-btn');

        this.totalAccuracy = document.getElementById('total-accuracy');
        this.totalAnsweredDisplay = document.getElementById('total-answered');
        this.historyBody = document.getElementById('history-body');
        this.weakQuestionsBody = document.getElementById('weak-questions-body');
        this.genWeakBtn = document.getElementById('gen-weak-btn');
        this.genWeakClauseBtn = document.getElementById('gen-weak-clause-btn');
        this.genRareBtn = document.getElementById('gen-rare-btn');
        this.genRandomBtn = document.getElementById('gen-random-btn');
        this.genSRSClauseBtn = document.getElementById('gen-srs-clause-btn');
        this.genSRSPageBtn = document.getElementById('gen-srs-page-btn');
        this.sidebarGenSRSClauseBtn = document.getElementById('sidebar-gen-srs-clause-btn');
        this.sidebarGenSRSPageBtn = document.getElementById('sidebar-gen-srs-page-btn');

        this.chartBtns = {
            accuracy: document.getElementById('show-accuracy-btn'),
            frequency: document.getElementById('show-frequency-btn'),
            errors: document.getElementById('show-errors-btn')
        };
        this.sidebar = document.getElementById('sidebar');
        this.sidebarContent = document.getElementById('quiz-sidebar-content');
        this.menuToggle = document.getElementById('menu-toggle');

        // Data management
        this.exportJsonBtn = document.getElementById('export-json-btn');
        this.importJsonBtn = document.getElementById('import-json-btn');
        this.exportCsvBtn = document.getElementById('export-csv-btn');
        this.importCsvBtn = document.getElementById('import-csv-btn');
        this.dataImportInput = document.getElementById('data-import-input');
        this.dataStatusMsg = document.getElementById('data-status-msg');
        this.understandingMap = document.getElementById('understanding-map');
        this.srsModal = document.getElementById('srs-modal');
        this.srsInfo = document.getElementById('srs-info');
        this.srsModalTitle = document.getElementById('srs-modal-title');
        this.closeModalBtn = document.getElementById('close-modal');
        this.srsDetailChart = null;
        this.clauseEditor = document.getElementById('clause-editor');

        this.clauseTextEditor = document.getElementById('clause-text-editor');
        this.clauseDummiesEditor = document.getElementById('clause-dummies-editor');
        this.clauseDisplay = document.getElementById('clause-display');
        this.tableWrapper = document.querySelector('.table-wrapper');
        this.columnControls = document.querySelector('.column-controls');
        this.tableControls = document.querySelector('.table-controls');
        this.insertTableBtn = document.getElementById('insert-table-btn');
        this.clearPoolBtn = document.getElementById('clear-pool-btn');
    }

    bindEvents() {
        this.tabQuiz.addEventListener('click', () => this.switchView('quiz'));
        this.tabStats.addEventListener('click', () => this.switchView('stats'));
        if (this.clearPoolBtn) {
            this.clearPoolBtn.addEventListener('click', () => this.clearAllPoolSelections());
        }
        this.editModeToggle.addEventListener('change', (e) => {
            this.isEditMode = e.target.checked;
            document.body.classList.toggle('edit-mode', this.isEditMode);
            this.updateTitleEditability();
            this.resetQuiz(); this.renderTOC(); this.renderTable();
        });
        this.checkAnswersBtn.addEventListener('click', () => this.batchCheckAnswers());
        this.resetQuizBtn.addEventListener('click', () => this.resetQuiz());
        this.addFolderBtn.addEventListener('click', () => this.addNewFolder());
        this.addPageBtn.addEventListener('click', () => this.addNewPage());
        this.addClauseBtn.addEventListener('click', () => this.addNewClausePage());
        this.addRowBtn.addEventListener('click', () => this.addNewRow());
        this.addColumnBtn.addEventListener('click', () => this.addNewColumn());
        this.clearDataBtn.addEventListener('click', () => this.clearData());
        this.deletePageBtn.addEventListener('click', () => this.deleteCurrentPage());
        this.clonePageBtn.addEventListener('click', () => this.cloneCurrentPage());

        this.insertTableBtn.addEventListener('click', () => {
            const template = "\n| é …ç›® | å†…å®¹ | å‚™è€ƒ |\n| --- | --- | --- |\n| [[ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰1]] | å†…å®¹1 | å‚™è€ƒ1 |\n| [[ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰2]] | å†…å®¹2 | å‚™è€ƒ2 |\n";
            const start = this.clauseTextEditor.selectionStart;
            const end = this.clauseTextEditor.selectionEnd;
            const text = this.clauseTextEditor.value;
            this.clauseTextEditor.value = text.substring(0, start) + template + text.substring(end);
            this.clauseTextEditor.dispatchEvent(new Event('input')); // Trigger update
        });

        this.genWeakBtn.addEventListener('click', () => this.generateSpecialQuiz('weak'));
        if (this.genWeakClauseBtn) {
            this.genWeakClauseBtn.addEventListener('click', () => this.generateSpecialQuiz('clause-weak'));
        }
        this.genRareBtn.addEventListener('click', () => this.generateSpecialQuiz('rare'));
        if (this.genRandomBtn) this.genRandomBtn.addEventListener('click', () => this.generateSpecialQuiz('random'));
        if (this.genSRSClauseBtn) this.genSRSClauseBtn.addEventListener('click', () => this.generateSpecialQuiz('srs-clause'));
        if (this.genSRSPageBtn) this.genSRSPageBtn.addEventListener('click', () => this.generateSpecialQuiz('srs-page'));
        if (this.sidebarGenSRSClauseBtn) this.sidebarGenSRSClauseBtn.addEventListener('click', () => this.generateSpecialQuiz('srs-clause'));
        if (this.sidebarGenSRSPageBtn) this.sidebarGenSRSPageBtn.addEventListener('click', () => this.generateSpecialQuiz('srs-page'));

        Object.keys(this.chartBtns).forEach(mode => {
            this.chartBtns[mode].addEventListener('click', () => {
                this.chartMode = mode;
                this.updateChartTabs();
                this.renderChart();
            });
        });
        this.tocList.addEventListener('click', (e) => {
            if (e.target.tagName === 'A') {
                e.preventDefault();
                const id = e.target.getAttribute('href').substring(1);
                const item = this.quizData.find(s => s.id === id);
                if (item && item.type === 'folder') {
                    this.toggleFolder(id);
                } else if (item) {
                    this.isAutoGenerated = false;
                    this.currentSetId = id;
                    this.loadSet(id);
                }
            }
        });

        // Update TOC real-time when editing title
        this.quizTitle.addEventListener('input', () => {
            if (this.isEditMode && !this.isAutoGenerated) {
                const set = this.quizData.find(s => s.id === this.currentSetId);
                if (set) {
                    set.title = this.quizTitle.textContent.trim();
                    this.renderTOC();
                }
            }
        });

        this.quizTitle.addEventListener('blur', () => {
            if (this.isEditMode && !this.isAutoGenerated) {
                const set = this.quizData.find(s => s.id === this.currentSetId);
                if (set) {
                    set.title = this.quizTitle.textContent.trim();
                    this.saveData();
                }
            }
        });
        this.menuToggle.addEventListener('click', () => { this.sidebar.classList.toggle('open'); });

        // Data management events
        this.exportJsonBtn.addEventListener('click', () => this.exportToJSON());
        this.importJsonBtn.addEventListener('click', () => { this.dataImportInput.accept = '.json'; this.dataImportInput.click(); });
        this.exportCsvBtn.addEventListener('click', () => this.exportToCSV());
        this.importCsvBtn.addEventListener('click', () => { this.dataImportInput.accept = '.csv'; this.dataImportInput.click(); });
        this.dataImportInput.addEventListener('change', (e) => this.handleFileImport(e));

        // Recovery button for internal backup
        const forceRestoreBtn = document.getElementById('force-restore-internal-btn');
        if (forceRestoreBtn) {
            forceRestoreBtn.addEventListener('click', () => this.checkAndOfferRecovery(true));
        }
    }

    init() {
        this.renderTOC();
        this.loadSet(this.currentSetId);
        this.checkAndOfferRecovery();
        this.checkBackupFrequency();
    }

    loadData() { const saved = localStorage.getItem('sharoQuizData'); return saved ? JSON.parse(saved) : JSON.parse(JSON.stringify(DEFAULT_QUIZ_DATA)); }
    saveData() {
        const dataStr = JSON.stringify(this.quizData);
        localStorage.setItem('sharoQuizData', dataStr);
        // Internal Redundancy: Also save to a backup key
        localStorage.setItem('sharo_auto_backup', JSON.stringify({
            quizData: this.quizData,
            history: this.history,
            questionStats: this.questionStats,
            savedAt: new Date().toISOString()
        }));
    }
    loadHistory() { const saved = localStorage.getItem('sharoQuizHistory'); return saved ? JSON.parse(saved) : []; }
    saveHistory() { localStorage.setItem('sharoQuizHistory', JSON.stringify(this.history)); }
    loadQuestionStats() { const saved = localStorage.getItem('sharoQuestionStats'); return saved ? JSON.parse(saved) : {}; }
    saveQuestionStats() { localStorage.setItem('sharoQuestionStats', JSON.stringify(this.questionStats)); }

    updateSRS(stat, isCorrect) {
        if (!stat) return;
        if (stat.srsLevel === undefined) stat.srsLevel = 0;
        if (!stat.history) stat.history = [];

        // Record attempt
        stat.history.push({
            date: new Date().toISOString(),
            isCorrect: isCorrect,
            level: stat.srsLevel
        });
        if (stat.history.length > 20) stat.history.shift();

        if (isCorrect) {
            stat.srsLevel = Math.min(stat.srsLevel + 1, SRS_INTERVALS.length - 1);
        } else {
            // Drop 2 levels on mistake, but keep at least 0
            stat.srsLevel = Math.max(0, stat.srsLevel - 2);
        }

        const days = SRS_INTERVALS[stat.srsLevel];
        const nextDate = new Date();
        nextDate.setDate(nextDate.getDate() + days);
        // Reset to beginning of day for simpler comparison (optional, but good for "daily" review)
        nextDate.setHours(0, 0, 0, 0);
        stat.nextReview = nextDate.toISOString();
    }

    normalizeInput(str) {
        if (!str) return "";
        return str.trim().replace(/[ï¼-ï¼™]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
    }

    showSRSDetail(statKey) {
        const stat = this.questionStats[statKey];
        if (!stat) return;

        this.srsModal.classList.remove('hidden');
        this.srsModalTitle.textContent = `è¨˜æ†¶å®šç€ã®æ¨ç§»: ${stat.text.substring(0, 40)}${stat.text.length > 40 ? '...' : ''}`;

        const history = stat.history || [];
        const nextReview = stat.nextReview ? new Date(stat.nextReview) : null;

        const labels = history.map(h => new Date(h.date).toLocaleDateString());
        const data = history.map(h => h.level);

        if (nextReview) {
            labels.push(`${nextReview.toLocaleDateString()} (äºˆå®š)`);
            data.push(stat.srsLevel);
        }

        const ctx = document.getElementById('srsDetailChart').getContext('2d');
        if (this.srsDetailChart) this.srsDetailChart.destroy();

        this.srsDetailChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'å®šç€ãƒ¬ãƒ™ãƒ«',
                    data: data,
                    borderColor: '#4cc9f0',
                    backgroundColor: 'rgba(76, 201, 240, 0.2)',
                    fill: true,
                    tension: 0.3,
                    pointBackgroundColor: [
                        ...history.map(h => h.isCorrect ? '#4ade80' : '#f72585'),
                        '#ffd166'
                    ],
                    pointRadius: 6,
                    pointHoverRadius: 8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: 'rgba(255,255,255,0.6)' } },
                    y: {
                        beginAtZero: true,
                        max: SRS_INTERVALS.length,
                        grid: { color: 'rgba(255,255,255,0.05)' },
                        ticks: { color: 'rgba(255,255,255,0.6)', stepSize: 1 },
                        title: { display: true, text: 'ç¿’ç†Ÿåº¦ãƒ¬ãƒ™ãƒ«', color: 'rgba(255,255,255,0.8)' }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const idx = context.dataIndex;
                                if (idx < history.length) {
                                    return `ãƒ¬ãƒ™ãƒ«: ${context.raw} (${history[idx].isCorrect ? 'æ­£è§£' : 'ä¸æ­£è§£'})`;
                                }
                                return `æ¬¡å›äºˆå®šãƒ¬ãƒ™ãƒ«: ${context.raw}`;
                            }
                        }
                    }
                }
            }
        });

        this.srsInfo.innerHTML = `
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem; background: rgba(255,255,255,0.03); padding: 1.5rem; border-radius: 12px;">
                <div>
                    <p><strong>ç¾åœ¨ã®ç¿’ç†Ÿåº¦:</strong> Lv.${stat.srsLevel}</p>
                    <p><strong>å¾©ç¿’é–“éš”:</strong> ${SRS_INTERVALS[stat.srsLevel]} æ—¥</p>
                </div>
                <div>
                    <p><strong>æ¬¡å›ã®å¾©ç¿’äºˆå®š:</strong> ${nextReview ? nextReview.toLocaleDateString() : 'æœªå®š'}</p>
                    <p><strong>ç´¯è¨ˆæˆç¸¾:</strong> ${stat.correct}/${stat.total} (${Math.round((stat.correct / stat.total) * 100)}%)</p>
                </div>
            </div>
            <p style="margin-top: 1rem; opacity: 0.7; font-size: 0.8rem;">â€»ã‚°ãƒ©ãƒ•ä¸Šã®ç‚¹ã¯ <span style="color:#4ade80">â—</span> ãŒæ­£è§£ã€<span style="color:#f72585">â—</span> ãŒä¸æ­£è§£ã‚’è¡¨ã—ã¾ã™ã€‚</p>
        `;
    }


    switchView(view) {
        this.tabQuiz.classList.toggle('active', view === 'quiz');
        this.tabStats.classList.toggle('active', view === 'stats');
        this.quizView.classList.toggle('hidden', view !== 'quiz');
        this.statsView.classList.toggle('hidden', view !== 'stats');
        if (view === 'stats') this.renderStats();
    }

    loadSet(id) {
        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === id);
        if (!set || set.type === 'folder') return;

        this.currentSetId = id;
        this.quizTitle.textContent = set.title;
        this.updateTitleEditability();

        this.resetQuiz();
        this.renderTable();
        this.updateActiveTOC(id);
    }

    updateActiveTOC(id) {
        const tocLinks = this.tocList.querySelectorAll('a');
        tocLinks.forEach(a => {
            const isActive = !this.isAutoGenerated && a.getAttribute('href') === `#${id}`;
            a.classList.toggle('active', isActive);
        });
    }

    updateTitleEditability() {
        this.quizTitle.contentEditable = this.isEditMode && !this.isAutoGenerated;
    }

    resetQuiz() {
        this.userAnswers = {};
        this.isChecked = false;
        this.shuffledCache = {};
        this.scoreDisplay.textContent = "æ­£è§£æ•°: 0 / 0";
        this.renderTable();
    }

    batchCheckAnswers() {
        if (this.isChecked) return;
        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === this.currentSetId);
        let correctCount = 0; let answeredCount = 0;

        if (set.type === 'clause') {
            const keywordData = [];
            // Match both [[...]] and ((...)) in order
            const parts = set.text.split(/(\[\[.*?\]\]|\(\(.*?\)\))/g);
            parts.forEach(part => {
                if (part.startsWith('[[') && part.endsWith(']]')) {
                    keywordData.push({ text: part.substring(2, part.length - 2), type: 'drag' });
                } else if (part.startsWith('((') && part.endsWith('))')) {
                    keywordData.push({ text: part.substring(2, part.length - 2), type: 'input' });
                }
            });

            let allBlanksCorrect = true;
            keywordData.forEach((kwInfo, idx) => {
                const userAnswer = (this.userAnswers[`${set.id}-${idx}`] || "").toString();
                if (!userAnswer && kwInfo.type === 'drag') {
                    allBlanksCorrect = false;
                    return;
                }
                answeredCount++;

                const isCorrect = kwInfo.type === 'drag'
                    ? userAnswer === kwInfo.text
                    : this.normalizeInput(userAnswer) === this.normalizeInput(kwInfo.text);

                if (isCorrect) correctCount++;
                else allBlanksCorrect = false;

                // Detailed stat per blank
                const statKey = `clause-${set.id}-${idx}`;
                if (!this.questionStats[statKey]) {
                    this.questionStats[statKey] = { correct: 0, total: 0, recent: [], page: set.title, text: `ç©´åŸ‹ã‚: ${kwInfo.text}` };
                }
                const stat = this.questionStats[statKey];
                stat.total++;
                if (isCorrect) stat.correct++;
                if (!stat.recent) stat.recent = [];
                stat.recent.push(isCorrect ? 1 : 0);
                if (stat.recent.length > 5) stat.recent.shift();
                stat.text = `ç©´åŸ‹ã‚: ${kwInfo.text}`; stat.page = set.title;
            });

            // Summary stat for the whole clause
            // ... (rest remains same)


            // Summary stat for the whole clause
            const summaryKey = `clause-summary-${set.id}`;
            if (!this.questionStats[summaryKey]) {
                this.questionStats[summaryKey] = { correct: 0, total: 0, recent: [], page: set.title, text: `æ¡æ–‡å…¨ä½“: ${set.title}` };
            }
            const summaryStat = this.questionStats[summaryKey];
            summaryStat.total++;
            if (allBlanksCorrect) summaryStat.correct++;
            if (!summaryStat.recent) summaryStat.recent = [];
            summaryStat.recent.push(allBlanksCorrect ? 1 : 0);
            if (summaryStat.recent.length > 5) summaryStat.recent.shift();
            summaryStat.text = `æ¡æ–‡å…¨ä½“: ${set.title}`; summaryStat.page = set.title;
            this.updateSRS(summaryStat, allBlanksCorrect);
        } else {
            set.questions.forEach((q) => {
                let isCorrect = false;
                const userAnswer = this.userAnswers[q.id];

                // Treat any question with [[...]] or ((...)) as a clause/blank type
                if (q.type === 'clause' || /\[\[|ï¼»ï¼»|\(\(|ï¼ˆï¼ˆ/.test(q.text)) {
                    // For clause type in special quiz, count individual blanks
                    const keywordData = [];
                    const parts = q.text.split(/(\[\[.*?\]\]|ï¼»ï¼».*?ï¼½ï¼½|\(\(.*?\)\)|ï¼ˆï¼ˆ.*?ï¼‰ï¼‰)/g);
                    parts.forEach(part => {
                        if ((part.startsWith('[[') && part.endsWith(']]')) || (part.startsWith('ï¼»ï¼»') && part.endsWith('ï¼½ï¼½'))) {
                            keywordData.push({ text: part.substring(2, part.length - 2), type: 'drag' });
                        } else if ((part.startsWith('((') && part.endsWith('))')) || (part.startsWith('ï¼ˆï¼ˆ') && part.endsWith('ï¼‰ï¼‰'))) {
                            keywordData.push({ text: part.substring(2, part.length - 2), type: 'input' });
                        }
                    });

                    let rowCorrectBlanks = 0;
                    let rowAnsweredBlanks = 0;
                    keywordData.forEach((kwInfo, idx) => {
                        const val = this.userAnswers[`${q.id}-${idx}`];
                        if (val) {
                            rowAnsweredBlanks++;
                            const isKwCorrect = kwInfo.type === 'drag'
                                ? val === kwInfo.text
                                : this.normalizeInput(val) === this.normalizeInput(kwInfo.text);
                            if (isKwCorrect) rowCorrectBlanks++;
                        }
                    });

                    answeredCount += rowAnsweredBlanks;
                    correctCount += rowCorrectBlanks;
                    // For the overall row status/stat, consider it correct only if all blanks are correct
                    isCorrect = (keywordData.length > 0 && rowAnsweredBlanks === keywordData.length && rowCorrectBlanks === keywordData.length);
                } else {
                    if (!userAnswer || (Array.isArray(userAnswer) && userAnswer.length === 0)) return;
                    answeredCount++;

                    const isMulti = this.isAutoGenerated ? q.isMultiSelect : set.isMultiSelect;
                    if (isMulti) {
                        const correctSet = new Set(q.answer);
                        const userSet = new Set(userAnswer);
                        isCorrect = (correctSet.size === userSet.size && [...correctSet].every(item => userSet.has(item)));
                    } else {
                        isCorrect = userAnswer === q.answer;
                    }
                    if (isCorrect) correctCount++;
                }

                const statKey = q.type === 'clause' ? `clause-summary-${q.id}` : q.id;
                if (!this.questionStats[statKey]) {
                    this.questionStats[statKey] = {
                        correct: 0, total: 0, recent: [],
                        page: q.origPage || set.title,
                        text: q.type === 'clause' ? `æ¡æ–‡å…¨ä½“: ${q.title || set.title}` : q.text
                    };
                }
                const stat = this.questionStats[statKey];
                stat.total++;
                if (isCorrect) stat.correct++;
                if (!stat.recent) stat.recent = [];
                stat.recent.push(isCorrect ? 1 : 0);
                if (stat.recent.length > 5) stat.recent.shift();
                stat.text = q.type === 'clause' ? `æ¡æ–‡å…¨ä½“: ${q.origPage}` : q.text;
                stat.page = q.origPage || set.title;
                this.updateSRS(stat, isCorrect);
            });
        }

        this.isChecked = true;

        // Calculate total items correctly: sum of questions (standard) + sum of blanks (clause)
        let totalItems = 0;
        if (set.type === 'clause') {
            totalItems = (set.text.match(/\[\[/g) || []).length;
        } else {
            set.questions.forEach(q => {
                if (q.type === 'clause') {
                    totalItems += (q.text.match(/\[\[/g) || []).length;
                } else {
                    totalItems++;
                }
            });
        }

        this.scoreDisplay.textContent = `æ­£è§£æ•°: ${correctCount} / ${answeredCount} (åˆè¨ˆ: ${totalItems})`;
        this.history.unshift({
            timestamp: new Date().toLocaleString(),
            page: set.title,
            score: `${correctCount} / ${answeredCount}`,
            accuracy: answeredCount > 0 ? Math.round((correctCount / answeredCount) * 100) : 0
        });
        if (this.history.length > 50) this.history.pop();
        this.saveHistory(); this.saveQuestionStats(); this.renderTable();
    }

    renderStats() {
        if (this.history.length === 0) {
            this.totalAccuracy.textContent = "0%"; this.totalAnsweredDisplay.textContent = "0";
            this.historyBody.innerHTML = '<tr><td colspan="4">å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</td></tr>';
            this.weakQuestionsBody.innerHTML = '<tr><td colspan="4">ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</td></tr>';
            return;
        }

        // å…¨ä½“ã®æ­£ç­”ç‡ã¨ç·è§£ç­”æ•°ã‚’ã€å±¥æ­´ï¼ˆä¸Šé™50ä»¶ï¼‰ã§ã¯ãªãå„å•é¡Œã®çµ±è¨ˆã‹ã‚‰ç®—å‡ºã™ã‚‹ã‚ˆã†ã«å¤‰æ›´
        const allStatsValues = Object.values(this.questionStats);
        const totalCorrect = allStatsValues.reduce((sum, s) => sum + (s.correct || 0), 0);
        const totalTotal = allStatsValues.reduce((sum, s) => sum + (s.total || 0), 0);
        const avg = totalTotal > 0 ? Math.round((totalCorrect / totalTotal) * 100) : 0;

        this.totalAccuracy.textContent = `${avg}%`;
        this.totalAnsweredDisplay.textContent = totalTotal;

        this.historyBody.innerHTML = this.history.map(h => `<tr><td>${h.timestamp}</td><td>${h.page}</td><td>${h.score}</td><td>${h.accuracy}%</td></tr>`).join('');

        const statsArray = Object.values(this.questionStats).map(s => {
            const recent = s.recent || [];
            const rTotal = recent.length;
            const rCorrect = recent.reduce((a, b) => a + b, 0);
            const accuracy = rTotal > 0 ? Math.round((rCorrect / rTotal) * 100) : 0;
            return { ...s, accuracy, rTotal, rCorrect };
        }).filter(s => s.total > 0).sort((a, b) => {
            if (a.accuracy !== b.accuracy) return a.accuracy - b.accuracy;
            return a.total - b.total;
        }).slice(0, 10);

        this.weakQuestionsBody.innerHTML = statsArray.map(s => `<tr><td style="text-align: left;">${s.text} <span class="history-icon-btn" onclick="app.showSRSDetail('${s.id}')" title="è¨˜æ†¶å®šç€ã®æ¨ç§»ã‚’è¦‹ã‚‹">ğŸ“ˆ</span></td><td>${s.page}</td><td>${s.total}</td><td style="color: ${s.accuracy < 50 ? 'var(--error)' : 'var(--text-primary)'}">${s.accuracy}%</td></tr>`).join('');
        this.updateChartTabs(); this.renderChart();
        this.renderUnderstandingMap();
    }

    updateChartTabs() { Object.keys(this.chartBtns).forEach(mode => { this.chartBtns[mode].classList.toggle('active', this.chartMode === mode); }); }

    renderUnderstandingMap() {
        if (!this.understandingMap) return;
        this.understandingMap.innerHTML = '';

        const allQuestions = [];
        this.quizData.forEach(set => {
            if (set.type === 'page' && set.questions) {
                set.questions.forEach(q => {
                    const stat = this.questionStats[q.id] || { correct: 0, total: 0, recent: [] };
                    const recent = stat.recent || [];
                    const rTotal = recent.length;
                    const rCorrect = recent.reduce((a, b) => a + b, 0);
                    const accuracy = recent.length > 0 ? Math.round((recent.reduce((a, b) => a + b, 0) / recent.length) * 100) : -1;
                    const nextReview = stat.nextReview ? new Date(stat.nextReview).toLocaleDateString() : 'æœªå®š';

                    allQuestions.push({
                        id: q.id,
                        type: 'page',
                        text: q.text,
                        page: set.title,
                        accuracy: accuracy,
                        total: stat.total,
                        srsLevel: stat.srsLevel || 0,
                        nextReview: nextReview,
                        pageId: set.id
                    });
                });
            } else if (set.type === 'clause' && set.text) {
                const statKey = `clause-summary-${set.id}`;
                const stat = this.questionStats[statKey] || { correct: 0, total: 0, recent: [] };
                const recent = stat.recent || [];
                const accuracy = recent.length > 0 ? Math.round((recent.reduce((a, b) => a + b, 0) / recent.length) * 100) : -1;
                const nextReview = stat.nextReview ? new Date(stat.nextReview).toLocaleDateString() : 'æœªå®š';

                allQuestions.push({
                    id: set.id,
                    type: 'clause',
                    text: `æ¡æ–‡æš—è¨˜: ${set.title}`,
                    page: set.title,
                    accuracy: accuracy,
                    total: stat.total,
                    srsLevel: stat.srsLevel || 0,
                    nextReview: nextReview,
                    pageId: set.id
                });

            }
        });

        allQuestions.forEach(q => {
            const cell = document.createElement('div');
            cell.className = 'map-cell';

            let bgColor = 'rgba(255, 255, 255, 0.1)'; // æœªå­¦ç¿’
            if (q.accuracy !== -1) {
                // Determine 10% step (0, 10, 20... 100)
                const step = Math.floor(q.accuracy / 10) * 10;
                // Map 0-100 to HSL hue 0-120 (Red to Green)
                const hue = (step * 1.2);
                bgColor = `hsl(${hue}, 70%, 50%)`;
            }

            cell.style.backgroundColor = bgColor;
            cell.setAttribute('data-tooltip', `ã€${q.page}ã€‘\n${q.text}\næ­£ç­”ç‡: ${q.accuracy === -1 ? 'æœªè§£ç­”' : q.accuracy + '%'}\nç¿’ç†Ÿåº¦: Lv.${q.srsLevel} / æ¬¡å›äºˆå®š: ${q.nextReview}`);

            cell.onclick = () => {
                if (q.pageId) {
                    this.switchView('quiz');
                    this.loadSet(q.pageId);
                    if (q.type === 'page') {
                        setTimeout(() => {
                            const row = document.getElementById(`row-${q.id}`);
                            if (row) row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }, 100);
                    }
                }
            };

            this.understandingMap.appendChild(cell);
        });
    }

    renderClauseView(set) {
        this.clauseEditor.classList.remove('hidden'); // Ensure it's not logically blocked
        this.clauseEditor.classList.toggle('hidden-quiz', !this.isEditMode);
        this.clauseDisplay.classList.remove('hidden');
        this.tableWrapper.classList.add('hidden');
        this.columnControls.classList.add('hidden');
        this.tableControls.classList.add('hidden');

        this.clauseDisplay.innerHTML = '';

        if (this.isEditMode) {
            // Only set value if not focused to avoid cursor jumping and blocking delimiters like commas
            if (document.activeElement !== this.clauseTextEditor) {
                this.clauseTextEditor.value = set.text || '';
            }
            if (document.activeElement !== this.clauseDummiesEditor) {
                this.clauseDummiesEditor.value = (set.dummies || []).join(', ');
            }

            this.clauseTextEditor.oninput = () => {
                set.text = this.clauseTextEditor.value;
                this.saveData();
                this.renderClauseView(set);
            };
            this.clauseDummiesEditor.oninput = () => {
                // We split by both full-width and half-width commas
                set.dummies = this.clauseDummiesEditor.value.split(/[ï¼Œ,]/).map(s => s.trim()).filter(s => s);
                this.saveData();
                this.renderClauseView(set);
            };
        }

        const container = document.createElement('div');
        container.className = 'clause-container';

        const clauseText = document.createElement('div');
        clauseText.className = 'clause-text';

        // Render clause content (with table support)
        let htmlContent = set.text;
        const lines = set.text.split('\n');
        const hasTable = lines.some(l => l.trim().startsWith('|'));

        if (hasTable) {
            let processedHtml = '';
            let tableLines = [];

            lines.forEach(line => {
                if (line.trim().startsWith('|')) {
                    tableLines.push(line);
                } else {
                    if (tableLines.length > 0) {
                        processedHtml += this.renderTableFromMarkdown(tableLines);
                        tableLines = [];
                    }
                    processedHtml += line + '<br>';
                }
            });
            if (tableLines.length > 0) {
                processedHtml += this.renderTableFromMarkdown(tableLines);
            }
            htmlContent = processedHtml;
        } else {
            htmlContent = set.text.replace(/\n/g, '<br>');
        }
        const keywords = [];
        let blankIndex = 0;

        // Use placeholder strategy for blanks to work inside any HTML (like tables)
        // Combine [[...]], ï¼»ï¼»...ï¼½ï¼½ (drag) and ((...)), ï¼ˆï¼ˆ...ï¼‰ï¼‰ (input) support
        const finalHtml = htmlContent.replace(/\[\[(.*?)\]\]|ï¼»ï¼»(.*?)ï¼½ï¼½|\(\((.*?)\)\)|ï¼ˆï¼ˆ(.*?)ï¼‰ï¼‰/g, (match, p1, p2, p3, p4) => {
            const keyword = p1 || p2 || p3 || p4;
            const type = (p1 || p2) ? 'drag' : 'input';
            keywords.push({ text: keyword, type: type });
            return `<span id="placeholder-${blankIndex++}"></span>`;
        });

        clauseText.innerHTML = finalHtml;

        // Replace placeholders with real interactive blanks
        for (let i = 0; i < blankIndex; i++) {
            const placeholder = clauseText.querySelector(`#placeholder-${i}`);
            if (!placeholder) continue;

            const kwInfo = keywords[i];
            const currentIdx = i;

            if (kwInfo.type === 'drag') {
                const blank = document.createElement('div');
                blank.className = 'clause-blank';
                blank.id = `blank-${currentIdx}`;

                const savedAnswer = this.userAnswers[`${set.id}-${currentIdx}`];
                if (savedAnswer) {
                    blank.textContent = savedAnswer;
                    blank.classList.add('filled');
                } else {
                    blank.innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';
                }

                if (!this.isChecked) {
                    blank.ondragover = (e) => { e.preventDefault(); blank.classList.add('drag-over'); };
                    blank.ondragleave = () => blank.classList.remove('drag-over');
                    blank.ondrop = (e) => {
                        e.preventDefault();
                        blank.classList.remove('drag-over');
                        const text = e.dataTransfer.getData('text/plain');
                        if (text) { this.userAnswers[`${set.id}-${currentIdx}`] = text; this.renderClauseView(set); }
                    };
                    blank.onclick = () => { delete this.userAnswers[`${set.id}-${currentIdx}`]; this.renderClauseView(set); };
                } else {
                    const isCorrect = savedAnswer === kwInfo.text;
                    blank.classList.add(isCorrect ? 'correct' : 'wrong');
                    if (!isCorrect) {
                        const reveal = document.createElement('span');
                        reveal.className = 'reveal-correct';
                        reveal.textContent = ` (${kwInfo.text})`;
                        blank.appendChild(reveal);
                    }
                }
                placeholder.replaceWith(blank);
            } else {
                // Input type
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'clause-input-blank';
                input.id = `input-${currentIdx}`;

                const savedAnswer = this.userAnswers[`${set.id}-${currentIdx}`] || '';
                input.value = savedAnswer;

                if (!this.isChecked) {
                    input.oninput = () => {
                        this.userAnswers[`${set.id}-${currentIdx}`] = input.value;
                    };
                } else {
                    input.disabled = true;
                    const isCorrect = this.normalizeInput(savedAnswer) === this.normalizeInput(kwInfo.text);
                    input.classList.add(isCorrect ? 'correct' : 'wrong');
                    if (!isCorrect) {
                        const tip = document.createElement('span');
                        tip.className = 'reveal-correct';
                        tip.textContent = ` (${kwInfo.text})`;
                        placeholder.parentNode.insertBefore(tip, placeholder.nextSibling);
                    }
                }
                placeholder.replaceWith(input);
            }
        }

        container.appendChild(clauseText);
        this.clauseDisplay.appendChild(container);

        // Keyword Bank
        if (!this.isChecked) {
            const bank = document.createElement('div');
            bank.className = 'keyword-bank';

            // Count how many times each drag-type keyword is required
            const requiredCounts = {};
            const dragKeywords = keywords.filter(kw => kw.type === 'drag').map(kw => kw.text);
            dragKeywords.forEach(text => {
                requiredCounts[text] = (requiredCounts[text] || 0) + 1;
            });

            const allOptions = [...new Set([...dragKeywords, ...(set.dummies || [])])];

            // Use cached shuffle or create new
            if (!this.shuffledCache[set.id]) {
                this.shuffledCache[set.id] = allOptions.sort(() => Math.random() - 0.5);
            }
            const shuffled = this.shuffledCache[set.id];

            // Track how many times each word is used in current answers
            const usedCounts = {};
            Object.keys(this.userAnswers).forEach(key => {
                if (key.startsWith(`${set.id}-`)) {
                    const ans = this.userAnswers[key];
                    usedCounts[ans] = (usedCounts[ans] || 0) + 1;
                }
            });

            shuffled.forEach(word => {
                const req = requiredCounts[word] || 0;
                const used = usedCounts[word] || 0;
                // If it's a dummy or required only once, the logic remains simple.
                // If it's required multiple times, only hide if used >= required.
                const isUsed = req > 0 ? (used >= req) : (used > 0);

                const card = document.createElement('div');
                card.className = `keyword-card ${isUsed ? 'used' : ''}`;

                if (req > 1 && !isUsed) {
                    card.innerHTML = `${word} <span class="keyword-count-badge">${req - used}</span>`;
                } else {
                    card.textContent = word;
                }

                card.draggable = !isUsed;

                card.ondragstart = (e) => {
                    if (isUsed) return;
                    e.dataTransfer.setData('text/plain', word);
                    card.classList.add('dragging');
                };
                card.ondragend = () => card.classList.remove('dragging');

                bank.appendChild(card);
            });
            this.clauseDisplay.appendChild(bank);
        }
    }

    renderTableFromMarkdown(lines) {
        let tableHtml = '<div class="table-wrapper"><table>';
        lines.forEach((line, idx) => {
            const cells = line.split('|').map(c => c.trim()).filter((c, i, arr) => i > 0 && i < arr.length - 1);
            if (cells.length === 0) return;
            const tag = (idx === 0) ? 'th' : 'td';

            tableHtml += '<tr>';
            cells.forEach(cell => {
                let content = cell.replace(/_br_/g, '<br>');
                let style = '';

                // Parse {width} for headers
                if (idx === 0) {
                    const widthMatch = content.match(/\{(.*?)\}/);
                    if (widthMatch) {
                        style = ` style="width: ${widthMatch[1]}; min-width: ${widthMatch[1]};"`;
                        content = content.replace(widthMatch[0], '');
                    }
                }

                tableHtml += `<${tag}${style}>${content}</${tag}>`;
            });
            tableHtml += '</tr>';
        });
        tableHtml += '</table></div>';
        return tableHtml;
    }

    renderChart() {
        const ctx = document.getElementById('statsChart').getContext('2d');
        if (this.statsChart) this.statsChart.destroy();
        const allStats = Object.values(this.questionStats).filter(s => s.total > 0).map(s => {
            const recent = s.recent || [];
            const rTotal = recent.length;
            const rCorrect = recent.reduce((a, b) => a + b, 0);
            const accuracy = rTotal > 0 ? Math.round((rCorrect / rTotal) * 100) : 0;
            const errors = rTotal - rCorrect;
            return { ...s, accuracy, errors, rTotal, rCorrect };
        });
        let sortedStats, data, label, color;
        if (this.chartMode === 'accuracy') { sortedStats = allStats.sort((a, b) => a.accuracy - b.accuracy).slice(0, 10); data = sortedStats.map(s => s.accuracy); label = 'æ­£ç­”ç‡ (%)'; color = '#4cc9f0'; }
        else if (this.chartMode === 'frequency') { sortedStats = allStats.sort((a, b) => b.total - a.total).slice(0, 10); data = sortedStats.map(s => s.total); label = 'è§£ç­”å›æ•° (å›)'; color = '#f72585'; }
        else { sortedStats = allStats.sort((a, b) => b.errors - a.errors).slice(0, 10); data = sortedStats.map(s => s.errors); label = 'æœ€è¿‘ã®èª¤ç­”å›æ•° (å›/5å›ä¸­)'; color = '#ff9f1c'; }
        const labels = sortedStats.map(s => s.text.length > 8 ? s.text.substring(0, 7) + '...' : s.text);
        this.statsChart = new Chart(ctx, {
            type: 'bar', data: { labels: labels, datasets: [{ label: label, data: data, backgroundColor: color + 'dd', borderColor: color, borderWidth: 1, borderRadius: 8 }] },
            options: { responsive: true, maintainAspectRatio: false, indexAxis: 'y', plugins: { legend: { display: false }, tooltip: { callbacks: { title: (items) => sortedStats[items[0].dataIndex].text, label: (item) => `${label}: ${item.raw}` } } }, scales: { x: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: 'rgba(255,255,255,0.6)' } }, y: { grid: { display: false }, ticks: { color: 'rgba(255,255,255,0.8)', font: { size: 12 } } } } }
        });
    }

    generateSpecialQuiz(type) {
        const allQuestions = [];
        let maxCols = 2;
        let bestCols = ["é …ç›®", "é¸æŠè‚¢"];

        this.quizData.forEach(set => {
            if (!this.isItemSelectedForPool(set.id)) return;

            const isSrs = type.startsWith('srs');
            const targetType = isSrs ? type.split('-')[1] : null; // 'clause' or 'page'

            if (set.type === 'page' && set.questions && type !== 'clause-weak') {
                if (isSrs && targetType !== 'page') return;

                if (set.columns && set.columns.length > maxCols) {
                    maxCols = set.columns.length;
                    bestCols = [...set.columns];
                }
                set.questions.forEach(q => {
                    if (q.isInPool === false) return;
                    const stat = this.questionStats[q.id] || { correct: 0, total: 0, recent: [] };
                    const recent = stat.recent || [];
                    const accuracy = recent.length > 0 ? (recent.reduce((a, b) => a + b, 0) / recent.length) : -1;

                    allQuestions.push({
                        id: q.id,
                        type: 'page',
                        text: q.text,
                        answer: q.answer,
                        memo: q.memo || '',
                        origPage: set.title,
                        columns: set.columns,
                        accuracy: accuracy,
                        total: stat.total,
                        nextReview: stat.nextReview,
                        isMultiSelect: set.isMultiSelect
                    });
                });
            } else if (set.type === 'clause' && set.text) {
                if (type !== 'clause-weak' && !isSrs && type !== 'rare' && type !== 'random') return;
                if (isSrs && targetType !== 'clause') return;

                const statKey = `clause-summary-${set.id}`;
                const stat = this.questionStats[statKey] || { correct: 0, total: 0, recent: [] };
                const recent = stat.recent || [];
                const accuracy = recent.length > 0 ? (recent.reduce((a, b) => a + b, 0) / recent.length) : -1;

                allQuestions.push({
                    id: set.id,
                    type: 'clause',
                    text: set.text,
                    dummies: set.dummies,
                    origPage: set.title,
                    accuracy: accuracy,
                    total: stat.total,
                    nextReview: stat.nextReview,
                    isMultiSelect: false
                });
            }
        });

        if (allQuestions.length === 0) {
            alert('ç‰¹è¨“ã®å¯¾è±¡ã¨ãªã‚‹å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’å…¥ã‚Œã¦å¯¾è±¡ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
            return;
        }

        let filtered, title;
        if (type === 'weak') {
            title = "ç‰¹è¨“ï¼šè‹¦æ‰‹ãªå•é¡Œãƒ¯ãƒ¼ã‚¹ãƒˆ10";
            // Get all questions with errors, sort by accuracy
            const candidates = allQuestions.filter(q => q.total > 0).sort((a, b) => a.accuracy - b.accuracy);
            if (candidates.length === 0) {
                alert('ã¾ã é–“é•ãˆãŸè¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã¾ãšã¯æ™®é€šã«å­¦ç¿’ã—ã¦å›ç­”ã‚’è¨˜éŒ²ã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            // Pick from the top 20 worst questions and shuffle for variety
            filtered = candidates.slice(0, 20).sort(() => Math.random() - 0.5).slice(0, 10);
        } else if (type === 'clause-weak') {
            title = "ç‰¹è¨“ï¼šè‹¦æ‰‹ãªæ¡æ–‡ãƒ¯ãƒ¼ã‚¹ãƒˆ3";
            const candidates = allQuestions.filter(q => q.total > 0).sort((a, b) => a.accuracy - b.accuracy);
            if (candidates.length === 0) {
                alert('ã¾ã é–“é•ãˆãŸè¨˜éŒ²ã®ã‚ã‚‹æ¡æ–‡ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã¾ãšã¯å„ãƒšãƒ¼ã‚¸ã‹ã‚‰æ¡æ–‡æš—è¨˜ã«å–ã‚Šçµ„ã‚“ã§ãã ã•ã„ã€‚');
                return;
            }
            // Pick from the top 10 worst clauses and shuffle for variety
            filtered = candidates.slice(0, 10).sort(() => Math.random() - 0.5).slice(0, 3);
        } else if (type.startsWith('srs')) {
            const mode = type.split('-')[1];
            title = mode === 'clause' ? "ç‰¹è¨“ï¼šå¿˜å´æ›²ç·šï¼ˆæ¡æ–‡ç©´åŸ‹ã‚ï¼‰" : "ç‰¹è¨“ï¼šå¿˜å´æ›²ç·šï¼ˆé¸æŠå¼ï¼‰";
            const now = new Date();
            filtered = allQuestions.filter(q => {
                if (!q.nextReview) return true;
                return new Date(q.nextReview) <= now;
            });
            if (filtered.length === 0) {
                alert('ç¾åœ¨ã€å¾©ç¿’ãŒå¿…è¦ãªå•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ç´ æ™´ã‚‰ã—ã„ã§ã™ã­ï¼');
                return;
            }
            // Shuffle and limit
            filtered = filtered.sort(() => Math.random() - 0.5).slice(0, 15);
        } else if (type === 'random') {
            title = "ç‰¹è¨“ï¼šå…¨å•é¡Œã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ 10å•";
            filtered = allQuestions.sort(() => Math.random() - 0.5).slice(0, 10);
        } else {
            title = "ç‰¹è¨“ï¼šæœªå­¦ç¿’ãƒ»ä½é »åº¦ãªå•é¡Œ10å•";
            filtered = allQuestions.sort((a, b) => {
                if (a.total !== b.total) return a.total - b.total;
                return a.accuracy - b.accuracy;
            }).slice(0, 10);
        }

        // Recalculate optimal columns - use UNION of all columns to ensure compatibility
        let finalBestCols = ["é …ç›®"];
        const colSet = new Set();
        filtered.forEach(q => {
            if (q.type === 'page' && q.columns) {
                // Skip the first column 'é …ç›®' which we already added
                for (let i = 1; i < q.columns.length; i++) {
                    colSet.add(q.columns[i]);
                }
            }
        });
        if (colSet.size > 0) {
            finalBestCols = ["é …ç›®", ...Array.from(colSet)];
        } else if (filtered.every(q => q.type === 'clause')) {
            finalBestCols = ["æ¡æ–‡å†…å®¹"];
        } else {
            finalBestCols = ["é …ç›®", "é¸æŠè‚¢"];
        }
        bestCols = finalBestCols;

        this.autoGeneratedSet = {
            id: 'temp-autogen',
            title: title,
            questions: filtered,
            columns: bestCols
        };
        this.isAutoGenerated = true;
        this.switchView('quiz');
        this.loadSet('temp-autogen');
    }

    renderTable() {
        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === this.currentSetId);

        // Hide delete/clone buttons for folders or when no set is selected or in auto-generated mode
        const isFolder = !set || set.type === 'folder' || this.isAutoGenerated;
        if (this.deletePageBtn) this.deletePageBtn.classList.toggle('hidden', isFolder);
        if (this.clonePageBtn) this.clonePageBtn.classList.toggle('hidden', isFolder);

        if (!set || set.type === 'folder') {
            this.tableBody.innerHTML = '';
            this.tableHead.innerHTML = '';
            this.quizTitle.textContent = set ? set.title : 'å•é¡Œã‚’é¸æŠã—ã¦ãã ã•ã„';
            if (this.clauseEditor) this.clauseEditor.classList.add('hidden');
            if (this.clauseDisplay) this.clauseDisplay.classList.add('hidden');
            return;
        }

        if (set.type === 'clause' && !this.isAutoGenerated) {
            this.renderClauseView(set);
            return;
        } else {
            this.clauseEditor.classList.add('hidden');
            this.clauseEditor.classList.add('hidden-quiz');
            this.clauseDisplay.classList.add('hidden');
            this.clauseDisplay.innerHTML = '';
            this.tableWrapper.classList.remove('hidden');
            if (this.columnControls) this.columnControls.classList.toggle('hidden', !this.isEditMode);
            if (this.tableControls) this.tableControls.classList.toggle('hidden', !this.isEditMode);
        }

        this.tableWrapper.innerHTML = '';

        if (this.isAutoGenerated) {
            // Group questions by their original column structure to avoid cross-page noise
            const groups = [];
            set.questions.forEach(q => {
                // Clause types in auto-gen are always their own block
                if (q.type === 'clause') {
                    groups.push({ type: 'clause', questions: [q], columns: ["æ¡æ–‡å†…å®¹"] });
                    return;
                }

                const colKey = q.columns ? q.columns.join('|') : 'default';
                let g = groups.find(it => it.type === 'page' && it.key === colKey);
                if (!g) {
                    g = { type: 'page', key: colKey, questions: [], columns: q.columns || ["é …ç›®", "é¸æŠè‚¢"] };
                    groups.push(g);
                }
                g.questions.push(q);
            });

            groups.forEach(g => {
                const table = document.createElement('table');
                table.className = 'quiz-table auto-gen-table';
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');
                table.appendChild(thead);
                table.appendChild(tbody);
                this.tableWrapper.appendChild(table);
                this.renderTableContent(g.columns, g.questions, thead, tbody, true);
            });
            this.quizTitle.textContent = set.title;
        } else {
            const table = document.createElement('table');
            table.id = 'quiz-table';
            const thead = document.createElement('thead'); thead.id = 'table-head';
            const tbody = document.createElement('tbody'); tbody.id = 'table-body';
            table.appendChild(thead);
            table.appendChild(tbody);
            this.tableWrapper.appendChild(table);
            this.tableHead = thead;
            this.tableBody = tbody;
            this.renderTableContent(set.columns, set.questions, thead, tbody, false);
            this.quizTitle.textContent = set.title;
        }
    }

    renderTableContent(columns, questions, thead, tbody, isAuto) {
        const headTr = document.createElement('tr');
        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === this.currentSetId);

        // Header Rendering
        if (isAuto) {
            columns.forEach(col => {
                const th = document.createElement('th');
                th.textContent = col.replace(/\{.*?\}/, '');
                const widthMatch = col.match(/\{(.*?)\}/);
                if (widthMatch) { th.style.width = widthMatch[1]; th.style.minWidth = widthMatch[1]; }
                headTr.appendChild(th);
            });
        } else {
            if (this.isEditMode) {
                const thPool = document.createElement('th');
                thPool.innerHTML = 'ç‰¹è¨“'; thPool.className = 'pool-cell';
                headTr.appendChild(thPool);
            }
            columns.forEach((col, index) => {
                const th = document.createElement('th');
                let displayLabel = col;
                const widthMatch = col.match(/\{(.*?)\}/);
                if (widthMatch) { th.style.width = widthMatch[1]; th.style.minWidth = widthMatch[1]; displayLabel = col.replace(widthMatch[0], ''); }
                const span = document.createElement('span');
                span.className = 'col-label-edit'; span.textContent = displayLabel;
                if (this.isEditMode) {
                    span.contentEditable = true;
                    span.onblur = () => {
                        const widthMatch = col.match(/\{.*?\}/);
                        const widthSpec = widthMatch ? widthMatch[0] : '';
                        let newVal = span.textContent.trim();
                        if (widthSpec && !newVal.includes('{')) newVal += widthSpec;
                        if (col !== newVal) {
                            const oldDisplay = col.replace(/\{.*?\}/, '').trim();
                            const newDisplay = newVal.replace(/\{.*?\}/, '').trim();
                            columns[index] = newVal;
                            questions.forEach(q => {
                                if (Array.isArray(q.answer)) q.answer = q.answer.map(a => a === oldDisplay ? newDisplay : a);
                                else if (q.answer === oldDisplay) q.answer = newDisplay;
                            });
                            this.saveData(); this.renderTable();
                        }
                    };
                }
                th.appendChild(span);
                if (this.isEditMode && index > 0) {
                    const delBtn = document.createElement('span'); delBtn.className = 'delete-col-btn'; delBtn.innerHTML = 'Ã—';
                    delBtn.onclick = (e) => { e.stopPropagation(); this.deleteColumn(index); };
                    th.appendChild(delBtn);
                }
                headTr.appendChild(th);
            });
        }
        thead.appendChild(headTr);

        // Rows Rendering
        questions.forEach((q) => {
            const tr = document.createElement('tr'); tr.id = `row-${q.id}`;
            const isQMulti = isAuto ? q.isMultiSelect : set.isMultiSelect;

            if (this.isChecked) {
                const userAnswer = this.userAnswers[q.id];
                if (userAnswer && (!Array.isArray(userAnswer) || userAnswer.length > 0)) {
                    let isAllCorrect = false;
                    if (isQMulti) {
                        const correctSet = new Set(q.answer); const userSet = new Set(userAnswer);
                        isAllCorrect = (correctSet.size === userSet.size && [...correctSet].every(item => userSet.has(item)));
                    } else { isAllCorrect = userAnswer === q.answer; }
                    tr.classList.add(isAllCorrect ? 'row-correct' : 'row-wrong');
                }
            }

            // Pool inclusion checkbox cell (REQUIRED FOR ALIGNMENT in edit mode)
            if (!isAuto && this.isEditMode) {
                const tdPool = document.createElement('td');
                tdPool.className = 'pool-cell';
                const poolCheck = document.createElement('input');
                poolCheck.type = 'checkbox';
                poolCheck.checked = q.isInPool !== false;
                poolCheck.onchange = (e) => {
                    q.isInPool = e.target.checked;
                    this.saveData();
                };
                tdPool.appendChild(poolCheck);
                tr.appendChild(tdPool);
            }

            const tdQ = document.createElement('td'); tdQ.className = 'question-cell';

            // Treat any question with [[...]] or ((...)) (including full-width) as a clause/blank type
            if (q.type === 'clause' || /\[\[|ï¼»ï¼»|\(\(|ï¼ˆï¼ˆ/.test(q.text)) {
                const wrapper = document.createElement('div'); wrapper.className = 'table-clause-wrapper';
                const badge = document.createElement('span'); badge.className = 'clause-badge'; badge.textContent = q.origPage || "æ¡æ–‡";
                wrapper.appendChild(badge);

                const cText = document.createElement('div'); cText.className = 'clause-text-mini';
                let htmlContent = q.text;
                const lines = q.text.split('\n');
                const hasTable = lines.some(l => l.trim().startsWith('|'));
                if (hasTable) {
                    let processedHtml = ''; let tableLines = [];
                    lines.forEach(line => {
                        if (line.trim().startsWith('|')) tableLines.push(line);
                        else {
                            if (tableLines.length > 0) { processedHtml += this.renderTableFromMarkdown(tableLines); tableLines = []; }
                            processedHtml += line + '<br>';
                        }
                    });
                    if (tableLines.length > 0) processedHtml += this.renderTableFromMarkdown(tableLines);
                    htmlContent = processedHtml;
                } else { htmlContent = q.text.replace(/\n/g, '<br>'); }

                const rowKeywords = []; let blankIdx = 0;
                // Combined drag/input support (including full-width)
                const finalHtml = htmlContent.replace(/\[\[(.*?)\]\]|ï¼»ï¼»(.*?)ï¼½ï¼½|\(\((.*?)\)\)|ï¼ˆï¼ˆ(.*?)ï¼‰ï¼‰/g, (match, p1, p2, p3, p4) => {
                    const keyword = p1 || p2 || p3 || p4;
                    const type = (p1 || p2) ? 'drag' : 'input';
                    rowKeywords.push({ text: keyword, type: type });
                    return `<span id="placeholder-${q.id}-${blankIdx++}"></span>`;
                });
                cText.innerHTML = finalHtml;

                for (let i = 0; i < blankIdx; i++) {
                    const placeholder = cText.querySelector(`#placeholder-${q.id}-${i}`);
                    if (!placeholder) continue;
                    const kwInfo = rowKeywords[i];
                    const currentBlankIdx = i;

                    if (kwInfo.type === 'drag') {
                        const blank = document.createElement('div'); blank.className = 'clause-blank';
                        const savedAnswer = this.userAnswers[`${q.id}-${currentBlankIdx}`];
                        if (savedAnswer) { blank.textContent = savedAnswer; blank.classList.add('filled'); }
                        else { blank.innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;'; }

                        if (!this.isChecked) {
                            blank.ondragover = (e) => { e.preventDefault(); blank.classList.add('drag-over'); };
                            blank.ondragleave = () => blank.classList.remove('drag-over');
                            blank.ondrop = (e) => {
                                e.preventDefault(); blank.classList.remove('drag-over');
                                const text = e.dataTransfer.getData('text/plain');
                                if (text) { this.userAnswers[`${q.id}-${currentBlankIdx}`] = text; this.renderTable(); }
                            };
                            blank.onclick = () => { delete this.userAnswers[`${q.id}-${currentBlankIdx}`]; this.renderTable(); };
                        } else {
                            const isCorrect = savedAnswer === kwInfo.text;
                            blank.classList.add(isCorrect ? 'correct' : 'wrong');
                            if (!isCorrect) {
                                const reveal = document.createElement('span');
                                reveal.className = 'reveal-correct'; reveal.textContent = ` (${kwInfo.text})`;
                                blank.appendChild(reveal);
                            }
                        }
                        placeholder.replaceWith(blank);
                    } else {
                        // Input type
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.className = 'clause-input-blank mini';
                        const savedAnswer = this.userAnswers[`${q.id}-${currentBlankIdx}`] || '';
                        input.value = savedAnswer;

                        if (!this.isChecked) {
                            input.oninput = () => {
                                this.userAnswers[`${q.id}-${currentBlankIdx}`] = input.value;
                            };
                        } else {
                            input.disabled = true;
                            const isCorrect = this.normalizeInput(savedAnswer) === this.normalizeInput(kwInfo.text);
                            input.classList.add(isCorrect ? 'correct' : 'wrong');
                            if (!isCorrect) {
                                const tip = document.createElement('span');
                                tip.className = 'reveal-correct';
                                tip.textContent = ` (${kwInfo.text})`;
                                placeholder.parentNode.insertBefore(tip, placeholder.nextSibling);
                            }
                        }
                        placeholder.replaceWith(input);
                    }
                }
                wrapper.appendChild(cText);
                tdQ.appendChild(wrapper);

                if (!this.isChecked) {
                    const dragKeywords = rowKeywords.filter(kw => kw.type === 'drag').map(kw => kw.text);
                    const requiredCounts = {}; dragKeywords.forEach(text => { requiredCounts[text] = (requiredCounts[text] || 0) + 1; });
                    const allOptions = [...new Set([...dragKeywords, ...(q.dummies || [])])];
                    if (allOptions.length > 0) {
                        const bankContainer = document.createElement('div');
                        bankContainer.className = 'keyword-bank'; bankContainer.style.marginTop = '1rem';
                        const cacheKey = `bank-${q.id}`;
                        if (!this.shuffledCache[cacheKey]) this.shuffledCache[cacheKey] = allOptions.sort(() => Math.random() - 0.5);

                        const usedCounts = {};
                        Object.keys(this.userAnswers).forEach(key => {
                            if (key.startsWith(`${q.id}-`)) {
                                const ans = this.userAnswers[key];
                                usedCounts[ans] = (usedCounts[ans] || 0) + 1;
                            }
                        });

                        this.shuffledCache[cacheKey].forEach(word => {
                            const req = requiredCounts[word] || 0;
                            const used = usedCounts[word] || 0;
                            const isUsed = req > 0 ? (used >= req) : (used > 0);

                            const card = document.createElement('div'); card.className = `keyword-card ${isUsed ? 'used' : ''}`;
                            if (req > 1 && !isUsed) {
                                card.innerHTML = `${word} <span class="keyword-count-badge">${req - used}</span>`;
                            } else {
                                card.textContent = word;
                            }
                            card.draggable = !isUsed;
                            card.ondragstart = (e) => { if (isUsed) return; e.dataTransfer.setData('text/plain', word); card.classList.add('dragging'); };
                            card.ondragend = () => card.classList.remove('dragging');
                            bankContainer.appendChild(card);
                        });
                        tdQ.appendChild(bankContainer);
                    }
                }
                tdQ.colSpan = columns.length + (!isAuto && this.isEditMode ? 1 : 0);
            } else {
                if (!isAuto && this.isEditMode) {
                    const delBtn = document.createElement('span'); delBtn.className = 'delete-row-btn'; delBtn.innerHTML = 'Ã—';
                    delBtn.onclick = () => this.deleteRow(q.id);
                    tdQ.appendChild(delBtn);
                }
                if (isAuto && q.origPage) { const tag = document.createElement('div'); tag.className = 'page-tag'; tag.textContent = q.origPage; tdQ.appendChild(tag); }

                const spanText = document.createElement('span'); spanText.textContent = q.text;
                if (!isAuto && this.isEditMode) { spanText.contentEditable = true; spanText.onblur = () => { q.text = spanText.textContent.trim(); this.saveData(); }; }
                tdQ.appendChild(spanText);

                if (!isAuto && this.isEditMode) {
                    const memoEl = document.createElement('div'); memoEl.className = 'memo-input'; memoEl.placeholder = 'ãƒ¡ãƒ¢...'; memoEl.contentEditable = true;
                    memoEl.textContent = q.memo || ''; memoEl.onblur = () => { q.memo = memoEl.textContent.trim(); this.saveData(); };
                    tdQ.appendChild(memoEl);
                } else if (this.isChecked && q.memo) {
                    const memoEl = document.createElement('div'); memoEl.className = 'memo-display';
                    memoEl.innerHTML = `<strong>è§£èª¬:</strong> ${q.memo.replace(/\n/g, '<br>')}`;
                    tdQ.appendChild(memoEl);
                }
            }

            const statKey = q.type === 'clause' ? `clause-summary-${q.id}` : q.id;
            if (this.questionStats[statKey]) {
                const historyBtn = document.createElement('span'); historyBtn.className = 'history-icon-btn'; historyBtn.innerHTML = ' ğŸ“ˆ';
                historyBtn.onclick = (e) => { e.stopPropagation(); this.showSRSDetail(statKey); };
                tdQ.appendChild(historyBtn);
            }
            tr.appendChild(tdQ);

            if (q.type !== 'clause') {
                for (let i = 1; i < columns.length; i++) {
                    const colLabelRaw = columns[i];
                    const colLabel = colLabelRaw.replace(/\{.*?\}/, '').trim();
                    const td = document.createElement('td'); td.className = 'choice-cell';
                    if (isQMulti) td.classList.add('multi-select');
                    td.textContent = colLabel;

                    if (this.isEditMode && !isAuto) {
                        const isCorrect = isQMulti ? (Array.isArray(q.answer) && q.answer.includes(colLabel)) : (q.answer === colLabel);
                        if (isCorrect) td.classList.add(isQMulti ? 'multi-selected' : 'correct');
                    } else {
                        const userAnswer = this.userAnswers[q.id];
                        const isSelected = isQMulti ? (Array.isArray(userAnswer) && userAnswer.includes(colLabel)) : (userAnswer === colLabel);

                        if (this.isChecked) {
                            const isCorrectAnswer = isQMulti ? (Array.isArray(q.answer) && q.answer.includes(colLabel)) : (q.answer === colLabel);
                            if (isCorrectAnswer) td.classList.add('correct');
                            else if (isSelected) td.classList.add('wrong');
                        } else if (isSelected) td.classList.add('selected');
                    }

                    td.onclick = () => {
                        if (!this.isChecked && !this.isEditMode) {
                            if (isQMulti) {
                                if (!Array.isArray(this.userAnswers[q.id])) this.userAnswers[q.id] = [];
                                if (this.userAnswers[q.id].includes(colLabel)) this.userAnswers[q.id] = this.userAnswers[q.id].filter(a => a !== colLabel);
                                else this.userAnswers[q.id].push(colLabel);
                            } else { this.userAnswers[q.id] = colLabel; }
                            this.renderTable();
                        } else if (this.isEditMode && !isAuto) {
                            if (isQMulti) {
                                if (!Array.isArray(q.answer)) q.answer = [];
                                if (q.answer.includes(colLabel)) q.answer = q.answer.filter(a => a !== colLabel);
                                else q.answer.push(colLabel);
                            } else { q.answer = colLabel; }
                            this.saveData(); this.renderTable();
                        }
                    };
                    tr.appendChild(td);
                }
            }
            tbody.appendChild(tr);
        });

    }


    deleteRow(id) {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (set.questions.length <= 1) { alert('æœ€ä½1è¡Œã¯å¿…è¦ã§ã™ã€‚'); return; }
        if (confirm('ã“ã®è¡Œã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
            set.questions = set.questions.filter(q => q.id !== id);
            this.saveData(); this.renderTable();
        }
    }

    moveRow(id, direction) {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        const index = set.questions.findIndex(q => q.id === id);
        if (index === -1) return;

        const newIndex = index + direction;
        if (newIndex < 0 || newIndex >= set.questions.length) return;

        // Swap
        const temp = set.questions[index];
        set.questions[index] = set.questions[newIndex];
        set.questions[newIndex] = temp;

        this.saveData();
        this.renderTable();
    }

    deleteColumn(index) {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (set.columns.length <= 2) { alert('æœ€ä½1ã¤ã®é¸æŠè‚¢ã¯å¿…è¦ã§ã™ã€‚'); return; }
        const colName = set.columns[index];
        if (confirm(`åˆ—ã€Œ${colName}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
            set.columns.splice(index, 1);
            set.questions.forEach(q => {
                if (Array.isArray(q.answer)) q.answer = q.answer.filter(a => a !== colName);
                else if (q.answer === colName) q.answer = set.columns[1];
            });
            this.saveData(); this.renderTable();
        }
    }

    renderTOC() {
        // Build a flat list in order of display (DFS)
        const getFlatDisplayList = (parentId = null, depth = 0) => {
            let result = [];
            const items = this.quizData.filter(item => item.parentId === parentId);
            items.forEach(item => {
                const globalIndex = this.quizData.findIndex(d => d.id === item.id);
                result.push({ ...item, depth, globalIndex });
                if (item.type === 'folder' && !item.isCollapsed) {
                    result = result.concat(getFlatDisplayList(item.id, depth + 1));
                }
            });
            return result;
        };

        const list = getFlatDisplayList(null, 0);

        this.tocList.innerHTML = list.map(s => {
            const isFolder = s.type === 'folder';
            const isActive = s.id === this.currentSetId && !this.isAutoGenerated && !isFolder;
            const indent = s.depth * 15;

            return `
            <li class="${isActive ? 'active' : ''} ${isFolder ? 'type-folder' : 'type-page'}" 
                style="padding-left: ${indent}px"
                draggable="${this.isEditMode}" 
                ondragstart="app.handleDragStart(event, '${s.id}')" 
                ondragover="app.handleDragOver(event, '${s.id}')" 
                ondrop="app.handleDrop(event, '${s.id}')" 
                ondragend="app.handleDragEnd(event)">
                <div class="item-container ${isFolder ? 'folder-item' : ''}">
                    ${isFolder ? `
                        <span class="folder-toggle" onclick="event.stopPropagation(); app.toggleFolder('${s.id}')">
                            ${s.isCollapsed ? 'â–¶' : 'â–¼'}
                        </span>
                        <span class="folder-icon">${s.isCollapsed ? 'ğŸ“' : 'ğŸ“‚'}</span>
                    ` : ''}
                    <input type="checkbox" class="toc-pool-checkbox" 
                           ${s.isInPool ? 'checked' : ''} 
                           onclick="event.stopPropagation(); app.toggleItemPool('${s.id}')" 
                           title="ç‰¹è¨“å¯¾è±¡ã«å«ã‚ã‚‹">
                    <a href="#${s.id}" draggable="false" onclick="if('${isFolder}' === 'true') { event.preventDefault(); app.toggleFolder('${s.id}'); }">
                        ${s.title}
                    </a>
                    <div class="reorder-btns">
                        <button class="reorder-btn" onclick="event.stopPropagation(); app.movePageById('${s.id}', -1)">â–²</button>
                        <button class="reorder-btn" onclick="event.stopPropagation(); app.movePageById('${s.id}', 1)">â–¼</button>
                        ${isFolder ? `
                            <button class="reorder-btn" title="å­ãƒ•ã‚©ãƒ«ãƒ€ã‚’è¿½åŠ " onclick="event.stopPropagation(); app.addNewFolder('${s.id}')">ï¼‹ğŸ“</button>
                            <button class="reorder-btn" title="é€šå¸¸ãƒšãƒ¼ã‚¸ã‚’è¿½åŠ " onclick="event.stopPropagation(); app.addNewPage('${s.id}')">ï¼‹ğŸ“„</button>
                            <button class="reorder-btn" title="æ¡æ–‡ç©´åŸ‹ã‚ã‚’è¿½åŠ " onclick="event.stopPropagation(); app.addNewClausePage('${s.id}')">ï¼‹ğŸ”¤</button>
                            <button class="reorder-btn delete-folder-btn" onclick="event.stopPropagation(); app.deleteFolder('${s.id}')">Ã—</button>
                        ` : ''}
                    </div>
                </div>
            </li>`;
        }).join('');
    }

    handleDragStart(e, id) {
        if (!this.isEditMode) return;
        this.draggedItemId = id;
        e.dataTransfer.setData('text/plain', id);
        e.currentTarget.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
    }

    handleDragOver(e, id) {
        if (!this.isEditMode) return;
        e.preventDefault();
        const li = e.currentTarget;
        if (id === this.draggedItemId) return;

        const targetItem = this.quizData.find(i => i.id === id);
        if (!targetItem) return;

        // Clean up previous classes
        li.classList.remove('drag-over-top', 'drag-over-bottom', 'drag-over-folder');

        const rect = li.getBoundingClientRect();
        const relativeY = e.clientY - rect.top;
        const height = rect.height;

        if (targetItem.type === 'folder') {
            if (relativeY < height * 0.25) {
                li.classList.add('drag-over-top');
                this.dropPosition = 'above';
            } else if (relativeY > height * 0.75) {
                li.classList.add('drag-over-bottom');
                this.dropPosition = 'below';
            } else {
                li.classList.add('drag-over-folder');
                this.dropPosition = 'inside';
            }
        } else {
            if (relativeY < height / 2) {
                li.classList.add('drag-over-top');
                this.dropPosition = 'above';
            } else {
                li.classList.add('drag-over-bottom');
                this.dropPosition = 'below';
            }
        }
    }

    isDescendant(targetId, potentialParentId) {
        let currentParentId = potentialParentId;
        while (currentParentId) {
            if (currentParentId === targetId) return true;
            const parent = this.quizData.find(i => i.id === currentParentId);
            currentParentId = parent ? parent.parentId : null;
        }
        return false;
    }

    handleDrop(e, id) {
        if (!this.isEditMode) return;
        e.preventDefault();
        const targetItem = this.quizData.find(i => i.id === id);
        const draggedItem = this.quizData.find(i => i.id === this.draggedItemId);

        if (!draggedItem || !targetItem || draggedItem.id === id) return;

        if (draggedItem.type === 'folder' && this.isDescendant(draggedItem.id, id)) {
            alert('ãƒ•ã‚©ãƒ«ãƒ€ã‚’è‡ªåˆ†è‡ªèº«ã®å­è¦ç´ ã«ç§»å‹•ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚');
            return;
        }

        const data = [...this.quizData];
        const itemIdx = data.findIndex(i => i.id === this.draggedItemId);
        if (itemIdx === -1) return;
        const item = data.splice(itemIdx, 1)[0];

        if (this.dropPosition === 'inside' && targetItem.type === 'folder') {
            item.parentId = targetItem.id;
            targetItem.isCollapsed = false;
            data.push(item);
        } else {
            item.parentId = targetItem.parentId;
            let targetIdx = data.findIndex(d => d.id === id);
            if (this.dropPosition === 'below') targetIdx++;
            data.splice(targetIdx, 0, item);
        }

        this.quizData = data;
        this.saveData();
        this.renderTOC();
    }

    handleDragEnd(e) {
        this.draggedItemId = null;
        this.renderTOC();
    }

    movePageById(id, direction) {
        const index = this.quizData.findIndex(i => i.id === id);
        if (index !== -1) this.movePage(index, direction);
    }

    toggleFolder(id) {
        const folder = this.quizData.find(s => s.id === id);
        if (folder && folder.type === 'folder') {
            folder.isCollapsed = !folder.isCollapsed;
            this.saveData();
            this.renderTOC();
        }
    }

    toggleItemPool(id) {
        const item = this.quizData.find(s => s.id === id);
        if (!item) return;

        const newState = !item.isInPool;

        // Recursive function to apply state to descendants
        const applyRecursive = (parentId, state) => {
            this.quizData.forEach(child => {
                if (child.parentId === parentId) {
                    child.isInPool = state;
                    if (child.type === 'folder') {
                        applyRecursive(child.id, state);
                    }
                }
            });
        };

        item.isInPool = newState;
        if (item.type === 'folder') {
            applyRecursive(item.id, newState);
        }

        this.saveData();
        this.renderTOC();
    }

    clearAllPoolSelections() {
        if (!confirm('ç‰¹è¨“å¯¾è±¡ã®ãƒã‚§ãƒƒã‚¯ã‚’ã™ã¹ã¦å¤–ã—ã¾ã™ã‹ï¼Ÿ')) return;
        this.quizData.forEach(item => {
            item.isInPool = false;
        });
        this.saveData();
        this.renderTOC();
    }

    isItemSelectedForPool(itemId) {
        const item = this.quizData.find(i => i.id === itemId);
        return item ? !!item.isInPool : false;
    }

    deleteFolder(id) {
        if (!this.isEditMode) return;
        const folder = this.quizData.find(s => s.id === id);
        if (!folder) return;

        const children = this.quizData.filter(item => item.parentId === id);
        let msg = `ãƒ•ã‚©ãƒ«ãƒ€ã€Œ${folder.title}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`;
        if (children.length > 0) {
            msg += `\n\næ³¨æ„ï¼šä¸­èº«ã®å•é¡Œï¼ˆ${children.length}ä»¶ï¼‰ã¯å‰Šé™¤ã•ã‚Œã¾ã›ã‚“ãŒã€ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰å‡ºã•ã‚Œã¾ã™ã€‚`;
        }

        if (confirm(msg)) {
            // Unparent children
            children.forEach(child => child.parentId = null);
            // Remove folder
            this.quizData = this.quizData.filter(s => s.id !== id);
            this.saveData();
            this.renderTOC();
        }
    }

    addNewFolder(parentId = null) {
        const title = prompt('ãƒ•ã‚©ãƒ«ãƒ€å:');
        if (!title) return;
        const id = 'f-' + Date.now();
        this.quizData.push({
            id, title, type: 'folder', parentId: parentId, isCollapsed: false
        });
        if (parentId) {
            const parent = this.quizData.find(p => p.id === parentId);
            if (parent) parent.isCollapsed = false;
        }
        this.saveData();
        this.renderTOC();
    }

    movePage(index, direction) {
        const itemsAtSameLevel = this.quizData.filter(item => item.parentId === this.quizData[index].parentId);
        const localIndex = itemsAtSameLevel.findIndex(item => item.id === this.quizData[index].id);
        const newLocalIndex = localIndex + direction;

        if (newLocalIndex < 0 || newLocalIndex >= itemsAtSameLevel.length) return;

        const targetGlobalIndex = this.quizData.findIndex(item => item.id === itemsAtSameLevel[newLocalIndex].id);

        const temp = this.quizData[index];
        this.quizData[index] = this.quizData[targetGlobalIndex];
        this.quizData[targetGlobalIndex] = temp;

        this.saveData();
        this.renderTOC();
    }

    updateActiveTOC(id) {
        this.tocList.querySelectorAll('li').forEach(li => {
            const a = li.querySelector('a');
            const isActive = a && a.getAttribute('href') === `#${id}`;
            li.classList.toggle('active', isActive);
        });
    }

    addNewPage(parentId = null) {
        const title = prompt('ã‚¿ã‚¤ãƒˆãƒ«:'); if (!title) return;
        const isMulti = confirm('è¤‡æ•°é¸æŠï¼ˆãƒ©ãƒ³ã‚­ãƒ³ã‚°å½¢å¼ï¼‰ã«ã—ã¾ã™ã‹ï¼Ÿ\nOK: è¤‡æ•°é¸æŠ, ã‚­ãƒ£ãƒ³ã‚»ãƒ«: å˜ä¸€é¸æŠ');
        const id = 'p-' + Date.now();
        const cols = isMulti ? [
            "é †ä½", "ã€ç”Ÿè¨ˆç¶­æŒã€‘", "ã€ç”Ÿè¨ˆåŒä¸€ã€‘", "é…å¶è€…", "å­", "çˆ¶æ¯", "å­«", "ç¥–çˆ¶æ¯", "å…„å¼Ÿå§‰å¦¹", "3è¦ªç­‰ä»¥å†…", "å¯¾è±¡ãªã—"
        ] : ["é …ç›®", "é¸æŠ1", "é¸æŠ2"];

        const questions = [];
        if (isMulti) {
            for (let i = 1; i <= 6; i++) {
                questions.push({ id: 'q-' + Date.now() + i, text: `ç¬¬${i}é †ä½`, answer: [] });
            }
        } else {
            questions.push({ id: 'q-' + Date.now(), text: "æ–°å•é¡Œ", answer: cols[1] });
        }

        const newPage = {
            id, title, type: 'page', parentId: parentId, isMultiSelect: isMulti,
            columns: cols,
            questions: questions
        };

        // If current viewing is a folder, maybe add to it? For now, just add to root
        this.quizData.push(newPage);

        this.isAutoGenerated = false;
        this.saveData();
        this.renderTOC();
        this.loadSet(id);

        // Scroll to the new page in the sidebar
        setTimeout(() => {
            const newElem = this.tocList.querySelector(`a[href="#${id}"]`);
            if (newElem) newElem.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 100);
    }

    addNewClausePage(parentId = null) {
        const title = prompt('æ¡æ–‡ç©´åŸ‹ã‚å•é¡Œã®ã‚¿ã‚¤ãƒˆãƒ«:'); if (!title) return;
        const id = 'p-' + Date.now();
        const newPage = {
            id, title, type: 'clause', parentId: parentId,
            text: 'ã“ã“ã«æ¡æ–‡ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚[[ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰]]ã®ã‚ˆã†ã«å›²ã‚€ã¨ãã“ãŒç©´åŸ‹ã‚ã«ãªã‚Šã¾ã™ã€‚',
            dummies: ''
        };
        this.quizData.push(newPage);
        this.saveData();
        this.renderTOC();
        this.loadSet(id);

        setTimeout(() => {
            const newElem = this.tocList.querySelector(`a[href="#${id}"]`);
            if (newElem) newElem.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 100);
    }

    addNewRow() {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        set.questions.push({
            id: 'q-' + Date.now(),
            text: "æ–°å•é¡Œ...",
            memo: "",
            answer: set.isMultiSelect ? [] : set.columns[1]
        });
        this.saveData();
        this.renderTable();
    }
    addNewColumn() { if (this.isAutoGenerated) return; const set = this.quizData.find(s => s.id === this.currentSetId); const name = prompt('åˆ—å:'); if (!name) return; set.columns.push(name); this.saveData(); this.renderTable(); }

    deleteCurrentPage() {
        if (this.quizData.length <= 1 || this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (!set || set.type === 'folder') {
            alert('ãƒ•ã‚©ãƒ«ãƒ€ã‚’å‰Šé™¤ã™ã‚‹å ´åˆã¯ã€ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®ã€ŒÃ—ã€ãƒœã‚¿ãƒ³ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚');
            return;
        }

        if (confirm(`ã“ã®ãƒšãƒ¼ã‚¸ï¼ˆ${set.title}ï¼‰ã®å…¨å•é¡Œãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚`)) {
            // Safety: if this page had children (unlikely but possible), unparent them
            const children = this.quizData.filter(item => item.parentId === this.currentSetId);
            children.forEach(c => c.parentId = null);

            this.quizData = this.quizData.filter(s => s.id !== this.currentSetId);

            // Find a valid next item (prefer a page)
            let nextItem = this.quizData.find(i => i.type === 'page' || i.type === 'clause');
            if (!nextItem) nextItem = this.quizData[0];

            this.currentSetId = nextItem ? nextItem.id : null;
            this.saveData();
            this.migrateData(); // Rescue orphans if any were created
            this.renderTOC();
            if (this.currentSetId) this.loadSet(this.currentSetId);
            else this.renderTable(); // Show empty state
        }
    }

    cloneCurrentPage() {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (!set) return;

        const newId = 'p-' + Date.now();
        const clonedSet = JSON.parse(JSON.stringify(set));
        clonedSet.id = newId;
        clonedSet.title = clonedSet.title + 'ï¼ˆã‚³ãƒ”ãƒ¼ï¼‰';

        // Re-generate question IDs to avoid conflicts and start fresh stats
        clonedSet.questions.forEach((q, i) => {
            q.id = 'q-' + Date.now() + '-' + i + '-' + Math.random().toString(36).substr(2, 5);
        });

        this.quizData.push(clonedSet);
        this.saveData();
        this.isAutoGenerated = false;
        this.renderTOC();
        this.loadSet(newId);
    }

    clearData() {
        const input = prompt('ã™ã¹ã¦ã®å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã¨å±¥æ­´ã‚’å®Œå…¨ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nå‰Šé™¤ã™ã‚‹å ´åˆã¯ã€ç¢ºèªã®ãŸã‚ã€ŒRESETã€ã¨å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚\næ³¨ï¼šäº‹å‰ã«ã€Œãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¿å­˜ã€ã‚’è¡Œã†ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚');
        if (input === 'RESET') { localStorage.clear(); window.location.reload(); } else if (input !== null) { alert('å…¥åŠ›ãŒæ­£ã—ããªã„ãŸã‚ã€å‰Šé™¤ã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚'); }
    }

    // --- Data Management (Export/Import) ---

    getTimestamp() {
        const now = new Date();
        const pad = (n) => n.toString().padStart(2, '0');
        return `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    }

    async exportToJSON() {
        const fullData = {
            quizData: this.quizData,
            history: this.history,
            questionStats: this.questionStats,
            exportedAt: new Date().toISOString()
        };
        const fileName = `sharo_study_backup_${this.getTimestamp()}.json`;
        const jsonContent = JSON.stringify(fullData, null, 2);

        // Try File System Access API for folder selection
        if (window.showSaveFilePicker) {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{ description: 'JSON File', accept: { 'application/json': ['.json'] } }]
                });
                const writable = await handle.createWritable();
                await writable.write(jsonContent);
                await writable.close();
                this.updateDataStatus("JSONã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚");
                return;
            } catch (err) {
                if (err.name === 'AbortError') return;
                console.error("showSaveFilePicker failed:", err);
            }
        }

        // Fallback for older browsers
        const blob = new Blob([jsonContent], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
        this.updateDataStatus("JSONå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸï¼ˆãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€ã«ä¿å­˜ï¼‰ã€‚");
    }

    async exportToCSV() {
        // CSV is focused on quiz questions only (for spreadsheet editing)
        let csv = '\uFEFF'; // UTF-8 BOM
        csv += 'ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ«,ID,å•é¡Œæ–‡,æ­£è§£(ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š),è§£èª¬,é¸æŠè‚¢1,é¸æŠè‚¢2,é¸æŠè‚¢3,é¸æŠè‚¢4,é¸æŠè‚¢5,é¸æŠè‚¢6,é¸æŠè‚¢7,é¸æŠè‚¢8,é¸æŠè‚¢9,é¸æŠè‚¢10\n';

        this.quizData.forEach(page => {
            if (page.type !== 'page' || !page.questions) return;
            page.questions.forEach(q => {
                const row = [
                    page.title,
                    q.id,
                    q.text,
                    Array.isArray(q.answer) ? q.answer.join('|') : q.answer,
                    q.memo || '',
                    ...(page.columns.slice(1)) // choice choices
                ].map(val => `"${(val || "").toString().replace(/"/g, '""')}"`).join(',');
                csv += row + '\n';
            });
        });

        const fileName = `sharo_questions_${this.getTimestamp()}.csv`;

        if (window.showSaveFilePicker) {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{ description: 'CSV File', accept: { 'text/csv': ['.csv'] } }]
                });
                const writable = await handle.createWritable();
                await writable.write(csv);
                await writable.close();
                this.updateDataStatus("CSVã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚");
                return;
            } catch (err) {
                if (err.name === 'AbortError') return;
                console.error("showSaveFilePicker failed:", err);
            }
        }

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
        this.updateDataStatus("CSVå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸï¼ˆãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€ã«ä¿å­˜ï¼‰ã€‚");
    }

    handleFileImport(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            const content = event.target.result;
            if (file.name.endsWith('.json')) {
                this.importFromJSON(content);
            } else if (file.name.endsWith('.csv')) {
                this.importFromCSV(content);
            }
        };
        reader.readAsText(file);
    }

    importFromJSON(jsonString) {
        try {
            const data = JSON.parse(jsonString);
            if (!data.quizData) throw new Error('Invalid backup format');

            if (confirm('ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã™ã¹ã¦ä¸Šæ›¸ãã—ã¦å¾©æ—§ã—ã¾ã™ã‹ï¼Ÿ\nï¼ˆç¾åœ¨ã®å•é¡Œãƒ»å±¥æ­´ãƒ»çµ±è¨ˆãŒã™ã¹ã¦æ¶ˆãˆã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã«ç½®ãæ›ã‚ã‚Šã¾ã™ï¼‰')) {
                this.quizData = data.quizData;
                this.history = data.history || [];
                this.questionStats = data.questionStats || {};

                this.saveData();
                this.saveHistory();
                this.saveQuestionStats();

                alert('ãƒ‡ãƒ¼ã‚¿ã‚’æ­£å¸¸ã«å¾©å…ƒã—ã¾ã—ãŸã€‚');
                window.location.reload();
            }
        } catch (err) {
            console.error(err);
            alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æœ‰åŠ¹ãªJSONãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
        }
    }

    importFromCSV(csvString) {
        try {
            const lines = csvString.split(/\r?\n/);
            if (lines.length < 2) return;

            // Simple CSV parser (not handling all escapes, but works for standard export)
            const parseCSVLine = (line) => {
                const parts = [];
                let current = '';
                let inQuotes = false;
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"' && line[i + 1] === '"') { current += '"'; i++; }
                    else if (char === '"') inQuotes = !inQuotes;
                    else if (char === ',' && !inQuotes) { parts.push(current); current = ''; }
                    else current += char;
                }
                parts.push(current);
                return parts;
            };

            const header = parseCSVLine(lines[0]);
            const newPages = new Map();

            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                const row = parseCSVLine(lines[i]);
                const pageTitle = row[0];
                const id = row[1] || ('q-' + Math.random().toString(36).substr(2, 9));
                const text = row[2];
                const answerRaw = row[3];
                const choices = row.slice(4).filter(c => c !== undefined && c !== "");

                if (!pageTitle || !text) continue;

                if (!newPages.has(pageTitle)) {
                    newPages.set(pageTitle, {
                        id: 'p-' + Date.now() + Math.random().toString(36).substr(2, 5),
                        title: pageTitle,
                        type: 'page',
                        parentId: null,
                        isCollapsed: false,
                        columns: ["é …ç›®", ...choices],
                        questions: [],
                        isMultiSelect: answerRaw.includes('|')
                    });
                }

                const page = newPages.get(pageTitle);
                page.questions.push({
                    id: id,
                    text: text,
                    answer: page.isMultiSelect ? answerRaw.split('|') : answerRaw,
                    isInPool: true
                });
            }

            if (confirm(`CSVã‹ã‚‰ ${newPages.size} ãƒšãƒ¼ã‚¸ã®å•é¡Œã‚’å–ã‚Šè¾¼ã¿ã¾ã™ã‹ï¼Ÿ\næ—¢å­˜ã®ãƒšãƒ¼ã‚¸ã¯ç¶­æŒã•ã‚Œã€æœ«å°¾ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚`)) {
                this.quizData.push(...Array.from(newPages.values()));
                this.saveData();
                alert('CSVã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’æ­£å¸¸ã«å–ã‚Šè¾¼ã¿ã¾ã—ãŸã€‚');
                this.renderTOC();
                this.loadSet(this.currentSetId);
            }
        } catch (err) {
            console.error(err);
            alert('CSVã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
        }
    }

    updateDataStatus(msg) {
        if (this.dataStatusMsg) {
            this.dataStatusMsg.textContent = `${msg} (${new Date().toLocaleTimeString()})`;
            this.dataStatusMsg.style.color = 'var(--success)';
            setTimeout(() => {
                this.dataStatusMsg.style.color = 'var(--text-secondary)';
            }, 5000);
        }
        // Save export timestamp for reminder
        if (msg.includes("ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ")) {
            localStorage.setItem('sharo_last_export_at', new Date().toISOString());
            this.checkBackupFrequency();
        }
    }

    // --- Automatic Recovery and Protection ---

    checkAndOfferRecovery(manual = false) {
        const backupStr = localStorage.getItem('sharo_auto_backup');
        if (!backupStr) {
            if (manual) alert('å†…éƒ¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
            return;
        }

        try {
            const backup = JSON.parse(backupStr);
            const isMainEmpty = (this.quizData.length <= DEFAULT_QUIZ_DATA.length && this.history.length === 0);

            if (manual || isMainEmpty) {
                const date = new Date(backup.savedAt).toLocaleString();
                const msg = manual
                    ? `å†…éƒ¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼ˆä¿å­˜æ—¥æ™‚: ${date}ï¼‰ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ\nç¾åœ¨ç·¨é›†ä¸­ã®å†…å®¹ã¯ä¸Šæ›¸ãã•ã‚Œã¾ã™ã€‚`
                    : `ã€ãƒ‡ãƒ¼ã‚¿å¾©æ—§ã®æ¡ˆå†…ã€‘\nãƒ¡ã‚¤ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒåˆæœŸçŠ¶æ…‹ã®ã‚ˆã†ã§ã™ãŒã€å†…éƒ¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼ˆä¿å­˜æ—¥æ™‚: ${date}ï¼‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚\nä»¥å‰ã®çŠ¶æ…‹ã‚’å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ`;

                if (confirm(msg)) {
                    this.quizData = backup.quizData;
                    this.history = backup.history || [];
                    this.questionStats = backup.questionStats || {};
                    this.saveData();
                    this.saveHistory();
                    this.saveQuestionStats();
                    alert('ãƒ‡ãƒ¼ã‚¿ã‚’æ­£å¸¸ã«å¾©å…ƒã—ã¾ã—ãŸã€‚');
                    window.location.reload();
                }
            }
        } catch (e) {
            console.error("Backup parse error", e);
        }
    }

    checkBackupFrequency() {
        const lastExport = localStorage.getItem('sharo_last_export_at');
        if (!lastExport) return;

        const hoursSince = (Date.now() - new Date(lastExport).getTime()) / (1000 * 60 * 60);
        if (hoursSince > 24) {
            const reminderArea = document.getElementById('backup-reminder');
            if (reminderArea) {
                reminderArea.style.display = 'block';
                reminderArea.innerHTML = `âš ï¸ æœ€çµ‚ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‹ã‚‰24æ™‚é–“ä»¥ä¸ŠçµŒéã—ã¦ã„ã¾ã™ã€‚å¤§åˆ‡ãªãƒ‡ãƒ¼ã‚¿ã‚’å®ˆã‚‹ãŸã‚ã€<span style="color:var(--accent); cursor:pointer; text-decoration:underline;" onclick="app.exportToJSON()">JSONãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ä¿å­˜</span>ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚`;
            }
        } else {
            const reminderArea = document.getElementById('backup-reminder');
            if (reminderArea) reminderArea.style.display = 'none';
        }
    }
}
let app;
document.addEventListener('DOMContentLoaded', () => {
    app = new QuizApp();
    window.app = app; // Correctly expose app to global for onclick handlers
});
