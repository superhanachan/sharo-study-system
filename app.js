const DEFAULT_QUIZ_DATA = [
    {
        id: "pension-1",
        title: "国民年金法 資格喪失の時期 (法9条) 強制被保険者",
        columns: ["項目", "当日喪失", "翌日喪失"],
        questions: [
            { id: "q-1", text: "イ）死亡したとき", answer: "翌日喪失" },
            { id: "q-2", text: "ニ）厚生年金保険法に基づく老齢給付等を受けることができる者その他この法律の適用を除外すべき特別の理由がある者として厚生労働省令で定める者となったとき（第2号被保険者又は第3号被保険者に該当するときを除く）", answer: "当日喪失" },
            { id: "q-3", text: "ハ）60歳に達したとき（第2号被保険者に該当するときを除く）", answer: "当日喪失" }
        ]
    },
    {
        id: "survivor-rank-1",
        title: "【特訓】遺族の順位判定（スリム版）",
        isMultiSelect: true,
        columns: [
            "順位", "【生計維持】", "【生計同一】", "配偶者", "子", "父母", "孫", "祖父母", "兄弟姉妹", "3親等以内", "対象なし"
        ],
        questions: [
            { id: "q-surv-1", text: "第1順位", answer: ["配偶者", "子", "【生計維持】"] },
            { id: "q-surv-2", text: "第2順位", answer: ["父母", "【生計維持】"] },
            { id: "q-surv-3", text: "第3順位", answer: ["孫", "【生計維持】"] },
            { id: "q-surv-4", text: "第4順位", answer: ["祖父母", "【生計維持】"] },
            { id: "q-surv-5", text: "第5順位", answer: ["対象なし"] },
            { id: "q-surv-6", text: "第6順位", answer: ["対象なし"] }
        ]
    },
    {
        id: "clause-sample-1",
        title: "雇用保険法 第1条（目的）",
        type: "clause",
        text: "雇用保険は、労働者が[[失業]]した場合及び労働者について[[雇用の継続]]が困難となる事由が生じた場合に必要な給付を行うほか、労働者が自ら職業に関する[[教育訓練]]を受けた場合並びに労働者が[[子を養育]]するための休業及び[[所定労働時間]]を短縮することによる就業をした場合に必要な給付を行うことにより、労働者の[[生活及び雇用]]の安定を図るとともに、[[求職活動]]を容易にする等その就職を促進し、あわせて、労働者の[[職業の安定]]に資するため、[[失業の予防]]、雇用状態の是正及び[[雇用機会の増大]]、労働者の[[能力の開発]]及び向上その他労働者の[[福祉の増進]]を図ることを目的とする。",
        dummies: ["老齢基礎年金", "厚生労働大臣", "60日以内"],
        questions: []
    }
];

class QuizApp {
    constructor() {
        this.quizData = this.loadData();
        this.history = this.loadHistory();
        this.questionStats = this.loadQuestionStats();
        this.currentSetId = this.quizData[0].id;
        this.isEditMode = false;
        this.isAutoGenerated = false;

        this.userAnswers = {};
        this.isChecked = false;
        this.sortColumnIndex = -1;
        this.sortDirection = 1;

        this.chartMode = 'accuracy';
        this.statsChart = null;

        this.migrateData();
        this.cacheDOM();
        this.bindEvents();
        this.init();
    }

    migrateData() {
        let modified = false;

        // 1. Inject/Update Survivor Sample (Check for "スリム版" or column count change)
        const currentRank = this.quizData.find(s => s.id === "survivor-rank-1");
        const defaultRank = DEFAULT_QUIZ_DATA.find(s => s.id === "survivor-rank-1");

        if (!currentRank || (currentRank.columns && currentRank.columns[1] !== "【生計維持】")) {
            if (currentRank) {
                this.quizData = this.quizData.filter(s => s.id !== "survivor-rank-1");
            }
            this.quizData.push(JSON.parse(JSON.stringify(defaultRank)));
            modified = true;
        }

        // SAFETY: Circular reference and orphaned item rescue
        const reachableIds = new Set();
        const walk = (parentId) => {
            this.quizData.filter(item => item.parentId === parentId).forEach(item => {
                if (reachableIds.has(item.id)) return; // Prevent infinite loop
                reachableIds.add(item.id);
                walk(item.id);
            });
        };
        walk(null); // Start from root

        this.quizData.forEach(set => {
            if (!set.type) set.type = 'page';
            if (set.parentId === undefined) set.parentId = null;
            if (set.isCollapsed === undefined) set.isCollapsed = false;
            if (set.isInPool === undefined) set.isInPool = true;

            if (!reachableIds.has(set.id)) {
                // Rescue item by moving to root
                set.parentId = null;
                reachableIds.add(set.id); // Mark as now reachable to prevent redundant rescue
                modified = true;
            }

            if (set.type === 'page') {
                if (!set.questions) return;
                set.questions.forEach(q => {
                    if (!q.id) { q.id = 'q-' + Math.random().toString(36).substr(2, 9) + Date.now(); modified = true; }
                    if (set.isMultiSelect && typeof q.answer === 'string') {
                        q.answer = [q.answer];
                        modified = true;
                    }
                    if (q.isInPool === undefined) {
                        q.isInPool = true;
                        modified = true;
                    }
                });
            }
        });

        // 2. Safe cleanup of questionStats
        // BUG FIX: Only cleanup stats if quizData is successfully loaded and has content.
        // If quizData is somehow empty or fallback-only but stats exist, we MUST NOT wipe them.
        if (this.quizData && this.quizData.length > 0) {
            const cleanedStats = {};
            const allIds = new Set();
            this.quizData.forEach(set => {
                if (set.type === 'page' && set.questions) {
                    set.questions.forEach(q => allIds.add(q.id));
                } else if (set.type === 'clause' && set.text) {
                    // Include summary ID and individual IDs for each blank
                    allIds.add(`clause-summary-${set.id}`);
                    const blankCount = set.text.split('[[').length - 1;
                    for (let i = 0; i < blankCount; i++) {
                        allIds.add(`clause-${set.id}-${i}`);
                    }
                }
            });

            let hasWiped = false;
            Object.keys(this.questionStats).forEach(key => {
                if (allIds.has(key)) {
                    cleanedStats[key] = this.questionStats[key];
                    // Initialize recent history for older data
                    if (!cleanedStats[key].recent) {
                        const t = cleanedStats[key].total || 0;
                        const c = cleanedStats[key].correct || 0;
                        const count = Math.min(t, 5);
                        const r = [];
                        const recentCorrect = t > 0 ? Math.round((c / t) * count) : 0;
                        for (let i = 0; i < count; i++) r.push(i < recentCorrect ? 1 : 0);
                        cleanedStats[key].recent = r;
                    }
                } else {
                    // Log or backup orphaned stats if needed, but for now, just track if we're deleting
                    hasWiped = true;
                }
            });

            // SAFETY: If we are about to wipe more than 50% of stats, something might be wrong.
            // In a real data loss scenario, quizData might be default (2 items) while stats are 100+.
            if (hasWiped && Object.keys(this.questionStats).length > 10 && Object.keys(cleanedStats).length < (Object.keys(this.questionStats).length / 2)) {
                console.warn("Migration safety triggered: Excessive stat cleanup prevented.");
            } else {
                this.questionStats = cleanedStats;
            }
        }

        this.isChecked = false;
        this.shuffledCache = {};

        if (modified) this.saveData();
        this.saveQuestionStats();
    }

    cacheDOM() {
        this.tabQuiz = document.getElementById('tab-quiz');
        this.tabStats = document.getElementById('tab-stats');
        this.quizView = document.getElementById('quiz-view');
        this.statsView = document.getElementById('stats-view');
        this.tocList = document.getElementById('toc-list');
        this.quizTitle = document.getElementById('quiz-title');
        this.tableHead = document.getElementById('table-head');
        this.tableBody = document.getElementById('table-body');
        this.scoreDisplay = document.getElementById('score');
        this.editModeToggle = document.getElementById('edit-mode-toggle');
        this.addFolderBtn = document.getElementById('add-folder-btn');
        this.addPageBtn = document.getElementById('add-page-btn');
        this.addClauseBtn = document.getElementById('add-clause-btn');
        this.addRowBtn = document.getElementById('add-row-btn');
        this.addColumnBtn = document.getElementById('add-column-btn');
        this.clearDataBtn = document.getElementById('clear-data-btn');
        this.deletePageBtn = document.getElementById('delete-page-btn');
        this.clonePageBtn = document.getElementById('clone-page-btn');
        this.checkAnswersBtn = document.getElementById('check-answers-btn');
        this.resetQuizBtn = document.getElementById('reset-quiz-btn');

        this.totalAccuracy = document.getElementById('total-accuracy');
        this.totalAnsweredDisplay = document.getElementById('total-answered');
        this.historyBody = document.getElementById('history-body');
        this.weakQuestionsBody = document.getElementById('weak-questions-body');
        this.genWeakBtn = document.getElementById('gen-weak-btn');
        this.genWeakClauseBtn = document.getElementById('gen-weak-clause-btn');
        this.genRareBtn = document.getElementById('gen-rare-btn');
        this.genRandomBtn = document.getElementById('gen-random-btn');

        this.chartBtns = {
            accuracy: document.getElementById('show-accuracy-btn'),
            frequency: document.getElementById('show-frequency-btn'),
            errors: document.getElementById('show-errors-btn')
        };
        this.sidebar = document.getElementById('sidebar');
        this.sidebarContent = document.getElementById('quiz-sidebar-content');
        this.menuToggle = document.getElementById('menu-toggle');

        // Data management
        this.exportJsonBtn = document.getElementById('export-json-btn');
        this.importJsonBtn = document.getElementById('import-json-btn');
        this.exportCsvBtn = document.getElementById('export-csv-btn');
        this.importCsvBtn = document.getElementById('import-csv-btn');
        this.dataImportInput = document.getElementById('data-import-input');
        this.dataStatusMsg = document.getElementById('data-status-msg');
        this.understandingMap = document.getElementById('understanding-map');
        this.clauseEditor = document.getElementById('clause-editor');
        this.clauseTextEditor = document.getElementById('clause-text-editor');
        this.clauseDummiesEditor = document.getElementById('clause-dummies-editor');
        this.clauseDisplay = document.getElementById('clause-display');
        this.tableWrapper = document.querySelector('.table-wrapper');
        this.columnControls = document.querySelector('.column-controls');
        this.tableControls = document.querySelector('.table-controls');
    }

    bindEvents() {
        this.tabQuiz.addEventListener('click', () => this.switchView('quiz'));
        this.tabStats.addEventListener('click', () => this.switchView('stats'));
        this.editModeToggle.addEventListener('change', (e) => {
            this.isEditMode = e.target.checked;
            document.body.classList.toggle('edit-mode', this.isEditMode);
            this.updateTitleEditability();
            this.resetQuiz(); this.renderTOC(); this.renderTable();
        });
        this.checkAnswersBtn.addEventListener('click', () => this.batchCheckAnswers());
        this.resetQuizBtn.addEventListener('click', () => this.resetQuiz());
        this.addFolderBtn.addEventListener('click', () => this.addNewFolder());
        this.addPageBtn.addEventListener('click', () => this.addNewPage());
        this.addClauseBtn.addEventListener('click', () => this.addNewClausePage());
        this.addRowBtn.addEventListener('click', () => this.addNewRow());
        this.addColumnBtn.addEventListener('click', () => this.addNewColumn());
        this.clearDataBtn.addEventListener('click', () => this.clearData());
        this.deletePageBtn.addEventListener('click', () => this.deleteCurrentPage());
        this.clonePageBtn.addEventListener('click', () => this.cloneCurrentPage());

        this.genWeakBtn.addEventListener('click', () => this.generateSpecialQuiz('weak'));
        if (this.genWeakClauseBtn) {
            this.genWeakClauseBtn.addEventListener('click', () => this.generateSpecialQuiz('clause-weak'));
        }
        this.genRareBtn.addEventListener('click', () => this.generateSpecialQuiz('rare'));
        if (this.genRandomBtn) this.genRandomBtn.addEventListener('click', () => this.generateSpecialQuiz('random'));

        Object.keys(this.chartBtns).forEach(mode => {
            this.chartBtns[mode].addEventListener('click', () => {
                this.chartMode = mode;
                this.updateChartTabs();
                this.renderChart();
            });
        });
        this.tocList.addEventListener('click', (e) => {
            if (e.target.tagName === 'A') {
                e.preventDefault();
                const id = e.target.getAttribute('href').substring(1);
                const item = this.quizData.find(s => s.id === id);
                if (item && item.type === 'folder') {
                    this.toggleFolder(id);
                } else if (item) {
                    this.isAutoGenerated = false;
                    this.currentSetId = id;
                    this.loadSet(id);
                }
            }
        });

        // Update TOC real-time when editing title
        this.quizTitle.addEventListener('input', () => {
            if (this.isEditMode && !this.isAutoGenerated) {
                const set = this.quizData.find(s => s.id === this.currentSetId);
                if (set) {
                    set.title = this.quizTitle.textContent.trim();
                    this.renderTOC();
                }
            }
        });

        this.quizTitle.addEventListener('blur', () => {
            if (this.isEditMode && !this.isAutoGenerated) {
                const set = this.quizData.find(s => s.id === this.currentSetId);
                if (set) {
                    set.title = this.quizTitle.textContent.trim();
                    this.saveData();
                }
            }
        });
        this.menuToggle.addEventListener('click', () => { this.sidebar.classList.toggle('open'); });

        // Data management events
        this.exportJsonBtn.addEventListener('click', () => this.exportToJSON());
        this.importJsonBtn.addEventListener('click', () => { this.dataImportInput.accept = '.json'; this.dataImportInput.click(); });
        this.exportCsvBtn.addEventListener('click', () => this.exportToCSV());
        this.importCsvBtn.addEventListener('click', () => { this.dataImportInput.accept = '.csv'; this.dataImportInput.click(); });
        this.dataImportInput.addEventListener('change', (e) => this.handleFileImport(e));

        // Recovery button for internal backup
        const forceRestoreBtn = document.getElementById('force-restore-internal-btn');
        if (forceRestoreBtn) {
            forceRestoreBtn.addEventListener('click', () => this.checkAndOfferRecovery(true));
        }
    }

    init() {
        this.renderTOC();
        this.loadSet(this.currentSetId);
        this.checkAndOfferRecovery();
        this.checkBackupFrequency();
    }

    loadData() { const saved = localStorage.getItem('sharoQuizData'); return saved ? JSON.parse(saved) : JSON.parse(JSON.stringify(DEFAULT_QUIZ_DATA)); }
    saveData() {
        const dataStr = JSON.stringify(this.quizData);
        localStorage.setItem('sharoQuizData', dataStr);
        // Internal Redundancy: Also save to a backup key
        localStorage.setItem('sharo_auto_backup', JSON.stringify({
            quizData: this.quizData,
            history: this.history,
            questionStats: this.questionStats,
            savedAt: new Date().toISOString()
        }));
    }
    loadHistory() { const saved = localStorage.getItem('sharoQuizHistory'); return saved ? JSON.parse(saved) : []; }
    saveHistory() { localStorage.setItem('sharoQuizHistory', JSON.stringify(this.history)); }
    loadQuestionStats() { const saved = localStorage.getItem('sharoQuestionStats'); return saved ? JSON.parse(saved) : {}; }
    saveQuestionStats() { localStorage.setItem('sharoQuestionStats', JSON.stringify(this.questionStats)); }

    switchView(view) {
        this.tabQuiz.classList.toggle('active', view === 'quiz');
        this.tabStats.classList.toggle('active', view === 'stats');
        this.quizView.classList.toggle('hidden', view !== 'quiz');
        this.statsView.classList.toggle('hidden', view !== 'stats');
        if (view === 'stats') this.renderStats();
    }

    loadSet(id) {
        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === id);
        if (!set || set.type === 'folder') return;

        this.currentSetId = id;
        this.quizTitle.textContent = set.title;
        this.updateTitleEditability();

        this.resetQuiz();
        this.renderTable();
        this.updateActiveTOC(id);
    }

    updateActiveTOC(id) {
        const tocLinks = this.tocList.querySelectorAll('a');
        tocLinks.forEach(a => {
            const isActive = !this.isAutoGenerated && a.getAttribute('href') === `#${id}`;
            a.classList.toggle('active', isActive);
        });
    }

    updateTitleEditability() {
        this.quizTitle.contentEditable = this.isEditMode && !this.isAutoGenerated;
    }

    resetQuiz() {
        this.userAnswers = {};
        this.isChecked = false;
        this.shuffledCache = {};
        this.scoreDisplay.textContent = "正解数: 0 / 0";
        this.renderTable();
    }

    batchCheckAnswers() {
        if (this.isChecked) return;
        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === this.currentSetId);
        let correctCount = 0; let answeredCount = 0;

        if (set.type === 'clause') {
            const keywords = [];
            const parts = set.text.split(/(\[\[.*?\]\])/g);
            parts.forEach(part => {
                if (part.startsWith('[[') && part.endsWith(']]')) {
                    keywords.push(part.substring(2, part.length - 2));
                }
            });

            let allBlanksCorrect = true;
            keywords.forEach((keyword, idx) => {
                const userAnswer = this.userAnswers[`${set.id}-${idx}`];
                if (!userAnswer) {
                    allBlanksCorrect = false;
                    return;
                }
                answeredCount++;

                const isCorrect = userAnswer === keyword;
                if (isCorrect) correctCount++;
                else allBlanksCorrect = false;

                // Detailed stat per blank
                const statKey = `clause-${set.id}-${idx}`;
                if (!this.questionStats[statKey]) {
                    this.questionStats[statKey] = { correct: 0, total: 0, recent: [], page: set.title, text: `穴埋め: ${keyword}` };
                }
                const stat = this.questionStats[statKey];
                stat.total++;
                if (isCorrect) stat.correct++;
                if (!stat.recent) stat.recent = [];
                stat.recent.push(isCorrect ? 1 : 0);
                if (stat.recent.length > 5) stat.recent.shift();
                stat.text = `穴埋め: ${keyword}`; stat.page = set.title;
            });

            // Summary stat for the whole clause
            const summaryKey = `clause-summary-${set.id}`;
            if (!this.questionStats[summaryKey]) {
                this.questionStats[summaryKey] = { correct: 0, total: 0, recent: [], page: set.title, text: `条文全体: ${set.title}` };
            }
            const summaryStat = this.questionStats[summaryKey];
            summaryStat.total++;
            if (allBlanksCorrect) summaryStat.correct++;
            if (!summaryStat.recent) summaryStat.recent = [];
            summaryStat.recent.push(allBlanksCorrect ? 1 : 0);
            if (summaryStat.recent.length > 5) summaryStat.recent.shift();
            summaryStat.text = `条文全体: ${set.title}`; summaryStat.page = set.title;
        } else {
            set.questions.forEach((q) => {
                const userAnswer = this.userAnswers[q.id];
                if (!userAnswer || (Array.isArray(userAnswer) && userAnswer.length === 0)) return;
                answeredCount++;

                let isCorrect = false;
                const isMulti = this.isAutoGenerated ? q.isMultiSelect : set.isMultiSelect;
                if (isMulti) {
                    const correctSet = new Set(q.answer);
                    const userSet = new Set(userAnswer);
                    isCorrect = (correctSet.size === userSet.size && [...correctSet].every(item => userSet.has(item)));
                } else if (q.type === 'clause') {
                    // Check all blanks for this clause in a special quiz
                    const parts = q.text.split(/(\[\[.*?\]\])/g);
                    let blankIdx = 0;
                    isCorrect = true;
                    parts.forEach(part => {
                        if (part.startsWith('[[') && part.endsWith(']]')) {
                            const kw = part.substring(2, part.length - 2);
                            const val = this.userAnswers[`${q.id}-${blankIdx}`];
                            if (val !== kw) isCorrect = false;
                            blankIdx++;
                        }
                    });
                } else {
                    isCorrect = userAnswer === q.answer;
                }

                if (isCorrect) correctCount++;
                const statKey = q.type === 'clause' ? `clause-summary-${q.id}` : q.id;
                if (!this.questionStats[statKey]) {
                    this.questionStats[statKey] = {
                        correct: 0, total: 0, recent: [],
                        page: q.origPage || set.title,
                        text: q.type === 'clause' ? `条文全体: ${q.title || set.title}` : q.text
                    };
                }
                const stat = this.questionStats[statKey];
                stat.total++;
                if (isCorrect) stat.correct++;
                if (!stat.recent) stat.recent = [];
                stat.recent.push(isCorrect ? 1 : 0);
                if (stat.recent.length > 5) stat.recent.shift();
                stat.text = q.type === 'clause' ? `条文全体: ${q.origPage}` : q.text;
                stat.page = q.origPage || set.title;
            });
        }

        this.isChecked = true;
        const totalItems = set.type === 'clause' ? set.text.split('[[').length - 1 : set.questions.length;
        this.scoreDisplay.textContent = `正解数: ${correctCount} / ${answeredCount} (合計: ${totalItems})`;
        this.history.unshift({
            timestamp: new Date().toLocaleString(),
            page: set.title,
            score: `${correctCount} / ${answeredCount}`,
            accuracy: answeredCount > 0 ? Math.round((correctCount / answeredCount) * 100) : 0
        });
        if (this.history.length > 50) this.history.pop();
        this.saveHistory(); this.saveQuestionStats(); this.renderTable();
    }

    renderStats() {
        if (this.history.length === 0) {
            this.totalAccuracy.textContent = "0%"; this.totalAnsweredDisplay.textContent = "0";
            this.historyBody.innerHTML = '<tr><td colspan="4">履歴がありません</td></tr>';
            this.weakQuestionsBody.innerHTML = '<tr><td colspan="4">データがありません</td></tr>';
            return;
        }

        // 全体の正答率と総解答数を、履歴（上限50件）ではなく各問題の統計から算出するように変更
        const allStatsValues = Object.values(this.questionStats);
        const totalCorrect = allStatsValues.reduce((sum, s) => sum + (s.correct || 0), 0);
        const totalTotal = allStatsValues.reduce((sum, s) => sum + (s.total || 0), 0);
        const avg = totalTotal > 0 ? Math.round((totalCorrect / totalTotal) * 100) : 0;

        this.totalAccuracy.textContent = `${avg}%`;
        this.totalAnsweredDisplay.textContent = totalTotal;

        this.historyBody.innerHTML = this.history.map(h => `<tr><td>${h.timestamp}</td><td>${h.page}</td><td>${h.score}</td><td>${h.accuracy}%</td></tr>`).join('');

        const statsArray = Object.values(this.questionStats).map(s => {
            const recent = s.recent || [];
            const rTotal = recent.length;
            const rCorrect = recent.reduce((a, b) => a + b, 0);
            const accuracy = rTotal > 0 ? Math.round((rCorrect / rTotal) * 100) : 0;
            return { ...s, accuracy, rTotal, rCorrect };
        }).filter(s => s.total > 0).sort((a, b) => {
            if (a.accuracy !== b.accuracy) return a.accuracy - b.accuracy;
            return a.total - b.total;
        }).slice(0, 10);

        this.weakQuestionsBody.innerHTML = statsArray.map(s => `<tr><td style="text-align: left;">${s.text}</td><td>${s.page}</td><td>${s.total}</td><td style="color: ${s.accuracy < 50 ? 'var(--error)' : 'var(--text-primary)'}">${s.accuracy}%</td></tr>`).join('');
        this.updateChartTabs(); this.renderChart();
        this.renderUnderstandingMap();
    }

    updateChartTabs() { Object.keys(this.chartBtns).forEach(mode => { this.chartBtns[mode].classList.toggle('active', this.chartMode === mode); }); }

    renderUnderstandingMap() {
        if (!this.understandingMap) return;
        this.understandingMap.innerHTML = '';

        const allQuestions = [];
        this.quizData.forEach(set => {
            if (set.type === 'page' && set.questions) {
                set.questions.forEach(q => {
                    const stat = this.questionStats[q.id] || { correct: 0, total: 0, recent: [] };
                    const recent = stat.recent || [];
                    const rTotal = recent.length;
                    const rCorrect = recent.reduce((a, b) => a + b, 0);
                    const accuracy = rTotal > 0 ? Math.round((rCorrect / rTotal) * 100) : -1;

                    allQuestions.push({
                        id: q.id,
                        type: 'page',
                        text: q.text,
                        page: set.title,
                        accuracy: accuracy,
                        total: stat.total,
                        pageId: set.id
                    });
                });
            } else if (set.type === 'clause' && set.text) {
                const statKey = `clause-summary-${set.id}`;
                const stat = this.questionStats[statKey] || { correct: 0, total: 0, recent: [] };
                const recent = stat.recent || [];
                const accuracy = recent.length > 0 ? Math.round((recent.reduce((a, b) => a + b, 0) / recent.length) * 100) : -1;

                allQuestions.push({
                    id: set.id,
                    type: 'clause',
                    text: `条文暗記: ${set.title}`,
                    page: set.title,
                    accuracy: accuracy,
                    total: stat.total,
                    pageId: set.id
                });
            }
        });

        allQuestions.forEach(q => {
            const cell = document.createElement('div');
            cell.className = 'map-cell';

            let bgColor = 'rgba(255, 255, 255, 0.1)'; // 未学習
            if (q.accuracy !== -1) {
                if (q.accuracy <= 40) bgColor = '#ff4d4d';
                else if (q.accuracy <= 70) bgColor = '#ffb347';
                else bgColor = 'var(--success)';
            }

            cell.style.backgroundColor = bgColor;
            cell.setAttribute('data-tooltip', `【${q.page}】\n${q.text}\n正答率: ${q.accuracy === -1 ? '未解答' : q.accuracy + '%'}`);

            cell.onclick = () => {
                if (q.pageId) {
                    this.switchView('quiz');
                    this.loadSet(q.pageId);
                    if (q.type === 'page') {
                        setTimeout(() => {
                            const row = document.getElementById(`row-${q.id}`);
                            if (row) row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }, 100);
                    }
                }
            };

            this.understandingMap.appendChild(cell);
        });
    }

    renderClauseView(set) {
        this.clauseEditor.classList.toggle('hidden-quiz', !this.isEditMode);
        this.clauseDisplay.classList.remove('hidden');
        this.tableWrapper.classList.add('hidden');
        this.columnControls.classList.add('hidden');
        this.tableControls.classList.add('hidden');

        this.clauseDisplay.innerHTML = '';

        if (this.isEditMode) {
            // Only set value if not focused to avoid cursor jumping and blocking delimiters like commas
            if (document.activeElement !== this.clauseTextEditor) {
                this.clauseTextEditor.value = set.text || '';
            }
            if (document.activeElement !== this.clauseDummiesEditor) {
                this.clauseDummiesEditor.value = (set.dummies || []).join(', ');
            }

            this.clauseTextEditor.oninput = () => {
                set.text = this.clauseTextEditor.value;
                this.saveData();
                this.renderClauseView(set);
            };
            this.clauseDummiesEditor.oninput = () => {
                // We split by both full-width and half-width commas
                set.dummies = this.clauseDummiesEditor.value.split(/[，,]/).map(s => s.trim()).filter(s => s);
                this.saveData();
                this.renderClauseView(set);
            };
        }

        const container = document.createElement('div');
        container.className = 'clause-container';

        const clauseText = document.createElement('div');
        clauseText.className = 'clause-text';

        // Parse [[keyword]]
        const parts = set.text.split(/(\[\[.*?\]\])/g);
        const keywords = [];
        let blankIndex = 0;

        parts.forEach(part => {
            if (part.startsWith('[[') && part.endsWith(']]')) {
                const keyword = part.substring(2, part.length - 2);
                keywords.push(keyword);

                const blank = document.createElement('div');
                blank.className = 'clause-blank';
                const currentIdx = blankIndex;
                blank.id = `blank-${currentIdx}`;

                const savedAnswer = this.userAnswers[`${set.id}-${currentIdx}`];
                if (savedAnswer) {
                    blank.textContent = savedAnswer;
                    blank.classList.add('filled');
                } else {
                    blank.innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'; // Minimum visibility
                }

                // Drag and Drop for Blanks
                blank.ondragover = (e) => {
                    if (this.isChecked) return;
                    e.preventDefault();
                    blank.classList.add('drag-over');
                };
                blank.ondragleave = () => blank.classList.remove('drag-over');
                blank.ondrop = (e) => {
                    if (this.isChecked) return;
                    e.preventDefault();
                    blank.classList.remove('drag-over');
                    const text = e.dataTransfer.getData('text/plain');
                    if (text) {
                        this.userAnswers[`${set.id}-${currentIdx}`] = text;
                        this.renderClauseView(set); // Use local render to avoid flickering
                    }
                };
                blank.onclick = () => {
                    if (!this.isChecked) {
                        delete this.userAnswers[`${set.id}-${currentIdx}`];
                        this.renderClauseView(set);
                    }
                };

                if (this.isChecked) {
                    const isCorrect = savedAnswer === keyword;
                    blank.classList.add(isCorrect ? 'correct' : 'wrong');
                    if (!isCorrect) {
                        const reveal = document.createElement('span');
                        reveal.className = 'reveal-correct';
                        reveal.textContent = ` (正解: ${keyword})`;
                        blank.appendChild(reveal);
                    }
                }

                clauseText.appendChild(blank);
                blankIndex++;
            } else {
                clauseText.appendChild(document.createTextNode(part));
            }
        });

        container.appendChild(clauseText);
        this.clauseDisplay.appendChild(container);

        // Keyword Bank
        if (!this.isChecked) {
            const bank = document.createElement('div');
            bank.className = 'keyword-bank';

            const allOptions = [...new Set([...keywords, ...(set.dummies || [])])];

            // Use cached shuffle or create new
            if (!this.shuffledCache[set.id]) {
                this.shuffledCache[set.id] = allOptions.sort(() => Math.random() - 0.5);
            }
            const shuffled = this.shuffledCache[set.id];

            // Track how many times each word is used in answers
            const usedCounts = {};
            Object.keys(this.userAnswers).forEach(key => {
                if (key.startsWith(`${set.id}-`)) {
                    const ans = this.userAnswers[key];
                    usedCounts[ans] = (usedCounts[ans] || 0) + 1;
                }
            });

            shuffled.forEach(word => {
                // If a word is already used in a blank, we can either hide it or grey it out.
                // Since a word might be the answer for multiple blanks, we should only hide/grey if used too many times.
                // But for simplicity, let's just let it stay but grey out if used at least once? 
                // Actually, standard quizzes often just let the card stay.
                const isUsed = usedCounts[word] > 0;

                const card = document.createElement('div');
                card.className = `keyword-card ${isUsed ? 'used' : ''}`;
                card.textContent = word;
                card.draggable = true;

                card.ondragstart = (e) => {
                    e.dataTransfer.setData('text/plain', word);
                    card.classList.add('dragging');
                };
                card.ondragend = () => card.classList.remove('dragging');

                bank.appendChild(card);
            });
            this.clauseDisplay.appendChild(bank);
        }
    }

    renderChart() {
        const ctx = document.getElementById('statsChart').getContext('2d');
        if (this.statsChart) this.statsChart.destroy();
        const allStats = Object.values(this.questionStats).filter(s => s.total > 0).map(s => {
            const recent = s.recent || [];
            const rTotal = recent.length;
            const rCorrect = recent.reduce((a, b) => a + b, 0);
            const accuracy = rTotal > 0 ? Math.round((rCorrect / rTotal) * 100) : 0;
            const errors = rTotal - rCorrect;
            return { ...s, accuracy, errors, rTotal, rCorrect };
        });
        let sortedStats, data, label, color;
        if (this.chartMode === 'accuracy') { sortedStats = allStats.sort((a, b) => a.accuracy - b.accuracy).slice(0, 10); data = sortedStats.map(s => s.accuracy); label = '正答率 (%)'; color = '#4cc9f0'; }
        else if (this.chartMode === 'frequency') { sortedStats = allStats.sort((a, b) => b.total - a.total).slice(0, 10); data = sortedStats.map(s => s.total); label = '解答回数 (回)'; color = '#f72585'; }
        else { sortedStats = allStats.sort((a, b) => b.errors - a.errors).slice(0, 10); data = sortedStats.map(s => s.errors); label = '最近の誤答回数 (回/5回中)'; color = '#ff9f1c'; }
        const labels = sortedStats.map(s => s.text.length > 8 ? s.text.substring(0, 7) + '...' : s.text);
        this.statsChart = new Chart(ctx, {
            type: 'bar', data: { labels: labels, datasets: [{ label: label, data: data, backgroundColor: color + 'dd', borderColor: color, borderWidth: 1, borderRadius: 8 }] },
            options: { responsive: true, maintainAspectRatio: false, indexAxis: 'y', plugins: { legend: { display: false }, tooltip: { callbacks: { title: (items) => sortedStats[items[0].dataIndex].text, label: (item) => `${label}: ${item.raw}` } } }, scales: { x: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: 'rgba(255,255,255,0.6)' } }, y: { grid: { display: false }, ticks: { color: 'rgba(255,255,255,0.8)', font: { size: 12 } } } } }
        });
    }

    generateSpecialQuiz(type) {
        const allQuestions = [];
        let maxCols = 2;
        let bestCols = ["項目", "選択肢"];

        this.quizData.forEach(set => {
            if (!this.isItemSelectedForPool(set.id)) return;

            if (set.type === 'page' && set.questions) {
                if (set.columns && set.columns.length > maxCols) {
                    maxCols = set.columns.length;
                    bestCols = [...set.columns];
                }
                set.questions.forEach(q => {
                    if (q.isInPool === false) return;
                    const stat = this.questionStats[q.id] || { correct: 0, total: 0, recent: [] };
                    const recent = stat.recent || [];
                    const accuracy = recent.length > 0 ? (recent.reduce((a, b) => a + b, 0) / recent.length) : -1;

                    allQuestions.push({
                        id: q.id,
                        type: 'page',
                        text: q.text,
                        answer: q.answer,
                        memo: q.memo || '',
                        origPage: set.title,
                        columns: set.columns,
                        accuracy: accuracy,
                        total: stat.total,
                        isMultiSelect: set.isMultiSelect
                    });
                });
            } else if (type === 'clause-weak' && set.type === 'clause' && set.text) {
                const statKey = `clause-summary-${set.id}`;
                const stat = this.questionStats[statKey] || { correct: 0, total: 0, recent: [] };
                const recent = stat.recent || [];
                const accuracy = recent.length > 0 ? (recent.reduce((a, b) => a + b, 0) / recent.length) : -1;

                allQuestions.push({
                    id: set.id,
                    type: 'clause',
                    text: set.text,
                    dummies: set.dummies,
                    origPage: set.title,
                    accuracy: accuracy,
                    total: stat.total,
                    isMultiSelect: false
                });
            }
        });

        if (allQuestions.length === 0) {
            alert('特訓の対象となる問題がありません。サイドバーのチェックボックスを入れて対象を選択してください。');
            return;
        }

        let filtered, title;
        if (type === 'weak') {
            title = "特訓：苦手な問題ワースト10";
            filtered = allQuestions.filter(q => q.total > 0).sort((a, b) => {
                if (a.accuracy !== b.accuracy) return a.accuracy - b.accuracy;
                return b.total - a.total;
            }).slice(0, 10);
            if (filtered.length === 0) {
                alert('まだ間違えた記録がありません。まずは普通に学習して回答を記録してください。');
                return;
            }
        } else if (type === 'clause-weak') {
            title = "特訓：苦手な条文ワースト3";
            filtered = allQuestions.filter(q => q.total > 0).sort((a, b) => {
                if (a.accuracy !== b.accuracy) return a.accuracy - b.accuracy;
                return b.total - a.total;
            }).slice(0, 3);
            if (filtered.length === 0) {
                alert('まだ間違えた記録のある条文がありません。まずは各ページから条文暗記に取り組んでください。');
                return;
            }
        } else if (type === 'random') {
            title = "特訓：全問題からランダム10問";
            filtered = allQuestions.sort(() => Math.random() - 0.5).slice(0, 10);
        } else {
            title = "特訓：未学習・低頻度な問題10問";
            filtered = allQuestions.sort((a, b) => {
                if (a.total !== b.total) return a.total - b.total;
                return a.accuracy - b.accuracy;
            }).slice(0, 10);
        }

        // Recalculate optimal columns - use UNION of all columns to ensure compatibility
        let finalBestCols = ["項目"];
        const colSet = new Set();
        filtered.forEach(q => {
            if (q.type === 'page' && q.columns) {
                // Skip the first column '項目' which we already added
                for (let i = 1; i < q.columns.length; i++) {
                    colSet.add(q.columns[i]);
                }
            }
        });
        if (colSet.size > 0) {
            finalBestCols = ["項目", ...Array.from(colSet)];
        } else if (filtered.every(q => q.type === 'clause')) {
            finalBestCols = ["条文内容"];
        } else {
            finalBestCols = ["項目", "選択肢"];
        }
        bestCols = finalBestCols;

        this.autoGeneratedSet = {
            id: 'temp-autogen',
            title: title,
            questions: filtered,
            columns: bestCols
        };
        this.isAutoGenerated = true;
        this.switchView('quiz');
        this.loadSet('temp-autogen');
    }

    renderTable() {
        const set = this.isAutoGenerated ? this.autoGeneratedSet : this.quizData.find(s => s.id === this.currentSetId);
        if (!set || set.type === 'folder') {
            this.tableBody.innerHTML = '';
            this.tableHead.innerHTML = '';
            this.quizTitle.textContent = set ? set.title : '問題を選択してください';
            return;
        }

        if (set.type === 'clause') {
            this.renderClauseView(set);
            return;
        } else {
            this.clauseEditor.classList.add('hidden-quiz');
            this.clauseDisplay.classList.add('hidden');
            this.clauseDisplay.innerHTML = '';
            this.tableWrapper.classList.remove('hidden');
            this.columnControls.classList.toggle('hidden', !this.isEditMode);
            this.tableControls.classList.toggle('hidden', !this.isEditMode);
        }

        this.tableHead.innerHTML = '';
        const headTr = document.createElement('tr');
        if (this.isAutoGenerated) {
            // Use set.columns which was computed in generateSpecialQuiz
            const cols = set.columns || ["項目", "選択肢"];
            headTr.innerHTML = `<th>${cols[0]}</th>`;
            for (let i = 1; i < cols.length; i++) {
                const th = document.createElement('th');
                th.textContent = cols[i];
                headTr.appendChild(th);
            }
        } else {
            // Pool inclusion checkbox header
            if (this.isEditMode) {
                const thPool = document.createElement('th');
                thPool.innerHTML = '特訓';
                thPool.className = 'pool-cell';
                thPool.title = '特訓（お任せ問題）の対象に含めるか';
                headTr.appendChild(thPool);
            }

            set.columns.forEach((col, index) => {
                const th = document.createElement('th');
                const span = document.createElement('span');
                span.textContent = col;
                if (this.isEditMode) {
                    span.contentEditable = true;
                    span.onblur = () => {
                        const oldVal = col;
                        const newVal = span.textContent.trim();
                        if (oldVal !== newVal) {
                            set.columns[index] = newVal;
                            set.questions.forEach(q => {
                                if (Array.isArray(q.answer)) {
                                    q.answer = q.answer.map(a => a === oldVal ? newVal : a);
                                } else if (q.answer === oldVal) q.answer = newVal;
                            });
                            this.saveData();
                            this.renderTable();
                        }
                    };
                    if (index > 0) {
                        const delBtn = document.createElement('span');
                        delBtn.className = 'delete-col-btn';
                        delBtn.innerHTML = '×';
                        delBtn.onclick = (e) => {
                            e.stopPropagation();
                            this.deleteColumn(index);
                        };
                        th.appendChild(delBtn);
                    }
                }
                th.appendChild(span);
                headTr.appendChild(th);
            });
        }
        this.tableHead.appendChild(headTr);
        this.tableBody.innerHTML = '';
        set.questions.forEach((q) => {
            const tr = document.createElement('tr'); tr.id = `row-${q.id}`;
            const isSetMulti = this.isAutoGenerated ? q.isMultiSelect : set.isMultiSelect;

            if (this.isChecked) {
                const userAnswer = this.userAnswers[q.id];
                if (userAnswer && (!Array.isArray(userAnswer) || userAnswer.length > 0)) {
                    let isAllCorrect = false;
                    if (isSetMulti) {
                        const correctSet = new Set(q.answer); const userSet = new Set(userAnswer);
                        isAllCorrect = (correctSet.size === userSet.size && [...correctSet].every(item => userSet.has(item)));
                    } else { isAllCorrect = userAnswer === q.answer; }
                    tr.classList.add(isAllCorrect ? 'row-correct' : 'row-wrong');
                }
            }
            const tdQ = document.createElement('td'); tdQ.className = 'question-cell';
            if (q.type === 'clause') {
                // Render sub-clause view for special quiz
                const wrapper = document.createElement('div');
                wrapper.className = 'table-clause-wrapper';
                const badge = document.createElement('span');
                badge.className = 'clause-badge';
                badge.textContent = q.origPage || "条文";
                wrapper.appendChild(badge);

                const cText = document.createElement('div');
                cText.className = 'clause-text-mini';
                const parts = q.text.split(/(\[\[.*?\]\])/g);
                let blankIdx = 0;
                parts.forEach(part => {
                    if (part.startsWith('[[') && part.endsWith(']]')) {
                        const keyword = part.substring(2, part.length - 2);
                        const blank = document.createElement('div');
                        blank.className = 'clause-blank';
                        const currentIdx = blankIdx;
                        const savedAnswer = this.userAnswers[`${q.id}-${currentIdx}`];
                        if (savedAnswer) {
                            blank.textContent = savedAnswer;
                            blank.classList.add('filled');
                        } else {
                            blank.innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;';
                        }

                        if (!this.isChecked) {
                            blank.ondragover = (e) => { e.preventDefault(); blank.classList.add('drag-over'); };
                            blank.ondragleave = () => blank.classList.remove('drag-over');
                            blank.ondrop = (e) => {
                                e.preventDefault(); blank.classList.remove('drag-over');
                                const text = e.dataTransfer.getData('text/plain');
                                if (text) { this.userAnswers[`${q.id}-${currentIdx}`] = text; this.renderTable(); }
                            };
                            blank.onclick = () => { delete this.userAnswers[`${q.id}-${currentIdx}`]; this.renderTable(); };
                        } else {
                            const isCorrect = savedAnswer === keyword;
                            blank.classList.add(isCorrect ? 'correct' : 'wrong');
                            if (!isCorrect) {
                                const reveal = document.createElement('span');
                                reveal.className = 'reveal-correct'; reveal.textContent = ` (${keyword})`;
                                blank.appendChild(reveal);
                            }
                        }
                        cText.appendChild(blank);
                        blankIdx++;
                    } else {
                        cText.appendChild(document.createTextNode(part));
                    }
                });
                wrapper.appendChild(cText);
                tdQ.appendChild(wrapper);

                // Add local keyword bank for this clause
                if (!this.isChecked) {
                    const keywords = new Set();
                    const kws = q.text.match(/\[\[(.*?)\]\]/g) || [];
                    kws.forEach(k => keywords.add(k.substring(2, k.length - 2)));
                    if (q.dummies) q.dummies.forEach(d => keywords.add(d));

                    if (keywords.size > 0) {
                        const bankContainer = document.createElement('div');
                        bankContainer.className = 'keyword-bank';
                        bankContainer.style.marginTop = '1rem';
                        bankContainer.style.background = 'rgba(0,0,0,0.1)';
                        bankContainer.style.padding = '10px';
                        bankContainer.style.borderRadius = '8px';

                        const cacheKey = `bank-${q.id}`;
                        if (!this.shuffledCache[cacheKey]) {
                            this.shuffledCache[cacheKey] = [...keywords].sort(() => Math.random() - 0.5);
                        }
                        const shuffled = this.shuffledCache[cacheKey];

                        shuffled.forEach(word => {
                            const card = document.createElement('div');
                            card.className = 'keyword-card';
                            card.textContent = word;
                            card.draggable = true;
                            card.ondragstart = (e) => {
                                e.dataTransfer.setData('text/plain', word);
                                card.classList.add('dragging');
                            };
                            card.ondragend = () => card.classList.remove('dragging');
                            bankContainer.appendChild(card);
                        });
                        tdQ.appendChild(bankContainer);
                    }
                }
                tdQ.colSpan = set.columns.length;
            } else if (this.isEditMode && !this.isAutoGenerated) {
                const rowControls = document.createElement('div');
                rowControls.className = 'row-edit-controls';

                const delBtn = document.createElement('span'); delBtn.className = 'delete-row-btn'; delBtn.innerHTML = '×';
                delBtn.title = '行を削除';
                delBtn.onclick = () => this.deleteRow(q.id);

                const upBtn = document.createElement('span'); upBtn.className = 'move-row-btn'; upBtn.innerHTML = '↑';
                upBtn.title = '上に移動';
                upBtn.onclick = () => this.moveRow(q.id, -1);

                const downBtn = document.createElement('span'); downBtn.className = 'move-row-btn'; downBtn.innerHTML = '↓';
                downBtn.title = '下に移動';
                downBtn.onclick = () => this.moveRow(q.id, 1);

                rowControls.appendChild(delBtn);
                rowControls.appendChild(upBtn);
                rowControls.appendChild(downBtn);
                tdQ.appendChild(rowControls);
            }
            if (this.isAutoGenerated && q.origPage) { const tag = document.createElement('div'); tag.className = 'page-tag'; tag.textContent = q.origPage; tdQ.appendChild(tag); }

            // Pool inclusion checkbox cell
            if (!this.isAutoGenerated && this.isEditMode) {
                const tdPool = document.createElement('td');
                tdPool.className = 'pool-cell';
                const poolCheck = document.createElement('input');
                poolCheck.type = 'checkbox';
                poolCheck.checked = q.isInPool !== false;
                poolCheck.onchange = (e) => {
                    q.isInPool = e.target.checked;
                    this.saveData();
                };
                tdPool.appendChild(poolCheck);
                tr.appendChild(tdPool);
            }

            // Standard text rendering - SKIP if it's a clause as it's already rendered above
            if (q.type !== 'clause') {
                const spanText = document.createElement('span'); spanText.textContent = q.text;
                if (this.isEditMode && !this.isAutoGenerated) { spanText.contentEditable = true; spanText.onblur = () => { q.text = spanText.textContent.trim(); this.saveData(); }; }
                tdQ.appendChild(spanText);

                // Memo block
                if (this.isEditMode && !this.isAutoGenerated) {
                    const memoEl = document.createElement('div');
                    memoEl.className = 'memo-input';
                    memoEl.placeholder = 'メモ・解説を入力...';
                    memoEl.contentEditable = true;
                    memoEl.textContent = q.memo || '';
                    memoEl.onblur = () => { q.memo = memoEl.textContent.trim(); this.saveData(); };
                    tdQ.appendChild(memoEl);
                } else if (this.isChecked && q.memo) {
                    const memoEl = document.createElement('div');
                    memoEl.className = 'memo-display';
                    memoEl.innerHTML = `<strong>解説:</strong> ${q.memo.replace(/\n/g, '<br>')}`;
                    tdQ.appendChild(memoEl);
                }
            }

            tr.appendChild(tdQ);

            if (q.type !== 'clause') {
                // Use the header's columns to ensure all rows are the same width
                for (let i = 1; i < set.columns.length; i++) {
                    const colLabel = set.columns[i];
                    const choiceName = (!q.columns || q.columns.includes(colLabel)) ? colLabel : '';
                    const td = document.createElement('td');
                    td.className = 'choice-cell';
                    if (choiceName) {
                        td.textContent = choiceName;
                    } else {
                        td.textContent = '';
                        td.style.pointerEvents = 'none';
                    }
                    if (isSetMulti) td.classList.add('multi-select');

                    if (this.isEditMode && !this.isAutoGenerated) {
                        const isCorrect = isSetMulti ? (Array.isArray(q.answer) && q.answer.includes(choiceName)) : (q.answer === choiceName);
                        if (isCorrect) td.classList.add(isSetMulti ? 'multi-selected' : 'correct');
                        td.onclick = () => {
                            if (isSetMulti) {
                                if (!Array.isArray(q.answer)) q.answer = [];
                                if (q.answer.includes(choiceName)) q.answer = q.answer.filter(a => a !== choiceName);
                                else q.answer.push(choiceName);
                            } else { q.answer = choiceName; }
                            this.saveData(); this.renderTable();
                        };
                    } else {
                        const userAnswer = this.userAnswers[q.id];
                        const isSelected = isSetMulti ? (Array.isArray(userAnswer) && userAnswer.includes(choiceName)) : (userAnswer === choiceName);

                        if (this.isChecked) {
                            const isCorrectAnswer = isSetMulti ? (Array.isArray(q.answer) && q.answer.includes(choiceName)) : (q.answer === choiceName);
                            if (isCorrectAnswer) td.classList.add('correct');
                            else if (isSelected) td.classList.add('wrong');
                        } else if (isSelected) td.classList.add('selected');

                        td.onclick = () => {
                            if (!this.isChecked) {
                                if (isSetMulti) {
                                    if (!Array.isArray(this.userAnswers[q.id])) this.userAnswers[q.id] = [];
                                    if (this.userAnswers[q.id].includes(choiceName)) this.userAnswers[q.id] = this.userAnswers[q.id].filter(a => a !== choiceName);
                                    else this.userAnswers[q.id].push(choiceName);
                                } else { this.userAnswers[q.id] = choiceName; }
                                this.renderTable();
                            }
                        };
                    }
                    tr.appendChild(td);
                }
            }
            this.tableBody.appendChild(tr);
        });
    }

    deleteRow(id) {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (set.questions.length <= 1) { alert('最低1行は必要です。'); return; }
        if (confirm('この行を削除しますか？')) {
            set.questions = set.questions.filter(q => q.id !== id);
            this.saveData(); this.renderTable();
        }
    }

    moveRow(id, direction) {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        const index = set.questions.findIndex(q => q.id === id);
        if (index === -1) return;

        const newIndex = index + direction;
        if (newIndex < 0 || newIndex >= set.questions.length) return;

        // Swap
        const temp = set.questions[index];
        set.questions[index] = set.questions[newIndex];
        set.questions[newIndex] = temp;

        this.saveData();
        this.renderTable();
    }

    deleteColumn(index) {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (set.columns.length <= 2) { alert('最低1つの選択肢は必要です。'); return; }
        const colName = set.columns[index];
        if (confirm(`列「${colName}」を削除しますか？`)) {
            set.columns.splice(index, 1);
            set.questions.forEach(q => {
                if (Array.isArray(q.answer)) q.answer = q.answer.filter(a => a !== colName);
                else if (q.answer === colName) q.answer = set.columns[1];
            });
            this.saveData(); this.renderTable();
        }
    }

    renderTOC() {
        // Build a flat list in order of display (DFS)
        const getFlatDisplayList = (parentId = null, depth = 0) => {
            let result = [];
            const items = this.quizData.filter(item => item.parentId === parentId);
            items.forEach(item => {
                const globalIndex = this.quizData.findIndex(d => d.id === item.id);
                result.push({ ...item, depth, globalIndex });
                if (item.type === 'folder' && !item.isCollapsed) {
                    result = result.concat(getFlatDisplayList(item.id, depth + 1));
                }
            });
            return result;
        };

        const list = getFlatDisplayList(null, 0);

        this.tocList.innerHTML = list.map(s => {
            const isFolder = s.type === 'folder';
            const isActive = s.id === this.currentSetId && !this.isAutoGenerated && !isFolder;
            const indent = s.depth * 15;

            return `
            <li class="${isActive ? 'active' : ''} ${isFolder ? 'type-folder' : 'type-page'}" 
                style="padding-left: ${indent}px"
                draggable="${this.isEditMode}" 
                ondragstart="app.handleDragStart(event, '${s.id}')" 
                ondragover="app.handleDragOver(event, '${s.id}')" 
                ondrop="app.handleDrop(event, '${s.id}')" 
                ondragend="app.handleDragEnd(event)">
                <div class="item-container ${isFolder ? 'folder-item' : ''}">
                    ${isFolder ? `
                        <span class="folder-toggle" onclick="event.stopPropagation(); app.toggleFolder('${s.id}')">
                            ${s.isCollapsed ? '▶' : '▼'}
                        </span>
                        <span class="folder-icon">${s.isCollapsed ? '📁' : '📂'}</span>
                    ` : ''}
                    <input type="checkbox" class="toc-pool-checkbox" 
                           ${s.isInPool ? 'checked' : ''} 
                           onclick="event.stopPropagation(); app.toggleItemPool('${s.id}')" 
                           title="特訓対象に含める">
                    <a href="#${s.id}" draggable="false" onclick="if('${isFolder}' === 'true') { event.preventDefault(); app.toggleFolder('${s.id}'); }">
                        ${s.title}
                    </a>
                    <div class="reorder-btns">
                        <button class="reorder-btn" onclick="event.stopPropagation(); app.movePageById('${s.id}', -1)">▲</button>
                        <button class="reorder-btn" onclick="event.stopPropagation(); app.movePageById('${s.id}', 1)">▼</button>
                        ${isFolder ? `
                            <button class="reorder-btn" title="子フォルダを追加" onclick="event.stopPropagation(); app.addNewFolder('${s.id}')">＋📁</button>
                            <button class="reorder-btn" title="通常ページを追加" onclick="event.stopPropagation(); app.addNewPage('${s.id}')">＋📄</button>
                            <button class="reorder-btn" title="条文穴埋めを追加" onclick="event.stopPropagation(); app.addNewClausePage('${s.id}')">＋🔤</button>
                            <button class="reorder-btn delete-folder-btn" onclick="event.stopPropagation(); app.deleteFolder('${s.id}')">×</button>
                        ` : ''}
                    </div>
                </div>
            </li>`;
        }).join('');
    }

    handleDragStart(e, id) {
        if (!this.isEditMode) return;
        this.draggedItemId = id;
        e.dataTransfer.setData('text/plain', id);
        e.currentTarget.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
    }

    handleDragOver(e, id) {
        if (!this.isEditMode) return;
        e.preventDefault();
        const li = e.currentTarget;
        if (id === this.draggedItemId) return;

        const targetItem = this.quizData.find(i => i.id === id);
        if (!targetItem) return;

        // Clean up previous classes
        li.classList.remove('drag-over-top', 'drag-over-bottom', 'drag-over-folder');

        const rect = li.getBoundingClientRect();
        const relativeY = e.clientY - rect.top;
        const height = rect.height;

        if (targetItem.type === 'folder') {
            if (relativeY < height * 0.25) {
                li.classList.add('drag-over-top');
                this.dropPosition = 'above';
            } else if (relativeY > height * 0.75) {
                li.classList.add('drag-over-bottom');
                this.dropPosition = 'below';
            } else {
                li.classList.add('drag-over-folder');
                this.dropPosition = 'inside';
            }
        } else {
            if (relativeY < height / 2) {
                li.classList.add('drag-over-top');
                this.dropPosition = 'above';
            } else {
                li.classList.add('drag-over-bottom');
                this.dropPosition = 'below';
            }
        }
    }

    isDescendant(targetId, potentialParentId) {
        let currentParentId = potentialParentId;
        while (currentParentId) {
            if (currentParentId === targetId) return true;
            const parent = this.quizData.find(i => i.id === currentParentId);
            currentParentId = parent ? parent.parentId : null;
        }
        return false;
    }

    handleDrop(e, id) {
        if (!this.isEditMode) return;
        e.preventDefault();
        const targetItem = this.quizData.find(i => i.id === id);
        const draggedItem = this.quizData.find(i => i.id === this.draggedItemId);

        if (!draggedItem || !targetItem || draggedItem.id === id) return;

        if (draggedItem.type === 'folder' && this.isDescendant(draggedItem.id, id)) {
            alert('フォルダを自分自身の子要素に移動することはできません。');
            return;
        }

        const data = [...this.quizData];
        const itemIdx = data.findIndex(i => i.id === this.draggedItemId);
        if (itemIdx === -1) return;
        const item = data.splice(itemIdx, 1)[0];

        if (this.dropPosition === 'inside' && targetItem.type === 'folder') {
            item.parentId = targetItem.id;
            targetItem.isCollapsed = false;
            data.push(item);
        } else {
            item.parentId = targetItem.parentId;
            let targetIdx = data.findIndex(d => d.id === id);
            if (this.dropPosition === 'below') targetIdx++;
            data.splice(targetIdx, 0, item);
        }

        this.quizData = data;
        this.saveData();
        this.renderTOC();
    }

    handleDragEnd(e) {
        this.draggedItemId = null;
        this.renderTOC();
    }

    movePageById(id, direction) {
        const index = this.quizData.findIndex(i => i.id === id);
        if (index !== -1) this.movePage(index, direction);
    }

    toggleFolder(id) {
        const folder = this.quizData.find(s => s.id === id);
        if (folder && folder.type === 'folder') {
            folder.isCollapsed = !folder.isCollapsed;
            this.saveData();
            this.renderTOC();
        }
    }

    toggleItemPool(id) {
        const item = this.quizData.find(s => s.id === id);
        if (item) {
            item.isInPool = !item.isInPool;
            this.saveData();
            this.renderTOC();
        }
    }

    isItemSelectedForPool(itemId) {
        let currentId = itemId;
        while (currentId) {
            const item = this.quizData.find(i => i.id === currentId);
            if (!item) break;
            if (item.isInPool) return true;
            currentId = item.parentId;
        }
        return false;
    }

    deleteFolder(id) {
        if (!this.isEditMode) return;
        const folder = this.quizData.find(s => s.id === id);
        if (!folder) return;

        const children = this.quizData.filter(item => item.parentId === id);
        let msg = `フォルダ「${folder.title}」を削除しますか？`;
        if (children.length > 0) {
            msg += `\n\n注意：中身の問題（${children.length}件）は削除されませんが、フォルダから出されます。`;
        }

        if (confirm(msg)) {
            // Unparent children
            children.forEach(child => child.parentId = null);
            // Remove folder
            this.quizData = this.quizData.filter(s => s.id !== id);
            this.saveData();
            this.renderTOC();
        }
    }

    addNewFolder(parentId = null) {
        const title = prompt('フォルダ名:');
        if (!title) return;
        const id = 'f-' + Date.now();
        this.quizData.push({
            id, title, type: 'folder', parentId: parentId, isCollapsed: false
        });
        if (parentId) {
            const parent = this.quizData.find(p => p.id === parentId);
            if (parent) parent.isCollapsed = false;
        }
        this.saveData();
        this.renderTOC();
    }

    movePage(index, direction) {
        const itemsAtSameLevel = this.quizData.filter(item => item.parentId === this.quizData[index].parentId);
        const localIndex = itemsAtSameLevel.findIndex(item => item.id === this.quizData[index].id);
        const newLocalIndex = localIndex + direction;

        if (newLocalIndex < 0 || newLocalIndex >= itemsAtSameLevel.length) return;

        const targetGlobalIndex = this.quizData.findIndex(item => item.id === itemsAtSameLevel[newLocalIndex].id);

        const temp = this.quizData[index];
        this.quizData[index] = this.quizData[targetGlobalIndex];
        this.quizData[targetGlobalIndex] = temp;

        this.saveData();
        this.renderTOC();
    }

    updateActiveTOC(id) {
        this.tocList.querySelectorAll('li').forEach(li => {
            const a = li.querySelector('a');
            const isActive = a && a.getAttribute('href') === `#${id}`;
            li.classList.toggle('active', isActive);
        });
    }

    addNewPage(parentId = null) {
        const title = prompt('タイトル:'); if (!title) return;
        const isMulti = confirm('複数選択（ランキング形式）にしますか？\nOK: 複数選択, キャンセル: 単一選択');
        const id = 'p-' + Date.now();
        const cols = isMulti ? [
            "順位", "【生計維持】", "【生計同一】", "配偶者", "子", "父母", "孫", "祖父母", "兄弟姉妹", "3親等以内", "対象なし"
        ] : ["項目", "選択1", "選択2"];

        const questions = [];
        if (isMulti) {
            for (let i = 1; i <= 6; i++) {
                questions.push({ id: 'q-' + Date.now() + i, text: `第${i}順位`, answer: [] });
            }
        } else {
            questions.push({ id: 'q-' + Date.now(), text: "新問題", answer: cols[1] });
        }

        const newPage = {
            id, title, type: 'page', parentId: parentId, isMultiSelect: isMulti,
            columns: cols,
            questions: questions
        };

        // If current viewing is a folder, maybe add to it? For now, just add to root
        this.quizData.push(newPage);

        this.isAutoGenerated = false;
        this.saveData();
        this.renderTOC();
        this.loadSet(id);

        // Scroll to the new page in the sidebar
        setTimeout(() => {
            const newElem = this.tocList.querySelector(`a[href="#${id}"]`);
            if (newElem) newElem.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 100);
    }

    addNewClausePage(parentId = null) {
        const title = prompt('条文穴埋め問題のタイトル:'); if (!title) return;
        const id = 'p-' + Date.now();
        const newPage = {
            id, title, type: 'clause', parentId: parentId,
            text: 'ここに条文を入力してください。[[キーワード]]のように囲むとそこが穴埋めになります。',
            dummies: ''
        };
        this.quizData.push(newPage);
        this.saveData();
        this.renderTOC();
        this.loadSet(id);

        setTimeout(() => {
            const newElem = this.tocList.querySelector(`a[href="#${id}"]`);
            if (newElem) newElem.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 100);
    }

    addNewRow() {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        set.questions.push({
            id: 'q-' + Date.now(),
            text: "新問題...",
            memo: "",
            answer: set.isMultiSelect ? [] : set.columns[1]
        });
        this.saveData();
        this.renderTable();
    }
    addNewColumn() { if (this.isAutoGenerated) return; const set = this.quizData.find(s => s.id === this.currentSetId); const name = prompt('列名:'); if (!name) return; set.columns.push(name); this.saveData(); this.renderTable(); }

    deleteCurrentPage() {
        if (this.quizData.length <= 1 || this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (confirm(`このページ（${set.title}）の全問題データを削除しますか？\nこの操作は取り消せません。`)) {
            this.quizData = this.quizData.filter(s => s.id !== this.currentSetId);
            this.saveData(); this.currentSetId = this.quizData[0].id; this.renderTOC(); this.loadSet(this.currentSetId);
        }
    }

    cloneCurrentPage() {
        if (this.isAutoGenerated) return;
        const set = this.quizData.find(s => s.id === this.currentSetId);
        if (!set) return;

        const newId = 'p-' + Date.now();
        const clonedSet = JSON.parse(JSON.stringify(set));
        clonedSet.id = newId;
        clonedSet.title = clonedSet.title + '（コピー）';

        // Re-generate question IDs to avoid conflicts and start fresh stats
        clonedSet.questions.forEach((q, i) => {
            q.id = 'q-' + Date.now() + '-' + i + '-' + Math.random().toString(36).substr(2, 5);
        });

        this.quizData.push(clonedSet);
        this.saveData();
        this.isAutoGenerated = false;
        this.renderTOC();
        this.loadSet(newId);
    }

    clearData() {
        const input = prompt('すべての学習データと履歴を完全に削除しますか？\n削除する場合は、確認のため「RESET」と入力してください。\n注：事前に「バックアップ保存」を行うことをお勧めします。');
        if (input === 'RESET') { localStorage.clear(); window.location.reload(); } else if (input !== null) { alert('入力が正しくないため、削除はキャンセルされました。'); }
    }

    // --- Data Management (Export/Import) ---

    getTimestamp() {
        const now = new Date();
        const pad = (n) => n.toString().padStart(2, '0');
        return `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    }

    async exportToJSON() {
        const fullData = {
            quizData: this.quizData,
            history: this.history,
            questionStats: this.questionStats,
            exportedAt: new Date().toISOString()
        };
        const fileName = `sharo_study_backup_${this.getTimestamp()}.json`;
        const jsonContent = JSON.stringify(fullData, null, 2);

        // Try File System Access API for folder selection
        if (window.showSaveFilePicker) {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{ description: 'JSON File', accept: { 'application/json': ['.json'] } }]
                });
                const writable = await handle.createWritable();
                await writable.write(jsonContent);
                await writable.close();
                this.updateDataStatus("JSONを保存しました。");
                return;
            } catch (err) {
                if (err.name === 'AbortError') return;
                console.error("showSaveFilePicker failed:", err);
            }
        }

        // Fallback for older browsers
        const blob = new Blob([jsonContent], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
        this.updateDataStatus("JSON形式でエクスポートしました（ダウンロードフォルダに保存）。");
    }

    async exportToCSV() {
        // CSV is focused on quiz questions only (for spreadsheet editing)
        let csv = '\uFEFF'; // UTF-8 BOM
        csv += 'ページタイトル,ID,問題文,正解(カンマ区切り),解説,選択肢1,選択肢2,選択肢3,選択肢4,選択肢5,選択肢6,選択肢7,選択肢8,選択肢9,選択肢10\n';

        this.quizData.forEach(page => {
            if (page.type !== 'page' || !page.questions) return;
            page.questions.forEach(q => {
                const row = [
                    page.title,
                    q.id,
                    q.text,
                    Array.isArray(q.answer) ? q.answer.join('|') : q.answer,
                    q.memo || '',
                    ...(page.columns.slice(1)) // choice choices
                ].map(val => `"${(val || "").toString().replace(/"/g, '""')}"`).join(',');
                csv += row + '\n';
            });
        });

        const fileName = `sharo_questions_${this.getTimestamp()}.csv`;

        if (window.showSaveFilePicker) {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{ description: 'CSV File', accept: { 'text/csv': ['.csv'] } }]
                });
                const writable = await handle.createWritable();
                await writable.write(csv);
                await writable.close();
                this.updateDataStatus("CSVを保存しました。");
                return;
            } catch (err) {
                if (err.name === 'AbortError') return;
                console.error("showSaveFilePicker failed:", err);
            }
        }

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
        this.updateDataStatus("CSV形式でエクスポートしました（ダウンロードフォルダに保存）。");
    }

    handleFileImport(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            const content = event.target.result;
            if (file.name.endsWith('.json')) {
                this.importFromJSON(content);
            } else if (file.name.endsWith('.csv')) {
                this.importFromCSV(content);
            }
        };
        reader.readAsText(file);
    }

    importFromJSON(jsonString) {
        try {
            const data = JSON.parse(jsonString);
            if (!data.quizData) throw new Error('Invalid backup format');

            if (confirm('現在のデータをすべて上書きして復旧しますか？\n（現在の問題・履歴・統計がすべて消え、ファイルの内容に置き換わります）')) {
                this.quizData = data.quizData;
                this.history = data.history || [];
                this.questionStats = data.questionStats || {};

                this.saveData();
                this.saveHistory();
                this.saveQuestionStats();

                alert('データを正常に復元しました。');
                window.location.reload();
            }
        } catch (err) {
            console.error(err);
            alert('ファイルの読み込みに失敗しました。有効なJSONバックアップファイルであることを確認してください。');
        }
    }

    importFromCSV(csvString) {
        try {
            const lines = csvString.split(/\r?\n/);
            if (lines.length < 2) return;

            // Simple CSV parser (not handling all escapes, but works for standard export)
            const parseCSVLine = (line) => {
                const parts = [];
                let current = '';
                let inQuotes = false;
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"' && line[i + 1] === '"') { current += '"'; i++; }
                    else if (char === '"') inQuotes = !inQuotes;
                    else if (char === ',' && !inQuotes) { parts.push(current); current = ''; }
                    else current += char;
                }
                parts.push(current);
                return parts;
            };

            const header = parseCSVLine(lines[0]);
            const newPages = new Map();

            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                const row = parseCSVLine(lines[i]);
                const pageTitle = row[0];
                const id = row[1] || ('q-' + Math.random().toString(36).substr(2, 9));
                const text = row[2];
                const answerRaw = row[3];
                const choices = row.slice(4).filter(c => c !== undefined && c !== "");

                if (!pageTitle || !text) continue;

                if (!newPages.has(pageTitle)) {
                    newPages.set(pageTitle, {
                        id: 'p-' + Date.now() + Math.random().toString(36).substr(2, 5),
                        title: pageTitle,
                        type: 'page',
                        parentId: null,
                        isCollapsed: false,
                        columns: ["項目", ...choices],
                        questions: [],
                        isMultiSelect: answerRaw.includes('|')
                    });
                }

                const page = newPages.get(pageTitle);
                page.questions.push({
                    id: id,
                    text: text,
                    answer: page.isMultiSelect ? answerRaw.split('|') : answerRaw,
                    isInPool: true
                });
            }

            if (confirm(`CSVから ${newPages.size} ページの問題を取り込みますか？\n既存のページは維持され、末尾に追加されます。`)) {
                this.quizData.push(...Array.from(newPages.values()));
                this.saveData();
                alert('CSVからデータを正常に取り込みました。');
                this.renderTOC();
                this.loadSet(this.currentSetId);
            }
        } catch (err) {
            console.error(err);
            alert('CSVの解析に失敗しました。');
        }
    }

    updateDataStatus(msg) {
        if (this.dataStatusMsg) {
            this.dataStatusMsg.textContent = `${msg} (${new Date().toLocaleTimeString()})`;
            this.dataStatusMsg.style.color = 'var(--success)';
            setTimeout(() => {
                this.dataStatusMsg.style.color = 'var(--text-secondary)';
            }, 5000);
        }
        // Save export timestamp for reminder
        if (msg.includes("エクスポート")) {
            localStorage.setItem('sharo_last_export_at', new Date().toISOString());
            this.checkBackupFrequency();
        }
    }

    // --- Automatic Recovery and Protection ---

    checkAndOfferRecovery(manual = false) {
        const backupStr = localStorage.getItem('sharo_auto_backup');
        if (!backupStr) {
            if (manual) alert('内部バックアップが見つかりません。');
            return;
        }

        try {
            const backup = JSON.parse(backupStr);
            const isMainEmpty = (this.quizData.length <= DEFAULT_QUIZ_DATA.length && this.history.length === 0);

            if (manual || isMainEmpty) {
                const date = new Date(backup.savedAt).toLocaleString();
                const msg = manual
                    ? `内部バックアップ（保存日時: ${date}）からデータを復元しますか？\n現在編集中の内容は上書きされます。`
                    : `【データ復旧の案内】\nメインデータが初期状態のようですが、内部バックアップ（保存日時: ${date}）が見つかりました。\n以前の状態を復元しますか？`;

                if (confirm(msg)) {
                    this.quizData = backup.quizData;
                    this.history = backup.history || [];
                    this.questionStats = backup.questionStats || {};
                    this.saveData();
                    this.saveHistory();
                    this.saveQuestionStats();
                    alert('データを正常に復元しました。');
                    window.location.reload();
                }
            }
        } catch (e) {
            console.error("Backup parse error", e);
        }
    }

    checkBackupFrequency() {
        const lastExport = localStorage.getItem('sharo_last_export_at');
        if (!lastExport) return;

        const hoursSince = (Date.now() - new Date(lastExport).getTime()) / (1000 * 60 * 60);
        if (hoursSince > 24) {
            const reminderArea = document.getElementById('backup-reminder');
            if (reminderArea) {
                reminderArea.style.display = 'block';
                reminderArea.innerHTML = `⚠️ 最終エクスポートから24時間以上経過しています。大切なデータを守るため、<span style="color:var(--accent); cursor:pointer; text-decoration:underline;" onclick="app.exportToJSON()">JSONバックアップの保存</span>をお勧めします。`;
            }
        } else {
            const reminderArea = document.getElementById('backup-reminder');
            if (reminderArea) reminderArea.style.display = 'none';
        }
    }
}
let app;
document.addEventListener('DOMContentLoaded', () => {
    app = new QuizApp();
    window.app = app; // Correctly expose app to global for onclick handlers
});
